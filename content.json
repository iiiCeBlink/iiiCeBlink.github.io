{"meta":{"title":"zakariyyasv's blog","subtitle":"","description":"Just forcus","author":"zakariyyasv","url":"http://zakariyyasv.pub"},"pages":[{"title":"categories","date":"2016-08-30T13:07:24.000Z","updated":"2016-08-30T13:08:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://zakariyyasv.pub/categories/index.html","excerpt":"","text":""},{"title":"iOS","date":"2016-08-30T12:56:19.000Z","updated":"2016-08-30T12:56:19.000Z","comments":true,"path":"iOS/index.html","permalink":"http://zakariyyasv.pub/iOS/index.html","excerpt":"","text":""}],"posts":[{"title":"CFNetwork学习笔记（四）","slug":"CFNetwork学习笔记（四）","date":"2016-10-10T08:46:53.000Z","updated":"2016-10-22T04:59:18.000Z","comments":true,"path":"2016/10/10/CFNetwork学习笔记（四）/","link":"","permalink":"http://zakariyyasv.pub/2016/10/10/CFNetwork学习笔记（四）/","excerpt":"前言本篇文章主要讲述用CFHTTPAuthentication API如何与HTTP认证服务器交互，如何找到合适的认证对象和证书并填入到HTTP请求中。一般而言，如果HTTP服务器给你的HTTP请求返回401或407，就意味着服务器是认证服务器并且要求证书。在CFHTTPAuthentication API中，每个证书集合都被存储在CFHTTPAuthentication对象中。因此，每个不同的认证服务器和连接到服务器的不同用户都需要存储在独立的CFHTTPAuthentication对象中。为了能与服务器进行通信，你需要将CFHTTPAuthentication存储到HTTP请求当中。后面会对这些步骤进行详细解释。","text":"前言本篇文章主要讲述用CFHTTPAuthentication API如何与HTTP认证服务器交互，如何找到合适的认证对象和证书并填入到HTTP请求中。一般而言，如果HTTP服务器给你的HTTP请求返回401或407，就意味着服务器是认证服务器并且要求证书。在CFHTTPAuthentication API中，每个证书集合都被存储在CFHTTPAuthentication对象中。因此，每个不同的认证服务器和连接到服务器的不同用户都需要存储在独立的CFHTTPAuthentication对象中。为了能与服务器进行通信，你需要将CFHTTPAuthentication存储到HTTP请求当中。后面会对这些步骤进行详细解释。 认证添加对认证的支持能让你的app与HTTP认证服务器进行会话，即使即使HTTP认证不是复杂的概念，但要去实现它却是比较复杂的过程。整个的过程如下： 1.客户端向服务器发送HTTP请求。2.服务端要求客户端进行认证。3.客户端将原始的请求和证书一起打包重新发给服务器。4.客户端和服务器进行通信。5.当服务器对客户端认证完成后，它会将请求的响应返回给客户端。 当HTTP请求返回401或407时，客户端第一步要做的是找到可靠的CFHTTPAuthentication对象。认证对象中包含证书和其他向服务器认证需要的信息。如果你已经跟服务器认证过了，你就会有有效的认证对象。然而，在大多数情况下，你需要调用CFHTTPAuthenticationCreateFromResponse方法创建认证对象。 1234567891011if (!authentication) &#123; CFHTTPMessageRef responseHeader = (CFHTTPMessageRef) CFReadStreamCopyProperty( readStream, kCFStreamPropertyHTTPResponseHeader ); // Get the authentication information from the response. authentication = CFHTTPAuthenticationCreateFromResponse(NULL, responseHeader); CFRelease(responseHeader);&#125; 如果创建的认证对象是有效的，那就可以继续下一步了。如果认证对象是无效的，就检查看证书是否已经损坏。更多关于证书的信息，可以阅读Security Credentials中的内容。损坏的证书意味着服务器不接受登录信息并且继续监听新的证书。然而，如果证书是完好的而服务器拒绝了app发出的请求，那就是说服务器拒绝与app进行通信，这时候就必须放弃。在证书损坏的情况下，重新创建认证对象并重复认证的步骤直到得到有效的认证对象。以下为代码示例： 1234567891011121314151617181920212223242526// 查找有效的认证对象 Code 4-1CFStreamError err;if (!authentication) &#123; // the newly created authentication object is bad, must return return; &#125; else if (!CFHTTPAuthenticationIsValid(authentication, &amp;err)) &#123; // destroy authentication and credentials if (credentials) &#123; CFRelease(credentials); credentials = NULL; &#125; CFRelease(authentication); authentication = NULL; // check for bad credentials (to be treated separately) if (err.domain == kCFStreamErrorDomainHTTP &amp;&amp; (err.error == kCFStreamErrorHTTPAuthenticationBadUserName || err.error == kCFStreamErrorHTTPAuthenticationBadPassword))&#123; retryAuthorizationFailure(&amp;authentication); return; &#125; else &#123; errorOccurredLoadingImage(err); &#125;&#125; 现在，你已经有了有效的认证对象，继续上面流程图下面的步骤。第一步，向服务器请求是否需要证书。如果不需要，直接将认证对象添加到HTTP请求当中。 12345678910void resumeWithCredentials() &#123; // Apply whatever credentials we've built up to the old request if (!CFHTTPMessageApplyCredentialDictionary(request, authentication, credentials, NULL)) &#123; errorOccurredLoadingImage(); &#125; else &#123; // Now that we've updated our request, retry the load loadRequest(); &#125;&#125; 如果内存和磁盘中没有存储证书，获取有效证书的唯一方式是向用户请求。大部分情况下，证书都需要用户名和密码。将认证对象传入CFHTTPAuthenticationRequiresUserNameAndPassword方法中就可以知道用户名和密码是否是必须的。如果证书需要用户名和密码，想用户请求并将它们存储在证书的字典中。对于NTLM服务器而言，证书还需要提供域名。在你有了新的证书后，你可以调用resumeWithCredentials方法将认证对象添加到HTTP请求当中。 123456789101112131415161718192021222324252627282930313233343536373839// ...continued from Code 4-1else &#123; cancelLoad(); if (credentials) &#123; resumeWithCredentials(); &#125; // are a user name &amp; password needed? else if (CFHTTPAuthenticationRequiresUserNameAndPassword(authentication)) &#123; CFStringRef realm = NULL; CFURLRef url = CFHTTPMessageCopyRequestURL(request); // check if you need an account domain so you can display it if necessary if (!CFHTTPAuthenticationRequiresAccountDomain(authentication)) &#123; realm = CFHTTPAuthenticationCopyRealm(authentication); &#125; // ...prompt user for user name (user), password (pass) // and if necessary domain (domain) to give to the server... // Guarantee values if (!user) user = CFSTR(\"\"); if (!pass) pass = CFSTR(\"\"); CFDictionarySetValue(credentials, kCFHTTPAuthenticationUsername, user); CFDictionarySetValue(credentials, kCFHTTPAuthenticationPassword, pass); // Is an account domain needed? (used currently for NTLM only) if (CFHTTPAuthenticationRequiresAccountDomain(authentication)) &#123; if (!domain) domain = CFSTR(\"\"); CFDictionarySetValue(credentials, kCFHTTPAuthenticationAccountDomain, domain); &#125; if (realm) CFRelease(realm); CFRelease(url); &#125; else &#123; resumeWithCredentials(); &#125;&#125; 将证书保存在内存中如果你需要频繁和认证服务器进行通信，那么重复利用证书可以避免多次向用户请求用户名和密码。为了重复利用证书，有三种数据结构需要在代码中做出修改。 1.创建可变数组CFMutableArrayRef取代CFHTTPAuthenticationRef对象来存储所有的认证对象CFHTTPAuthenticationRef authentication; -&gt; CFMutableArrayRef authArray;2.使用字典创建认证对象到证书的映射CFMutableDictionaryRef credentials; -&gt; CFMutableDictionaryRef credentialsDict;3.在所有更新当前认证对象和当前证书的地方保存这些结构CFRelease(credentials); -&gt; CFDictionaryRemoveValue(credentialsDict, authentication); 在创建HTTP请求后，需要查找匹配的认证对象。以下代码是很简易的且未优化的查找合适对象的方法： 1234567891011CFHTTPAuthenticationRef findAuthenticationForRequest &#123; int i, c = CFArrayGetCount(authArray); for (i = 0; i &lt; c; i ++) &#123; CFHTTPAuthenticationRef auth = (CFHTTPAuthenticationRef) CFArrayGetValueAtIndex(authArray, i); if (CFHTTPAuthenticationAppliesToRequest(auth, request)) &#123; return auth; &#125; &#125; return NULL;&#125; 如果认证数组中查找到匹配的认证对象，然后检查证书存储中是否可以获取。这样做防止你再次向用户请求用户名和密码。查找证书可以调用CFDictionaryGetValue方法。 1credentials = CFDictionaryGetValue(credentialsDict, authentication); 然后将匹配的认证对象和证书添加到原始的HTTP请求中并重新发送。注意，在每一偶收到服务器认证消息之前不要将证书添加到HTTP请求中。服务器可能自从上一次认证过后改变了认证策略，你这样做可能会发生安全危险。 通过以上三种结构的改变，你的app能够将认证对象和证书存储在内存当中。 将证书保存在持久化仓库中将证书存储在内存中可以防止在指定app启动时用户重复输入用户名和密码。然而，当app退出时，这些证书会被释放。为了避免丢失证书，我们将每个服务器的证书存储在持久化仓库中并且只需要生成一次。钥匙串是存储证书非常推荐的位置。即使你有多个钥匙串，默认会将用户的默认钥匙串作为存储证书的位置。使用钥匙串意味着你存储的认证信息同样可以在其他的app中使用。 在钥匙串中存储和获取证书依赖于两个方法：一个是用来查找认证的证书字典，另一个是用来存储请求中的证书。 1234CFMutableDictionaryRef findCredentialsForAuthentication( CFHTTPAuthenticationRef auth); void saveCredentialsForRequest(void); findCredentialsForAuthentication方法首先会检查存储在内存中的证书字典是否在本地有缓存。如果证书在内存中没有缓存，之后就搜索钥匙串。调用SecKeychainFindInternetPassword方法搜索钥匙串。该方法要求很多参数： keychainOrArray：NULL指定用户默认的钥匙串列表。serverNameLength：服务器名字长度，通常是strlen(serverName)。serverName：解析HTTP请求的服务器名字。securityDomainLength：安全域名的长度，如果没有域名传入0。securityDomain：认证对象的范围，可从CFHTTPAuthenticationCopyRealm方法中获取。accountNameLength：用户名的长度。如果用户名为空，则传入0。accountName：用户名。pathLength：路径的长度，如果没有路径则传入0。path：认证对象的路径，可从CFURLCopyPath方法中获取。port：端口号，可从CFURLGetPortNumber方法中获取。protocol：协议，可从CFURLCopyScheme方法中获取。authenticationType：认证类型，可从CFHTTPAuthenticationCopyMethod方法中获取。passwordLength：密码长度。0，因为在获取钥匙串许可时没有密码是必须的。passwordData：密码数据。NULL，因为在获取钥匙串许可时没有密码是必须的。itemRef：钥匙串条目。 1234567891011didFind = SecKeychainFindInternetPassword(NULL, strlen(host), host, realm ? strlen(realm) : 0, realm, 0, NULL, path ? strlen(path) : 0, path, port, protocolType, authenticationType, 0, NULL, &amp;itemRef); 当SecKeychainFindInternetPassword方返回成功时，创建钥匙串属性列表（SecKeychainAttributeList）存储钥匙串属性（SecKeychainAttribute）。钥匙串属性列表会存储用户名和密码。要加载钥匙串属性列表，调用SecKeychainItemCopyContent方法并将SecKeychainFindInternetPassword方法返回的钥匙串条目对象传入。该方法会用用户的用户名和密码填充钥匙串属性。以下代码示例表示从要是传中加载服务器证书： 123456789101112131415161718192021222324252627282930313233343536373839404142if (didFind == noErr) &#123; SecKeychainAttribute attr; SecKeychainAttributeList attrList; UInt32 length; void *outData; // To set the account name attribute attr.tag = kSecAccountItemAttr; attr.length = 0; attr.data = NULL; attrList.count = 1; attrList.attr = &amp;attr; if (SecKeychainItemCopyContent(itemRef, NULL, &amp;attrList, &amp;length, &amp;outData) == noErr) &#123; // attr.data is the account (username) and outdata is the password CFStringRef username = CFStringCreateWithBytes(kCFAllocatorDefault, attr.data, attr.length, kCFStringEncodingUTF8, false); CFStringRef password = CFStringCreateWithBytes(kCFAllocatorDefault, outData, length, kCFStringEncodingUTF8, false); SecKeychainItemFreeContent(&amp;attrList, outData); // create credentials dictionary and fill it with the user name &amp; password credentials = CFDictionaryCreateMutable(NULL, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CFDictionarySetValue(credentials, kCFHTTPAuthenticationUsername, username); CFDictionarySetValue(credentials, kCFHTTPAuthenticationPassword, password); CFRelease(username); CFRelease(password); &#125; CFRelease(itemRef);&#125; 如果你可以在钥匙串中存储证书，那么从钥匙串中获取证书会起作用。这些步骤与加载证书非常类似。首先，查看证书是否存储在要是传中。调用SecKeychainFindInternetPassword方法并传入用户名和用户名长度。如果证书存在，修改它的密码。设置data存入用户名，这样就可以修改正确的属性。然后调用SecKeychainItemModifyContent方法传入item、钥匙串属性列表和新密码。修改钥匙串许可而不是复写它，钥匙串许可会正确地更新并且任何与之关联的元数据都会得到保存。代码如下： 1234567// Set the attribute to the account nameattr.tag = kSecAccountItemAttr;attr.length = strlen(username);attr.data = (void*)username; // Modify the keychain entrySecKeychainItemModifyContent(itemRef, &amp;attrList, strlen(password), (void *)password); 如果许可不存在，你就需要创建它。SecKeychainAddInternetPassword方法可以完成这个工作，该方法的参数与SecKeychainFindInternetPassword方法一致，不一样的地方在于在SecKeychainAddInternetPassword方法中需要用户名和密码。成功调用后，若不需要再使用item则将其释放。 防火墙认证防火墙认证与服务器认证很相似，但防火墙认证在HTTP请求失败后需要同时进行代理认证和服务器认证。这意味着你需要对代理服务器和原始服务器分开进行存储。因而，返回失败的响应后所做的操作应该是： 检查响应码是不是407.如果是，在内存代理存储和磁盘代理存储中找到匹配的认证对象和证书。如果都没有合适的对象和证书，则向用户请求证书，然后将认证对象添加到HTTP请求中并重试。 检查响应码是不是401。如果是，重复407下的做法，只是查找的是原始服务器存储。 除此之外，当使用代理服务器时还有些小差别。第一就是钥匙串调用方法的参数来自于代理主机和端口而不是原始服务器的URL。第二就是当向用户请求用户名和密码的时候，确保提示清楚地说明密码是什么。 只要遵循这些操作，app就能成功与认证防火墙工作。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}],"tags":[],"keywords":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}]},{"title":"CFNetwork学习笔记（三）","slug":"CFNetwork学习笔记（三）","date":"2016-10-07T06:39:12.000Z","updated":"2016-10-22T05:04:33.000Z","comments":true,"path":"2016/10/07/CFNetwork学习笔记（三）/","link":"","permalink":"http://zakariyyasv.pub/2016/10/07/CFNetwork学习笔记（三）/","excerpt":"前言本篇文章主要介绍如何创建、发送和接收HTTP请求和响应。","text":"前言本篇文章主要介绍如何创建、发送和接收HTTP请求和响应。 创建CFHTTP请求HTTP请求实际上是包含了请求方法、URL、消息头和消息体的消息。请求方法通常是GET, HEAD, PUT, POST, DELETE, TRACE, CONNECT 或 OPTIONS。用CFHTTP创建HTTP请求需要四个步骤： 1.调用CFHTTPMessageCreateRequest方法生成CFHTTP消息对象。2.调用CFHTTPMessageSetBody方法设置消息体。3.调用CFHTTPMessageSetHeaderFieldValue方法设置消息头。4.调用CFHTTPMessageCopySerializedMessage方法对消息进行序列化。 1234567891011121314151617// 创建HTTP请求CFStringRef bodyString = CFSTR(\"\"); // Usually used for POST dataCFDataRef bodyData = CFStringCreateExternalRepresentation(kCFAllocatorDefault, bodyString, kCFStringEncodingUTF8, 0); CFStringRef headerFieldName = CFSTR(\"X-My-Favorite-Field\");CFStringRef headerFieldValue = CFSTR(\"Dreams\"); CFStringRef url = CFSTR(\"http://www.apple.com\");CFURLRef myURL = CFURLCreateWithString(kCFAllocatorDefault, url, NULL); CFStringRef requestMethod = CFSTR(\"GET\");CFHTTPMessageRef myRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, myURL, kCFHTTPVersion1_1); CFDataRef bodyDataExt = CFStringCreateExternalRepresentation(kCFAllocatorDefault, bodyData, kCFStringEncodingUTF8, 0);CFHTTPMessageSetBody(myRequest, bodyDataExt);CFHTTPMessageSetHeaderFieldValue(myRequest, headerFieldName, headerFieldValue);CFDataRef mySerializedRequest = CFHTTPMessageCopySerializedMessage(myRequest); 在上面这段代码中，url会被CFURLCreateWithString方法转换成CFURL对象。然后，调用CFHTTPMessageCreateRequest创建HTTP请求对象。之后，将创建的对象连同消息体（bodyData）传入CFHTTPMessageSetBody方法中，将请求对象连同消息头的名字（headerField）和值（value）传入CFHTTPMessageSetHeaderFieldValue方法中，headerField参数接受CFString类型的对象如Content-Length，value参数接受CFString类型的对象如1260。最后，调用CFHTTPMessageCopySerializedMessage方法对消息进行序列化并且通过写入流发送到接受者那里。 当请求不再需要时，我们需要释放消息对象和序列化的消息。 123456CFRelease(myRequest);CFRelease(myURL);CFRelease(url);CFRelease(mySerializedRequest);myRequest = NULL;mySerializedRequest = NULL; 创建CFHTTP响应创建HTTP响应的步骤与创建HTTP请求的步骤是一致的。唯一的区别在于是调用CFHTTPMessageCreateResponse方法而不是CFHTTPMessageCreateRequest方法。 反序列化HTTP请求要对收到的HTTP请求进行反序列化操作，首先要调用CFHTTPMessageCreateEmpty方法创建空的消息对象，并在isRequest参数中传入true表示创建的是请求消息对象。然后，调用CFHTTPMessageAppendBytes方法将接收到的HTTP请求添加到消息对象中去。CFHTTPMessageAppendBytes方法会反序列化消息并且移除它保存的任何控制信息。一直不停地循环去调用该方法直到CFHTTPMessageIsHeaderComplete返回true。若CFHTTPMessageIsHeaderComplete没有返回true，说明消息是不完整的。 1234CFHTTPMessageRef myMessage = CFHTTPMessageCreateEmpty(kCFAllocatorDefault, TRUE);if (!CFHTTPMessageAppendBytes(myMessage, &amp;data, numBytes)) &#123; //Handle parsing error&#125; 在CFHTTPMessageAppendBytes方法中，data参数表示要被添加进消息对象中的数据，numBytes参数表示data的大小。你可以调用CFHTTPMessageIsHeaderComplete方法去验证添加消息是否完成。123if (CFHTTPMessageIsHeaderComplete(myMessage)) &#123; // Perform processing.&#125; 当消息反序列化完成后，你可以调用下面的方法从消息对象中截取信息： CFHTTPMessageCopyBody：获取消息体的拷贝 CFHTTPMessageCopyHeaderFieldValue：获取指定头部区域的拷贝 CFHTTPMessageCopyAllHeaderFields：获取所有消息头的拷贝 CFHTTPMessageCopyRequestURL：获取消息的URL的拷贝 CFHTTPMessageCopyRequestMethod：获取消息请求方法的拷贝 当你不在需要消息对象时，需要正确地对其进行释放和销毁操作。 反序列化HTTP响应正如创建HTTP请求和创建HTTP响应很相似，反序列化HTTP请求和反序列化HTTP响应也非常相似。唯一重要的区别在于当调用CFHTTPMessageCreateEmpty方法时，你必须给isRequest参数传入false表示创建的消息是响应消息。 使用读流序列化和发送HTTP请求你可以使用CFReadStream对象序列化和发送CFHTTP请求。当你使用CFReadStream对象发送CFHTTP请求时，打开流会让消息的序列化和发送在一步中完成。使用CFReadStream对象发送CFHTTP请求让获取响应变得容易因为响应会作为流的属性而被访问。 序列化和发送HTTP请求要使用CFReadStream对象序列化和发送HTTP请求，首先要创建CFHTTP请求并设置消息头和消息体。然后，调用CFReadStreamCreateForHTTPRequest方法创建CFReadStream对象并传入先前创建的请求。最后，调用CFReadStreamOpen打开读流。 当CFReadStreamCreateForHTTPRequest方法被调用时，它会将传入的CFHTTP请求对象进行拷贝。因而，如果必要，你应该在调用完CFReadStreamCreateForHTTPRequest方法后立即释放CFHTTP请求对象。因为读流要与指定的服务器建立套接字连接，所以在流可以打开之前需要耗费一部分时间。打开读流同样会引起请求的序列化和发送操作。 1234567891011CFStringRef url = CFSTR(\"http://www.apple.com\");CFURLRef myURL = CFURLCreateWithString(kCFAllocatorDefault, url, NULL);CFStringRef requestMethod = CFSTR(\"GET\"); CFHTTPMessageRef myRequest = CFHTTPMessageCreateRequest(kCFAllocatorDefault, requestMethod, myUrl, kCFHTTPVersion1_1);CFHTTPMessageSetBody(myRequest, bodyData);CFHTTPMessageSetHeaderFieldValue(myRequest, headerField, value); CFReadStreamRef myReadStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest); CFReadStreamOpen(myReadStream); 检查响应在你将请求添加到runloop中后，你最终会得到完整的头部回调。这时候，你可以调用CFReadStreamCopyProperty方法从读流中获取消息的响应。 1CFHTTPMessageRef myResponse = (CFHTTPMessageRef)CFReadStreamCopyProperty(myReadStream, kCFStreamPropertyHTTPResponseHeader); 你可以调用CFHTTPMessageCopyResponseStatusLine方法从响应消息中得到状态行。 1CFStringRef myStatusLine = CFHTTPMessageCopyResponseStatusLine(myResponse); 或者，调用CFHTTPMessageGetResponseStatusCode方法得到响应消息的状态码。 1UInt32 myErrCode = CFHTTPMessageGetResponseStatusCode(myResponse); 处理认证错误如果CFHTTPMessageGetResponseStatusCode方法返回的状态码是401（远程服务器要求认证信息）或407（代理服务器要求认证），你需要将认证信息添加到请求中并重新发送。 处理重定向错误当调用CFReadStreamCreateForHTTPRequest方法创建读流，默认情况下流的自动重定向是被禁用的。如果请求指向的URL被重定向给另一个URL，你需要关闭流并重新创建流，打开流的重定向选项，最后打开流。 1234567CFReadStreamClose(myReadStream);CFReadStreamRef myReadStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, myRequest);if (CFReadStreamSetProperty(myReadStream, kCFStreamPropertyHTTPShouldAutoredirect, kCFBooleanTrue) == false) &#123; // something went wrong, exit&#125;CFReadStreamOpen(myReadStream); 取消正在发送的请求一旦请求发送出去后，就不可能阻止远程服务器对其进行操作。然而，如果你不再关心响应数据，你可以关闭流。注意，当另一个线程在同一个流中等待数据时不要从任何线程中关闭流。如果你需要终结请求，你需要使用不阻塞的方式（参见CFNetwork学习笔记（二））。在关闭流之前要确保将流从runloop中移除。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}],"tags":[],"keywords":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}]},{"title":"CFNetwork学习笔记（二）","slug":"CFNetwork学习笔记（二）","date":"2016-10-06T12:50:01.000Z","updated":"2016-10-22T05:00:22.000Z","comments":true,"path":"2016/10/06/CFNetwork学习笔记（二）/","link":"","permalink":"http://zakariyyasv.pub/2016/10/06/CFNetwork学习笔记（二）/","excerpt":"前言本篇文章主要讨论如何创建、开启读写流并检查读写流上的错误。此外，还会介绍如何从读流中读出数据，如何向写流中写入数据，如何在读写的过程中防止发生阻塞，如何通过代理服务器来引导流。 CFStream可以用来读写文件或者与socket一起工作。除了创建流的过程之外，它们其他的行为都很相似。","text":"前言本篇文章主要讨论如何创建、开启读写流并检查读写流上的错误。此外，还会介绍如何从读流中读出数据，如何向写流中写入数据，如何在读写的过程中防止发生阻塞，如何通过代理服务器来引导流。 CFStream可以用来读写文件或者与socket一起工作。除了创建流的过程之外，它们其他的行为都很相似。 ReadStream要使用读流，首先需要创建读流对象，代码如下：1CFReadStreamRef myReadStream = CFReadStreamCreateWithFile(kCFAllocatorDefault, fileURL); 在这段代码中，kCFAllocatorDefault参数指定了当前为流分配内存的默认系统分配器，fileURL参数指明了读入文件的文件名，例如file:///Users/joeuser/Downloads/MyApp.sit。 创建成功后就可以打开它。打开流会导致流持有任何它需要的系统资源，如文件描述子用来打开文件。打开流的代码如下： 1234567891011if (!CFReadStreamOpen(myReadStream)) &#123; CFStreamError myErr = CFReadStreamGetError(myReadStream); // An error has occurred. if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123; // Interpret myErr.error as a UNIX errno. &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123; // Interpret myErr.error as a MacOS error code. OSStatus macError = (OSStatus)myErr.error; // Check other error domains. &#125;&#125; CFReadStreamOpen方法如果返回true则代表成功，返回false则表示由于某些原因而打开失败。如果CFReadStreamOpen返回false，上面代码中会调用CFReadStreamGetError方法，该方法会返回CFStreamError类型的结构，其包含两个值：域代码和错误代码。域代码指定如何翻译错误代码。例如，如果域代码是kCFStreamErrorDomainPOSIX，那错误代码就是UNIX errno值。另外的错误域则是kCFStreamErrorDomainMacOSStatus，它指定的错误代码是定义在MacErrors.h中的OSStatus类型的值；还有错误域kCFStreamErrorDomainHTTP，它指定的错误代码是CFStreamErrorHTTP类型的枚举值。 打开流可能是很长的过程，因此为了避免阻塞，CFReadStreamOpen和CFWriteStreamOpen方法通过返回true说明打开流的进程已经开始。我们可以通过调用CFReadStreamGetStatus和CFWriteStreamGetStatus方法检查开启的状态，如果开启还在进行中，则返回kCFStreamStatusOpening，如果开启完成，则返回kCFStreamStatusOpen，如果开启完成但发生了错误，则返回kCFStreamStatusErrorOccurred。在大多数情况下，无论打开动作是否完成都无关紧要，因为CFStream的读写方法在流未打开时是一直处于阻塞状态的。 打开操作完成后，就需要从读流中读取数据，这就需要调用CFReadStreamRead方法，这与UNIX的系统调用read()相似。这两个方法都有缓冲区和缓冲区长度的参数，都返回读取字节的状态码，如果读取到流或文件的最后则返回0，如果发生错误则返回-1，都会在字节流可以读取之前处于阻塞状态，都会在不阻塞的情况下继续读取直到最后。以下为读取代码： 1234567891011CFIndex numBytesRead;do &#123; UInt8 buf[myReadBufferSize]; // define myReadBufferSize as desired numBytesRead = CFReadStreamRead(myReadStream, buf, sizeof(buf)); if( numBytesRead &gt; 0 ) &#123; handleBytes(buf, numBytesRead); &#125; else if( numBytesRead &lt; 0 ) &#123; CFStreamError error = CFReadStreamGetError(myReadStream); reportError(error); &#125;&#125; while( numBytesRead &gt; 0 ); 当所有的数据读取完毕后，你应该调用CFReadStreamClose方法来关闭流，并且释放预置相关联的系统资源。然后，通过调用CFRelease方法释放stream对象的引用。你还可以通过将其设置为NULL来使其引用失效。 123CFReadStreamClose(myReadStream);CFRelease(myReadStream);myReadStream = NULL; WriteStream写入流与读出流原理很相似。主要的区别在于CFWriteStreamWrite不保证会接收你传入的所有字节，而是会返回它接收的字节数目。注意看下面的代码，如果写入的字节数与需要写入的总字节数不一致，缓冲区会自动调节去容纳它。 123456789101112131415161718192021222324252627282930313233343536373839CFWriteStreamRef myWriteStream = CFWriteStreamCreateWithFile(kCFAllocatorDefault, fileURL);if (!CFWriteStreamOpen(myWriteStream)) &#123; CFStreamError myErr = CFWriteStreamGetError(myWriteStream); // An error has occurred. if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123; // Interpret myErr.error as a UNIX errno. &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123; // Interpret myErr.error as a MacOS error code. OSStatus macError = (OSStatus)myErr.error; // Check other error domains. &#125;&#125;UInt8 buf[] = “Hello, world”;CFIndex bufLen = (CFIndex)strlen(buf); while (!done) &#123; CFIndex bytesWritten = CFWriteStreamWrite(myWriteStream, buf, (CFIndex)bufLen); if (bytesWritten &lt; 0) &#123; CFStreamError error = CFWriteStreamGetError(myWriteStream); reportError(error); &#125; else if (bytesWritten == 0) &#123; if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd) &#123; done = TRUE; &#125; &#125; else if (bytesWritten != bufLen) &#123; // Determine how much has been written and adjust the buffer bufLen = bufLen - bytesWritten; memmove(buf, buf + bytesWritten, bufLen); // Figure out what went wrong with the write stream CFStreamError error = CFWriteStreamGetError(myWriteStream); reportError(error); &#125;&#125;CFWriteStreamClose(myWriteStream);CFRelease(myWriteStream);myWriteStream = NULL; 防止阻塞当使用流进行通信，特别是基于socket的流时，数据传输可能会耗费很长时间。如果你同步实现了流服务那整个app将会在数据传输上强制等待。因此，异常推荐使用替代方法来阻止阻塞。 当对CFStream对象进行读写操作时有两种方式来防止阻塞： runloop——注册接收流相关事件并将stream加入到runloop中。当流相关事件发生时，回调函数会被调用。 调查——对于读流，在从流中读取之前检查是否有字节可读，对于写流，在写入流之前检查流是否可被写入。 runloop使用runloop是比较推荐的方式。runloop在主线程中运行，它会一直等待事件的发生，然后会调用与事件关联的方法。在网络传输过程中，当注册的事件发生时，回调函数会被runloop调用执行。这意味着我们不需要去检查套接字流，也就不会拖慢线程的运行效率。 我们以代码来进一步说明，首先创建套接字读流：1CFStreamCreatePairWithSocketToCFHost(kCFAllocatorDefault, host, port, &amp;myReadStream, NULL); 其中host参数代表读流指向的主机，port参数代表主机使用的端口号，CFStreamCreatePairWithSocketToCFHost方法返回新的读流对象的引用并将其存储在myReadStream地址中。最后一个参数NULL代表调用者不想创建写流。如果你想创建写流，就传入对象的地址如&amp;myWriteStream。 在打开套接字读流之前，需要创建上下文，这在注册接收流相关事件的时候会用到：1CFStreamClientContext myContext = &#123;0, myPtr, myRetain, myRelease, myCopyDesc&#125;; 第一个参数0代表版本号，info参数即myPtr是指向你想要传给回调函数的数据的指针，通常，myPrt指向的结构体中包含的都是与流相关的信息。retain参数是指向持有info参数的方法的指针，如果你像上面代码中一样设置了它，CFStream会调用myRetain(myPtr)方法持有info指针。类似地，release参数是指向释放info参数方法的指针，当流与上下文断开连接，CFStream会调用myRelease(myPtr)方法。最后一个参数copyDescription是关于流描述信息的方法。例如，如果你用流上下文调用CFCopyDesc(myReadStream)方法，CFStream回你调用myCopyDesc(myPtr)。此外，上下文也允许将retain、release和copyDescription参数置为NULL。如果你将retain、release参数置为NULL，系统会在流对象被销毁前一直让info参数指向的内存存活。如果你将copyDescription参数置为NULL，系统会在必要的时候给出info指针指向的内存中的内容的基本描述。 创建完上下文后，调用CFReadStreamSetClient方法来注册接收流相关事件。CFReadStreamSetClient方法要求你指定回调方法和你想要接收的事件。下面的代码中，回调方法想要接收kCFStreamEventHasBytesAvailable, kCFStreamEventErrorOccurred和 kCFStreamEventEndEncountered事件。最后调用CFReadStreamScheduleWithRunLoop方法将stream添加到runloop中去。 1234CFOptionFlags registeredEvents = kCFStreamEventHasBytesAvailable | kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;if (CFReadStreamSetClient(myReadStream, registeredEvents, myCallBack, &amp;myContext))&#123; CFReadStreamScheduleWithRunLoop(myReadStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);&#125; 成功将stream添加到runloop中后，就可以打开stream了： 123456789101112131415if (!CFReadStreamOpen(myReadStream)) &#123; CFStreamError myErr = CFReadStreamGetError(myReadStream); if (myErr.error != 0) &#123; // An error has occurred. if (myErr.domain == kCFStreamErrorDomainPOSIX) &#123; // Interpret myErr.error as a UNIX errno. strerror(myErr.error); &#125; else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123; OSStatus macError = (OSStatus)myErr.error; &#125; // Check other domains. &#125; else // start the run loop CFRunLoopRun();&#125; 现在，等待你的回调方法被执行。在回调方法中，检查事件码并做相应的处理： 123456789101112131415161718192021222324252627282930void myCallBack (CFReadStreamRef stream, CFStreamEventType event, void *myPtr) &#123; switch(event) &#123; case kCFStreamEventHasBytesAvailable: // It is safe to call CFReadStreamRead; it won’t block because bytes // are available. UInt8 buf[BUFSIZE]; CFIndex bytesRead = CFReadStreamRead(stream, buf, BUFSIZE); if (bytesRead &gt; 0) &#123; handleBytes(buf, bytesRead); &#125; // It is safe to ignore a value of bytesRead that is less than or // equal to zero because these cases will generate other events. break; case kCFStreamEventErrorOccurred: CFStreamError error = CFReadStreamGetError(stream); reportError(error); CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes); CFReadStreamClose(stream); CFRelease(stream); break; case kCFStreamEventEndEncountered: reportCompletion(); CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes); CFReadStreamClose(stream); CFRelease(stream); break; &#125;&#125; 当回调方法接收到kCFStreamEventHasBytesAvailable时，会调用CFReadStreamRead方法读取数据。当回调方法接收到kCFStreamEventErrorOccurred时，会调用CFReadStreamGetError方法获取错误对象并调用reportError方法处理错误。当回调方法接收到kCFStreamEventEndEncountered时，会调用reportCompletion方法处理最后的数据，然后调用CFReadStreamUnscheduleFromRunLoop方法将stream对象从指定的runloop中移除。最后，调用CFReadStreamClose方法关闭流，调用CFRelease释放流对象的引用。 调查总的来说，调查网络流是不推荐的。然而，在某些特殊的环境下，这种方式会比较有效。首先你要检查流是否准备好进行读写操作，然后在流上执行读写操作。当向写流中写入时，你可以调用CFWriteStreamCanAcceptBytes方法来决定流是否开始接收数据。如果返回true，就可以确保在之后的CFWriteStreamWrite方法调用在不阻塞的情况下可以立即发送数据。类似地，对于读流，在调用CFReadStreamRead方法之前，先调用CFReadStreamHasBytesAvailable方法。具体的代码示例如下： 12345678910111213141516171819// Polling in a read streamwhile (!done) &#123; if (CFReadStreamHasBytesAvailable(myReadStream)) &#123; UInt8 buf[BUFSIZE]; CFIndex bytesRead = CFReadStreamRead(myReadStream, buf, BUFSIZE); if (bytesRead &lt; 0) &#123; CFStreamError error = CFReadStreamGetError(myReadStream); reportError(error); &#125; else if (bytesRead == 0) &#123; if (CFReadStreamGetStatus(myReadStream) == kCFStreamStatusAtEnd) &#123; done = TRUE; &#125; &#125; else &#123; handleBytes(buf, bytesRead); &#125; &#125; else &#123; // ...do something else while you wait... &#125;&#125; 12345678910111213141516171819202122232425262728// Polling in a write streamUInt8 buf[] = “Hello, world”;UInt32 bufLen = strlen(buf); while (!done) &#123; if (CFWriteStreamCanAcceptBytes(myWriteStream)) &#123; int bytesWritten = CFWriteStreamWrite(myWriteStream, buf, strlen(buf)); if (bytesWritten &lt; 0) &#123; CFStreamError error = CFWriteStreamGetError(myWriteStream); reportError(error); &#125; else if (bytesWritten == 0) &#123; if (CFWriteStreamGetStatus(myWriteStream) == kCFStreamStatusAtEnd) &#123; done = TRUE; &#125; &#125; else if (bytesWritten != strlen(buf)) &#123; // Determine how much has been written and adjust the buffer bufLen = bufLen - bytesWritten; memmove(buf, buf + bytesWritten, bufLen); // Figure out what went wrong with the write stream CFStreamError error = CFWriteStreamGetError(myWriteStream); reportError(error); &#125; &#125; else &#123; // ...do something else while you wait... &#125;&#125; 防火墙在stream中应用防火墙的方式有两种。对于大多数流而言，你可以调用SCDynamicStoreCopyProxies方法获取代理设置，然后通过设置kCFStreamHTTPProxy（或kCFStreamFTPProxy）属性将设置应用到stream中。SCDynamicStoreCopyProxies方法是SystemConfiguration.framework中的一部分，因此在使用该方法的时候你需要在项目中导入&lt;SystemConfiguration/SystemConfiguration.h&gt;。然后在你使用完之后去释放代理字典的引用，整个过程的代码如下： 12CFDictionaryRef proxyDict = SCDynamicStoreCopyProxies(NULL);CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, proxyDict); 然而，如果你需要在多个流中使用代理设置，这就会变得复杂起来。在这种情况下获得用户机器的防火墙设置需要五个步骤： 1.创建单一持久化的指向动态存储会话SCDynamicStoreRef的句柄。2.将句柄添加到runloop中来接收代理变化的通知。3.用SCDynamicStoreCopyProxies方法获取最新的代理设置。4.当代理设置发生改变时更新代理拷贝中的内容。5.使用结束后清空SCDynamicStoreRef。 我们接着以代码来详细说明。首先，调用SCDynamicStoreCreate方法并传入分配子、描述行为的名字、回调方法和动态存储上下文等参数来创建创建动态存储会话的句柄。这会在初始化应用程序时执行。 接着，我们需要将其添加到runloop中。我们要调用SCDynamicStoreKeyCreateProxies和SCDynamicStoreSetNotificationKeys方法将设置句柄来管理代理的变化，然后，再调用SCDynamicStoreCreateRunLoopSource和CFRunLoopAddSource方法将句柄添加到runloop中去。 12345678910111213141516// 1.Create a handle to a dynamic store sessionSCDynamicStoreContext context = &#123;0, self, NULL, NULL, NULL&#125;;systemDynamicStore = SCDynamicStoreCreate(NULL, CFSTR(\"SampleApp\"), proxyHasChanged, &amp;context);// 2.Set up the store to monitor any changes to the proxiesCFStringRef proxiesKey = SCDynamicStoreKeyCreateProxies(NULL);CFArrayRef keyArray = CFArrayCreate(NULL, (const void **)(&amp;proxiesKey), 1, &amp;kCFTypeArrayCallBacks);SCDynamicStoreSetNotificationKeys(systemDynamicStore, keyArray, NULL);CFRelease(keyArray);CFRelease(proxiesKey); // 3.Add the dynamic store to the run loopCFRunLoopSourceRef storeRLSource = SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);CFRunLoopAddSource(CFRunLoopGetCurrent(), storeRLSource, kCFRunLoopCommonModes);CFRelease(storeRLSource); 一旦句柄被添加到runloop中，就可以通过调用SCDynamicStoreCopyProxies方法来预加载当前代理设置和代理字典。 1gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore); 由于将句柄添加到runloop中，因而每次代理改变时回调方法会被调用。释放当前的代理字典并用新的代理设置来重新加载它。 1234void proxyHasChanged() &#123; CFRelease(gProxyDict); gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);&#125; 当所有的代理信息都是最新的时，应用这些代理信息。当创建了读写流后，通过调用CFReadStreamSetProperty和CFWriteStreamSetProperty方法可以设置kCFStreamPropertyHTTPProxy代理。以下以读流为例： 1CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPProxy, gProxyDict); 当我们使用完代理设置后，确保释放字典和句柄，并将句柄从runloop中移除。12345678910if (gProxyDict) &#123; CFRelease(gProxyDict);&#125; // Invalidate the dynamic store's run loop source// to get the store out of the run loopCFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, systemDynamicStore, 0);CFRunLoopSourceInvalidate(rls);CFRelease(rls);CFRelease(systemDynamicStore); 结语以上就是对读写流的操作的详细解释，如果发现文中有问题或错误，欢迎指出。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}],"tags":[],"keywords":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}]},{"title":"CFNetwork学习笔记（一）","slug":"CFNetwork学习笔记（一）","date":"2016-10-05T04:36:19.000Z","updated":"2016-10-20T12:29:53.000Z","comments":true,"path":"2016/10/05/CFNetwork学习笔记（一）/","link":"","permalink":"http://zakariyyasv.pub/2016/10/05/CFNetwork学习笔记（一）/","excerpt":"简介提到CFNetwork框架，首先想到的是当年号称“网络终结者”的ASIHTTPRequest。ASI的底层就是基于CFNetwork开发的，现如今用的最广泛的AFNetworking框架则是基于NSURLSession开发的，相比而言，CFNetwork比NSURLSession更底层，在性能方面理论上来说CFNetwork会更好。之前没怎么研究过CFNetwork，所以决定深入研究一下。","text":"简介提到CFNetwork框架，首先想到的是当年号称“网络终结者”的ASIHTTPRequest。ASI的底层就是基于CFNetwork开发的，现如今用的最广泛的AFNetworking框架则是基于NSURLSession开发的，相比而言，CFNetwork比NSURLSession更底层，在性能方面理论上来说CFNetwork会更好。之前没怎么研究过CFNetwork，所以决定深入研究一下。CFNetwork是CoreServices框架中的框架，它提供了网络协议的抽象接口。这些抽象接口让直行各种网络任务变得简单起来，比如：支持与BSDScoket，HTTP，FTP服务工作，使用SSL或TLS建立加密连接，支持DNS主机解析等。 CFNetwork是底层且高性能的框架，它能够让我们在协议栈上进行精细地控制。它是对BSDSocket的扩展，BSDSocket是提供对象简化任务如与FTP或者HTTP服务器通信或者解析DNS主机的标准socket抽象API。 由于CFNetwork依赖于BSDsocket，如NSURL等的一些Cocoa类是依赖于CFNetwork实现的。此外，在视图中展示web内容的WebKit也同样依赖于CFNetwork。CFNetwork和其他一些框架的层级结构如下图所示。 优势CFNetwork继承了BSDSocket的一些优势。它集成了run-loop，如果你的应用是基于run-loop，你可以在不实现线程的情况下使用网络协议。CFNetwork也包含很多对象来帮助你不需要自己实现细节就可以使用网络协议。例如，你可以不用实现CFFTP的API而使用FTP协议。如果你理解网络协议，需要底层控制但又不想自己实现它们，这时候CFNetwork可能是很好的选择。 使用CFNetwork相比于Foundation级别的网络API有很多优势。CFNetwork更侧重于网络协议，而Foundation级别的网络API更侧重于数据的访问，如通过HTTP或FTP协议传输数据。Foundation级别的网络API确实提供了一些配置项，但CFNetwork提供的更多。 结构在学习CFNetwork的API之前，我们必须首先理解其API的整体结构。CFNetwork依赖于两大框架：CoreFoundation，CFSocket和CFStream。理解这两个框架对于使用CFNetwork非常有必要。 CFSocket APISocket是网络通信的最基础层。Socket的作用于电话插口有些类似，它允许你与另一个Socket进行连接（不管是本地的还是网络的）并且向另一个Socket发送数据。 最常见的socket是BSDsocket，CFSocket是对BSDsocket的抽象。CFSocket提供了几乎所有BSDsocket服务并且它将socket集成到run-loop中。CFSocket不仅仅局限于基于流服务的socket（如TCP），它可以处理任何类型的socket。 你可以用CFSocketCreate或CFSocketCreateWithNative函数创建CFSocket对象。然后，你可以用CFSocketCreateRunLoopSource函数创建run-loop源，并通过CFRunLoopAddSource函数添加到runloop中。之后，你可以用CFSocketSendData函数发送消息。当CFSocket对象接收到消息时，CFSocket函数回调会触发。 CFStream API读写流提供了在各种媒介之间交换数据的简单方式。你可以为内存，文件或网络上的数据创建流，并且可以在不一次性将所有数据加载进内存的情况下使用流。 流实际上是在通信路径上的连续的字节传输序列。流是单向通道，因此要进行双向通信就需要输入流和输出流。除了文件流以外，你不能在流中搜索查找，一旦流数据被接收或发送，那么就无法再从流中重新获取。 CFStream API提供两个新的CFType类型的对象：CFReadStream和CFWriteStream。CFStream构建在CFSocket的上层同时也是CFHTTP和CFFTP的底层。它们的层级关系见下图。 你可以像操作UNIX文件描述子的形式来使用读写流。首先，你需要指定流的类型（内存，文件或Socket）并设置可选项来实例化流对象。接着，你打开流进行读和写操作。当流对象已经存在，你可以通过访问它的属性来获取流对象的相关信息。当你不再需要它时，关闭并释放它。 CFStream的读写方法会一直处于挂起或者阻塞状态直到有数据可读或可写的时候才会结束挂起或阻塞状态。为了避免读写过程中流可能处于阻塞状态，使用异步方法并将其编排进runloop中。当读写操作不会被阻塞时回调方法会触发。 另外，CFStream本身还支持SSL（Secure Sockets Layer）协议。你可以将流的SSL信息存储进一个字典对象中，然后将字典对象传给stream对象的kCFStreamPropertySSLSettings属性。 CFNetwork API概览为了理解CFNetwork框架，你需要熟悉构成该框架的各个组成块。CFNetwork框架可以被拆解成几个独立的API，每个独立的API覆盖了不同的网络协议。这些API可以组合使用也可以单独使用，这取决于你自己的需求。 CFFTP APICFFTP可以帮我们与FTP服务器进行通信。使用CFFTP API可以创建读流负责下载，创建写流负责上传。使用读写流可以实现如下功能： 从FTP服务器上下载文件 向FTP服务器上传文件 从FTP服务器下载目录列表 在FTP服务器上创建目录 FTP流对象工作原理与其他的CFNetwork流一样。例如，你可以通过调用CFReadStreamCreateWithFTPURL方法创建FTP读流，然后，调用CFReadStreamGetError在任何时候检查流的状态。 通过设定FTP流的属性，你可以自定义流来满足你的需求。例如，如果流连接的服务器要求用户名和密码，你需要设置正确的属性这样流对象才能正确地进行工作。 CFFTP流可以使用同步或异步。创建完读流对象后，为了打开指定的FTP服务器的连接需要调用CFReadStreamOpen方法。为了从流中读取数据，可以调用CFReadStreamRead方法。CFReadStreamRead方法将FTP服务器的输出填充到缓冲区中。 CFHTTP API为了能收发HTTP消息，我们使用CFHTTP API。正如CFFTP是对FTP协议的抽象，CFHTTP是对HTTP协议的抽象。 HTTP协议是在客户端和服务端之间的请求/响应协议。客户端创建请求消息，进程会将消息转换成的原始字节流，这是序列化的过程。这一步是非常必要的，否则消息无法被发送出去。然后，消息会被发送到服务器上。服务器响应会发送带有字符串的消息给客户端。如果有必要这一步操作会重复多次。 要创建HTTP请求消息，你需要指定下面的属性： 请求方法，如OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT URL HTTP版本，如1.0或1.1 消息头，通过指定头部名字和它的值，如User-Agent ： MyUserAgent 消息体 消息构建完后再对其进行序列化。序列化完成后，请求会像下面的形式： GET / HTTP/1.0\\r\\nUser-Agent: UserAgent\\r\\nContent-Length: 0\\r\\n\\r\\n 反序列化是对序列化的逆操作。从服务端或客户端接收到的原始字节流通过反序列化会重新存储成它原始的表现形式。CFNetwork提供了所有关于获取接收到的序列化的消息的消息类型，HTTP版本，URL，消息头，消息体信息的方法。 CFHTTPAuthentication API如果你给认证服务器发送HTTP请求却没有证书或者是错误的证书，服务器会返回认证错误，通常错误码是401或407。CFHTTPAuthentication API支持认证证书设置，其支持以下的认证模式： Basic Digest NT LAN Manager Simple and Protected GSS-API Negotiation Mechanism（SPNEGO） 现在，你可以将每个服务器对应的CFHTTPAuthentication对象保存到集合中。当你接收到401货407响应时，你需要找到服务器对应的正确的对象和证书并且应用它们。CFNetwork使用存储在认证对象中的信息来提高请求的效率。 CFHost API通过调用CFHost API请求主机信息，包括名字，地址和可访问的信息。请求主机信息的进程叫做resolution。 CFHost使用方法与CFStream相似： 创建CFHost对象 开始解析CFHost对象 重新获取地址，主机名或者是否可访问的信息 销毁CFHost对象 跟所有的CFNetwork类一样，CFHost兼容IPv4和IPv6。使用CFHost，你可以写代码去处理IPv4和IPv6的情况。CFHost被集成到其他的CFNetwork的类中。例如，有一个CFStream的方法叫CFStreamCreatePairWithSocketToCFHost，它会直接从一个CFHost对象中创建CFStream对象。 CFNetServices API如果你想要你的app使用Bonjour服务来注册服务或者发现服务，那就使用CFNetServices API。Bonjour是苹果的零配置网络的实现，它允许你创建，发现，解析网络服务。 想要实现Bonjour，CFNetServices API定义了三种类型： CFNetService, CFNetServiceBrowser, CFNetServiceMonitor。CFNetService对象代表单独的网络服务，如打印机或者文件服务器。它包含另外的电脑解析服务所需要的所有信息，如名字，类型，域名和端口号。CFNetServiceBrowser对象用来发现域名和域名指向的网络服务。CFNetServiceMonitor对象用来管理CFNetService对象内容的更改，如iChat中的状态消息。 CFNetDiagnostics APIapp连接网络服务依赖于稳定的连接。如果网络断开，便会引起问题。使用CFNetDiagnostics API，用户可以自己诊断网络问题，例如： 物理连接失败，如网口没插好 网络失败，如DNS或DHCP服务器无法响应 配置失败，如代理配置不正确 一旦网络失败被诊断，CFNetDiagnostics会指导用户去修复问题。在Safari连接网络失败后你可能已经看到过CFNetDiagnostics做出的反应。CFNetDiagnostics助手如下图所示： 向CFNetDiagnostics提供网络错误的上下文，你可以告诉CFNetDiagnosticDiagnoseProblemInteractively方法来引导用户尝试去找到解决方案。另外，你可以用CFNetDiagnostics去查询连接状态并且向用户传递错误消息。 结语以上只是对CFNetwork框架的概览，至于更详细的使用会在后面的文章中罗列出来。","categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}],"tags":[],"keywords":[{"name":"MacOS","slug":"MacOS","permalink":"http://zakariyyasv.pub/categories/MacOS/"}]},{"title":"dumpdecrypted砸壳记录","slug":"dumpdecrypted砸壳记录","date":"2016-10-03T02:14:41.000Z","updated":"2016-10-19T13:07:14.000Z","comments":true,"path":"2016/10/03/dumpdecrypted砸壳记录/","link":"","permalink":"http://zakariyyasv.pub/2016/10/03/dumpdecrypted砸壳记录/","excerpt":"前言之前一直采用Clutch对ipa包进行砸壳，后来发现Clutch在某些iOS版本下砸壳会失效，故而放弃了Clutch而采用dumpdecrypted。本篇文章就是记录用dumpdecrypted砸壳的过程以及其中的注意点。 准备工作砸壳需要的东西： dumpdecrypted 越狱的iOS设备 OpenSSH（Cydia） iFile（Cydia） Cycript（Cydia） XCode Command Line Tools","text":"前言之前一直采用Clutch对ipa包进行砸壳，后来发现Clutch在某些iOS版本下砸壳会失效，故而放弃了Clutch而采用dumpdecrypted。本篇文章就是记录用dumpdecrypted砸壳的过程以及其中的注意点。 准备工作砸壳需要的东西： dumpdecrypted 越狱的iOS设备 OpenSSH（Cydia） iFile（Cydia） Cycript（Cydia） XCode Command Line Tools 编译dumpdecrypted从Github上下载最新的dumpdecrypted源码，在命令行中进入进入源码的目录下，输入make进行编译生成dumpdecrypted.dylib。这里有一点需要注意，编译时依赖的XCode的SDK版本需要兼容iOS越狱设备的系统版本。比如，我当前XCode的SDK版本是iOS10.0，而我的越狱设备的系统版本是iOS 9.3.1，按照当前配置编译出来的dumpdecrypted.dylib在设备上进行砸壳是会失败的。那如何知道Xcode当前的SDK版本呢？我们可以在命令行中输入命令：xcrun –sdk iphoneos –show-sdk-path。1/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.0.sdk 若SDK版本不兼容怎么办？可以在这里下载过往版本的SDK。把下载的SDK替换当前SDK的位置，当然别忘了把当前SDK备份，或者用xcode-select命令指定一个活动的XCode。最后再make，成功，输出如下：1234567$ make`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c`xcrun --sdk iphoneos --find gcc` -Os -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o$ lsMakefile dumpdecrypted.c dumpdecrypted.oREADME dumpdecrypted.dylib 再看目录下多出了两个文件：dumpdecrypted.o和dumpdecrypted.dylib，其中dumpdecrypted.dylib是我们用来砸壳的锤子。 配置iOS越狱设备进入越狱设备的Cydia中下载安装OpenSSH、Cycript、iFile。在越狱设备上安装上需要砸壳的APP。 在Mac命令行中通过SSH连接iOS设备，这里必须确保iOS设备与mac电脑处于同一无线网络下，OpenSSH的默认密码是alpine。 12// 192.168.xx.xx为iOS设备在wifi下的IP地址ssh root@192.168.xx.xx 连接成功后，需要找到砸壳APP的bundle id了，我们可以把除砸壳APP的所有其他APP关掉，在命令行中输入：ps -e命令。以微信为例，我们可以看到微信的bundle id为WeChat。 知道了bundle id，我们就可以通过Cycript找到微信Documents路径，在命令行中输入：cycript -p WeChat，再输入：NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES)[0]。 记下bundle id和Documents的路径，后面会用到。 砸壳将dumpdecrypted.dylib拷贝到iOS越狱设备上，这里可以用像iTools、iFunBox工具，我用的是scp命令将其传到iOS设备。123$ scp dumpdecrypted.dylib root@192.168.xxx.xxx:/usr/libroot@192.168.xxx.xxx's password:dumpdecrypted.dylib 100% 81KB 81.0KB/ 注意，若你的设备是iOS 9.3以上，可能会在后面的砸壳中出现错误，所以，推荐将dumpdecrypted.dylib传到/usr/lib目录下。 在命令行中切换到/usr/lib目录下，输入砸壳命令：DYLD_INSERT_LIBRARIES=”dumpdecrypted.dylib的路径” “app的Bundle id的路径” 1234567891011121314151617181920root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/EBBD26E9-DDBA-481E-9403-84D159436889/HBGC.app/HBGCmach-o decryption dumperDISCLAIMER: This tool is only meant for security research purposes, not for application crackers.[+] detected 32bit ARM binary in memory.[+] offset to cryptid found: @0xd5a90(from 0xd5000) = a90[+] Found encrypted data at address 00004000 of length 3047424 bytes - type 1.[+] Opening /private/var/mobile/Applications/EBBD26E9-DDBA-481E-9403-84D159436889/HBGC.app/HBGC for reading.[+] Reading header[+] Detecting header type[+] Executable is a FAT image - searching for right architecture[+] Correct arch is at offset 16384 in the file[+] Opening HBGC.decrypted for writing.[+] Copying the not encrypted start of the file[+] Dumping the decrypted data into the file[+] Copying the not encrypted remainder of the file[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset 4a90[+] Closing original file[+] Closing dump file 到此，砸壳工作就完成了。这里还有一点说明，StoreApp对沙盒以外的其他大多数目录没有写权限。除了/usr/lib外，你还可以把dumpdecrypted.dylib拷贝到Documents目录下操作。如果不放在Documents目录下，可能会出现下面的问题：12345FunMaker-5: /var/mobile/Containers/Data/Application/D41C4343-63AA-4BFF-904B-2146128611EE/Documents root# mv dumpdecrypted.dylib /var/tmp/FunMaker-5: /var/mobile/Containers/Data/Application/D41C4343-63AA-4BFF-904B-2146128611EE/Documents root# cd /var/tmpFunMaker-5:/var/tmp root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /private/var/mobile/Containers/Bundle/Application/03B61840-2349-4559-B28E-0E2C6541F879/TargetApp.app/TargetAppdyld: could not load inserted library 'dumpdecrypted.dylib' because no suitable image found. Did find: dumpdecrypted.dylib: stat() failed with errno=1","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"iOS OpenDev踩坑记录","slug":"iOS OpenDev踩坑记录","date":"2016-09-20T14:52:58.000Z","updated":"2016-10-15T14:53:23.000Z","comments":true,"path":"2016/09/20/iOS OpenDev踩坑记录/","link":"","permalink":"http://zakariyyasv.pub/2016/09/20/iOS OpenDev踩坑记录/","excerpt":"前言最近在研究iOS逆向工程，需要用到iOSDev工具，心想那就安装呗，多大点事儿。谁知道自己有点too young too simple，原以为下载完安装包再按步骤点点点就完了，谁知道到了最后一步，它给我来个安装失败。真是没有一点点防备啊，于是各种找办法解决安装问题，最终解决了，于是，决定把解决的过程写下来，方便以后回顾。","text":"前言最近在研究iOS逆向工程，需要用到iOSDev工具，心想那就安装呗，多大点事儿。谁知道自己有点too young too simple，原以为下载完安装包再按步骤点点点就完了，谁知道到了最后一步，它给我来个安装失败。真是没有一点点防备啊，于是各种找办法解决安装问题，最终解决了，于是，决定把解决的过程写下来，方便以后回顾。 安装必要的软件包和工具1.安装MacPort。在官网根据当前电脑系统下载对应的pkg安装包，然后进行安装。安装过程会很慢，建议全程开启VPN会好一些。 2.更新MacPort。在命令行中输入命令进行更新：1sudo port -v selfupdate 3.安装dpkg工具。在命令行中输入：1sudo port -f install dpkg 4.安装theos工具。首先，打开环境变量配置文件，并添加： 1export THEOS=/opt/theos 然后，下载兼容iOSOpenDev版本的theos，在命令行中输入：1git clone -b stableversion https://github.com/haorenqq/theos/ $THEOS 修改Xcode目录文件由于Xcode更新后的文件位置移动，自Xcode 7开始不支持dylib，我们需要把缺失的文件放到指定目录下。我们可以从这里下载所需要的四个文件。然后，在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/“路径下创建名为”Specifications”文件夹，并将名为”iPhoneOSPackageTypes.xcspec”和”iPhoneOSProductTypes.xcspec”的文件复制到该文件夹下。同样的操作发生在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode”路径下，只不过是将名为”iPhone Simulator PackageTypes.xcspec”和”iPhone Simulator ProductTypes.xcspec”的文件放到”Specifications”文件夹下。之后，在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer”路径下创建名为”usr”的文件夹，并且在该文件夹内创建名为”bin”的文件夹。 安装iOSOpenDev，运行脚本打开iOSOpenDev安装包进行安装，结果肯定又是安装失败。别急，继续按照步骤走。进入/opt目录下，我们会发现有名为iosopendevsetup的文件夹，并且在该文件夹下的bin目录下有一个叫iod-setup的脚本，在命令行中输入：12sudo ./iod-setup basesudo ./iod-setup sdk -sdk iphoneos 之后，一切就OK了。重启Xcode，新建项目，就可以看到iOSOpenDev了。","categories":[{"name":"iOS逆向工程","slug":"iOS逆向工程","permalink":"http://zakariyyasv.pub/categories/iOS逆向工程/"}],"tags":[],"keywords":[{"name":"iOS逆向工程","slug":"iOS逆向工程","permalink":"http://zakariyyasv.pub/categories/iOS逆向工程/"}]},{"title":"iOS APP砸壳小记","slug":"iOS APP砸壳小记","date":"2016-09-18T01:07:15.000Z","updated":"2016-10-15T09:32:03.000Z","comments":true,"path":"2016/09/18/iOS APP砸壳小记/","link":"","permalink":"http://zakariyyasv.pub/2016/09/18/iOS APP砸壳小记/","excerpt":"前言在逆向工程中，砸壳是很必要并且不可缺少的一个步骤。所谓“壳”，其实就是苹果给应用加密的一层保护，我们只要是从APP Store上下载的APP都是带壳的。带壳的APP是无法进行class-dump以及hook等操作，因此，需要对APP进行砸壳。接下来，我以微信为例来进行砸壳。","text":"前言在逆向工程中，砸壳是很必要并且不可缺少的一个步骤。所谓“壳”，其实就是苹果给应用加密的一层保护，我们只要是从APP Store上下载的APP都是带壳的。带壳的APP是无法进行class-dump以及hook等操作，因此，需要对APP进行砸壳。接下来，我以微信为例来进行砸壳。 准备工作要能顺利完成砸壳需要四样东西： 电脑 越狱后的iOS设备 AppStore下载的待砸壳的app Clutch砸壳工具 我用的是MacBookPro+iPad（iOS 9.3.1）组合，微信直接从AppStore上下载即可。Clutch则是到其github地址下载最新的release版本。 iOS设备上导入Clutch要能对微信进行砸壳，就要把砸壳工具Clutch导入到iPad的指定目录下。熟悉Linux的人肯定对ssh不陌生，我这里采用的也是通过ssh将clutch工具传输到iPad上。默认情况下，iOS设备是不支持ssh，所以，我们要在Cydia商店中下载名叫“OpenSSH”的插件。 安装好后，要能让电脑和iPad进行ssh连接，就要保证两者在同一个无线网络下。然后，查看iPad在wifi下的IP地址。 在电脑的命令行中输入：scp “Clutch路径” root@”iOS设备IP地址”:/usr/bin。回车后会提示输入密码，iOS设备默认的密码是“alpine”。 砸壳成功将Clutch工具包导入到/usr/bin目录下后，在命令行中ssh连接iPad，密码与之前的一致。连接成功后切换到/usr/bin目录下。 输入命令：Clutch -i。Clutch是工具包的名字，如果你的包名是Clutch-2.0.4，则输入Clutch-2.0.4 -i。该命令获取的是所有已安装的APP。 根据获取的结果，输入命令：Clutch -d(或者b) 33。该命令是对指定的app进行砸壳，d代表输出ipa包，b代表输出二进制文件，33是微信在安装列表中的编号。砸壳成功后，它会将砸壳后的ipa包的路径显示出来，比如我这里砸壳后的ipa包路径是：/private/var/mobile/Documents/Dumped/com.tencent.xin-iOS7.0-(Clutch-2.0.4).ipa。 最后通过ssh将砸壳后的ipa传到电脑上。 class-dump导出头文件class-dump可以从Mach-O的section中还原出OC代码的头文件。我们可以从这个地址获取下载地址。我下载的是class-dump-3.5.dmg，双击安装，将可执行文件移动到/usr/bin目录下，这样就可以在命令行下直接调用”class-dump”命令了。在移动的过程中遇到一点小问题，操作被拒绝，研究了一下才知道自OS X 10.11 EI Capitan开始，系统启用了SIP(System Integrity Protection)，导致root用户也没有权限修改/usr/bin目录。解决方案是重启电脑按住command+R进入recovery模式，在命令行中输入”csrutil disable”并重启。 移动文件成功后，打开命令行，输入：class-dump，命令行会显示class-dump用法。 将先前砸完壳的微信ipa包解压，在Pyload文件夹下操作WeChat.app显示包内容，得到如下目录： 在命令行中输入：class-dump -H “Mach-O文件路径” -O “输出头文件的路径”。若不加-O，则会在当前目录下输出头文件。 输完命令回车后，在输出目录下就可以看到一大堆头文件。 砸壳过程到此就全部完成了。","categories":[{"name":"iOS逆向工程","slug":"iOS逆向工程","permalink":"http://zakariyyasv.pub/categories/iOS逆向工程/"}],"tags":[],"keywords":[{"name":"iOS逆向工程","slug":"iOS逆向工程","permalink":"http://zakariyyasv.pub/categories/iOS逆向工程/"}]},{"title":"iOS APP中调用私有方法","slug":"iOS APP中调用私有方法","date":"2016-09-04T15:08:43.000Z","updated":"2016-10-14T16:26:12.000Z","comments":true,"path":"2016/09/04/iOS APP中调用私有方法/","link":"","permalink":"http://zakariyyasv.pub/2016/09/04/iOS APP中调用私有方法/","excerpt":"前言得益于苹果封闭的生态系统，iOS平台才能如此优秀和健壮。然而，对于开发者而言，开源永远是最受欢迎的，闭源只会让开发者束手束脚。我们在开发的过程中可能会遇到有需求需要依赖于iOS私有API，但由于iOS的封闭，我们无法直接调用私有方法，这让人很是头疼。那有没有方法能让我们在不越狱的情况下去调用私有API呢？","text":"前言得益于苹果封闭的生态系统，iOS平台才能如此优秀和健壮。然而，对于开发者而言，开源永远是最受欢迎的，闭源只会让开发者束手束脚。我们在开发的过程中可能会遇到有需求需要依赖于iOS私有API，但由于iOS的封闭，我们无法直接调用私有方法，这让人很是头疼。那有没有方法能让我们在不越狱的情况下去调用私有API呢？答案是有的，并且就我目前了解而言有两种方案。为了更好地解释这两种方案，我写了个小Demo。在Demo中只有一个类TestClass。 1234567// TestClass.h#import &lt;Foundation/Foundation.h&gt;@interface TestClass : NSObject- (void)publicMethod;@end 123456789101112// TestClass.m#import \"TestClass.h\"@implementation TestClass- (void)publicMethod&#123; NSLog(@\"Call public method\");&#125;- (void)privateMethod&#123; NSLog(@\"call private method\");&#125;@end 在这个类中有两个方法：publicMethod和privateMethod。其中，publicMethod是公有方法，privateMethod是私有方法。如果我们直接在实例中调用privateMethod，会得到”No visible @interface for ‘TestClass’ declares the selector ‘privateMethod’”的错误。因此，直接调用私有方法肯定是行不通的，那就换个套路试试。 1234567891011// main.m#import &lt;Foundation/Foundation.h&gt;#import \"TestClass.h\"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TestClass *obj = [[TestClass alloc] init]; [obj privateMethod]; &#125; return 0;&#125; 利用runtime特性这里需要用到两个runtime相关的方法：respondsToSelector:和performSelector:。前者是用来判断类或者类实例是否实现了某个方法选择子，后者是调用指定的方法选择子。 这里提一下performSelector:与直接调用方法之间的区别。由于OC的运行时，使得程序可以在运行时动态添加方法，因此在编译时动态方法是不存在的。为了能调用动态方法，就有了performSelector:。因此两者的区别就在于直接调用方法在编译期是会自动校验公有方法，若不存在该方法则编译无法通过，而调用performSelector:则在编译期不会进行校验，它会在运行时去查找并调用指定方法，若运行时找不到指定方法则会发生崩溃。考虑到程序的健壮性，会先调用respondsToSelector:检查方法是否存在。 采用该方案去调用privateMethod的正确做法应该是这样： 12345678910111213// main.m#import &lt;Foundation/Foundation.h&gt;#import \"TestClass.h\"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TestClass *obj = [[TestClass alloc] init]; if ([obj respondsToSelector:@selector(privateMethod)]) &#123; [obj performSelector:@selector(privateMethod)]; &#125; &#125; return 0;&#125; 匿名category欺骗编译器从刚才的方案中我们知道，直接调用方法会失败是因为编译器自动校验失败而报错，那如果我们欺骗编译器让它误以为校验的方法存在呢？这倒是个不错的思路，第二个方案也就由此产生。那就是写一个匿名的category声明想要调用的私有方法，这样编译器就会认为该方法存在而不会报错。 采用该方案调用privateMethod的正确姿势是： 123456789101112131415// main.m#import &lt;Foundation/Foundation.h&gt;#import \"TestClass.h\"@interface TestClass()- (void)privateMethod;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TestClass *obj = [[TestClass alloc] init]; [obj privateMethod]; &#125; return 0;&#125; 结语理论上这两种方法均可以实现对私有API的调用，不过，我更推荐第一种方案。因为第一种方案在程序的健壮性上会更好，并且书写上也更简单。友情提醒，可以在程序中调用私有API并不意味着就可以通过苹果的审核。其实，我也不太懂苹果的审核机制，有些APP调用私有API可以通过审核，有些APP则会被拒绝，所以，要想通过审核往往是要碰运气的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"拆解ARC下的self","slug":"拆解ARC下的self","date":"2016-08-24T13:23:28.000Z","updated":"2016-10-10T13:14:53.000Z","comments":true,"path":"2016/08/24/拆解ARC下的self/","link":"","permalink":"http://zakariyyasv.pub/2016/08/24/拆解ARC下的self/","excerpt":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。","text":"最近在研究AFNetworking源码的过程中碰到了很多处地方用到了weakSelf和strongSelf。依据自己之前的理解，正常情况下使用weakSelf是为了避免发生循环引用，而使用strongSelf是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。 self的本质self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是const Class self，在实例方法中self是Person const* self（以Person类举例）。事实确实如此么？来验证一下。 123456789101112131415#import \"Person.h\"@implementation Person- (void)eat&#123;&#125;+ (void)classEat&#123;&#125;- (void)drink:(NSString *)sth&#123; [self eat];&#125;@end 将Person.m用clang命令进行重写，得到的代码如下： 12345678910static void _I_Person_eat(Person * self, SEL _cmd) &#123; id obj = ((Person *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(\"Person\"))&#125;, sel_registerName(\"init\"));&#125;static void _C_Person_classEat(Class self, SEL _cmd) &#123;&#125;static void _I_Person_drink_(Person * self, SEL _cmd, NSString *sth) &#123; ((void (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(\"eat\"));&#125; 从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了Clang的官方文档,找到了其中关于self的说明： The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object. To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method. 翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下： 在ARC中，self的修饰符是unsafe_unretained，而不是strong。unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。 OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。 对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"CallKit学习笔记","slug":"CallKit学习笔记","date":"2016-07-30T02:21:17.000Z","updated":"2016-10-10T12:06:51.000Z","comments":true,"path":"2016/07/30/CallKit学习笔记/","link":"","permalink":"http://zakariyyasv.pub/2016/07/30/CallKit学习笔记/","excerpt":"概览近几年4G大规模的普及使得VoIP（Voice over Internet Protocol）变得可靠和稳定。iOS 10开始全面支持VOIP，于是推出了CallKit框架。 CallKit框架能让你的第三方VoIP应用程序获得原声应用程序的体验效果。为了能更好得讲述CallKit新特性，我们以一个第三方VoIP应用程序——“Speakerbox”举例来说明。","text":"概览近几年4G大规模的普及使得VoIP（Voice over Internet Protocol）变得可靠和稳定。iOS 10开始全面支持VOIP，于是推出了CallKit框架。 CallKit框架能让你的第三方VoIP应用程序获得原声应用程序的体验效果。为了能更好得讲述CallKit新特性，我们以一个第三方VoIP应用程序——“Speakerbox”举例来说明。在iOS 10之前，当用户收到“Speakerbox”的电话时的界面如同下图。在锁屏状态下，我们无法区分iMessage和VoIP电话的区别，它只是一则通知。如果想要接听“Speakerbox”中的来电，我们需要先右滑通知，输入密码，进入app才能接听电话。这是非常糟糕的体验。而在解锁状态下，来电会显示为一条横幅，我们有时候可能会错过这些通知，这样的体验也是很糟糕的。 在iOS 10中，“Speakerbox”可以像原生电话UI那样接听和显示VoIP通话。 Architecture在iOS 10以前，像系统服务如蓝牙、Siri、CarPlay与VoIP的应用程序如“Speakerbox”是相互独立的两部分。在iOS 10中，通过CallKit框架可以将两者连接起来，现在在“Speakerbox”上发起的通信电话可以被系统获取然后系统会与目的设备之间建立起通信。 现在我们进一步来聊聊“Speakerbox”。在下图中，我们有“Speakerbox”以及它所有的代码，它与网络进行通信并有自己的UI。接下来，我们要与CallKit连接。这里有两个类需要我们着重去注意，分别是CXProvider和CXCallController。 CXProviderOut-of-band nontificationsNot user actionsExternal events incoming calls CXCallControllerRequests from appLocal user actionsInternal events Start call CXProvider的作用是告知系统所有的带外（out-of-band）通知信息。带外通知的意思是指非用户操作而是外在真实发生的事件，比如来电（incoming call）。 CXCallController的作用是让系统感知来自于app自身的请求。这里的请求是真实的用户操作就像内部事件，如开始通话操作。CXCallController会与系统上其他的通话产生相互影响。例如，用户已经处于通话状态了，而他还想通过“Speakerbox”再开启一个通话。这时候CXCallController会告诉系统用户的开启通话的操作，系统会告知通话提供者保持当前的通话，这样可以让“Speakerbox”开始它的通话。 所以，当CXProvider想与系统进行通信时它会使用CSXCallUpdate类，当系统想让“Speakerbox”接收用户操作，它会使用CXAction类来让“Speakerbox”知道。CXCallController会将这些用户操作装进CSTransaction对象中来告知系统用户产生的操作。 现在我们来看看来电的整体工作流程。现在比如说一个叫做Jane的人收到了来自他妈妈的来电通话请求。“Speakerbox”收到了来电，然后会创建CXCallUpdate对象并通过CXProvider发送给系统。接着，系统将来电告知包括UI的所有服务。如果Jane想应答，Jane可以通过通话界面的应答按钮接通通话。这时候系统会告诉“Speakerbox”只要它需要随时可以接通来电通话。如果Jane想通过操作app的UI来结束通话，CXCallController会将结束action打包进一个CXTransaction对象中并将其发送给系统。如果一切ok，系统会通过CXProvider将其发送给“Speakerbox”，这样“Speakerbox”就可以随时结束通话。 Incoming Call下面以代码的形式简要概述来电发生的过程： 1.将来电信息通知到系统1provider.reportNewIncomingCall(with: UUID, update: CXCallUpdate) &#123; error in /* ... */ &#125; 2.用户点击通话按钮进行通话，ProviderDelegate会调用PerformAnswerCallAction方法。1func provider(_ provider: CXProvider, perform action: CXAnswerCallAction) &#123; /* ... */ &#125; 3.当用户真正地在通话时，CXAnswerCallAction会执行fulfill方法。1answerCallAction.fulfill() Call Actions以下列出了所有的callAction类型： CXAnswerCallAction CXStartCallAction CXEndCallAction CXSetHeldCallAction CXSetGroupCallAction CXPlayDTMFCallAction CXSetMutedCallAction Multiple Call接下来花点时间讲讲多来电通话时的管理。例如，现在“Speakerbox”已经处于通话状态了，这时候又有一个通话请求进来。 如果用户想要结束现在进行的通话并且回应刚进来的通话时，系统会给“Speakerbox”发送CXTransaction。CXTransaction只是一个或多个action组合起来的集合，在现在这种情况下它就是end和answer操作的集合。一旦“Speakerbox”处理并执行集合中的action，系统就会了解到并且换UI。 Outgoing Call再来看看去电的流程。要拨出电话首先要找到你需要联系的联系人再进行操作发起通话请求（start call intent）。intent是代表用户意愿操作的对象，被打包成NSUser activity后传回你的app中。app接收到开始通话的intent然后在intent信息的基础上构建开始通话action。我们通过CallController来执行和请求action，之后，CallController会将action传递给系统。如果通话请求被接受了，action会通过ProviderDelegate返回你的app中。最后，app通过网络执行必要的命令建立起通话连接。 我们来看下整个去电的生命周期。我们以执行开始通话操作为起始点。这时候通话处于starting状态，之后，我们会执行完action操作并将通话状态变成started。当通话的另一端响应通话时，我们会通知provider通话已经开始连接（connecting）。最后，我们告诉provider通话已经连接上了（connected）来通知系统两端可以开始互相说话。 最后我们以代码的形式来简要回顾一下去电的流程： 1.通过CallController请求开始通话action1callController.request(startCallTransaction) &#123; error in /* ... */ &#125; 2.action通过ProviderDelegate被接受，然后执行。1startCallAction.fulfill() 3.app通知call将其状态从connecting转变成connected。12provider.reportOutgoingCall(with: call.uuid, startedConnectingAt: call.connectingDate)provider.reportOutgoingCall(with: call.uuid, connectedAt: call.connectDate) API DetailsAuthorization跟其他如contacts、core location的API类似，CallKit也需要向用户请求准许的权限。正因为如此，每次app启动之后，你的app要做的第一件事就是检查当前的授权状态。因为可能在上次启动app之后用户进入到设置中修改了权限。如果你发现你的app的授权状态是不允许的，你应该为你的app请求授权。系统会弹框向用户请求允许权限。最后，当你的app启动时，你应该去观察并监听任何授权状态的改变，这样你才能一直将最新的UI展示给你的用户。 Provider ConfigurationProvider Configuration可以帮助你的app自定义通话界面。比如说，你的app在通话界面显示的名称，还有是否支持视频通话，指定显示在通话UI最后的button图片，点击这个button可以直接跳转到你的app中。 Actions Error我们已经知道了在不发生错误的情况下action发生的过程。那么要是在执行过程中发生错误了呢？比如，网络连接发生异常，我们无法建立起通话连接。在这种情况下，action会执行失败。 其中的过程是这样的：action通知系统发生错误，系统转而通过像通话失败UI来告诉用户通话请求失败。与这些action错误连同一起的是action timeouts。系统的每个action都有其特定的过期时间，这些时间很重要，它们确保了被用户启动的action执行的顺畅。如果action执行超时，provider的代理方法会通知app来正确响应此时的操作。 System Restrictions现实中你可能会遇到来电被拒。来电被拒绝的原因可能是用户禁用了你的app并且不再给予授权，可能是你的来电被用户列入黑名单中，可能是用户开启勿扰模式。在这些情况下，API中的competition handler会通知你的app。例如reportNewIncomingCallAPI会在它的completion handler传入一个error。 123456provider.reportNewIncomingCall(with: UUID(), update: CXCallUpdate()) &#123; error in if let incomingCallError = error, incomingCallErrorCode = CXErrorCodeIncomingCallError(rawValue: incomingCallError.code) where incomingCallErrorCode == .filteredByDoNotDisturb &#123; // handle do not disturb &#125;&#125; Audio由于有CallKit，你的app的通话音频得到了很多好处。其中最大的好处就是你的音频会话的优先级比系统通话和Facetime更高，这意味着系统其它的app不能够打断你的app的音频通话。 现在以来电流程举例。我们知道当有来电时，app会收到应答action然后执行action。在接收action后是配置音频会话最佳的时间点，这是因为我们知道这时候通话即将变成connected状态。当我们执行应答action后，系统会优先自动为app开启音频会话，然后通过音频会话提供者的代理方法的回调来告诉app发生了什么。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"iOS 10推送通知小记（下）","slug":"iOS 10推送通知小记（下）","date":"2016-07-26T02:50:03.000Z","updated":"2016-09-24T16:37:50.000Z","comments":true,"path":"2016/07/26/iOS 10推送通知小记（下）/","link":"","permalink":"http://zakariyyasv.pub/2016/07/26/iOS 10推送通知小记（下）/","excerpt":"Overview在上一篇iOS 10推送通知小记（上）中，已经将iOS 10推送机制的改进以及原理讲完了。本篇文章的着重点放在心的推送框架UserNotification.framework上面。 先说说iOS 10之前的推送API中存在的问题。比如，本地推送和远程推送使用的是不同的回调方法但有可能回调方法中的代码是重复的。当你的app将通知发送给用户之后就没办法再去控制它了。为了解决这些问题，iOS 10推出了新的推送框架——UserNotification.framework。","text":"Overview在上一篇iOS 10推送通知小记（上）中，已经将iOS 10推送机制的改进以及原理讲完了。本篇文章的着重点放在心的推送框架UserNotification.framework上面。 先说说iOS 10之前的推送API中存在的问题。比如，本地推送和远程推送使用的是不同的回调方法但有可能回调方法中的代码是重复的。当你的app将通知发送给用户之后就没办法再去控制它了。为了解决这些问题，iOS 10推出了新的推送框架——UserNotification.framework。新框架的主要特性有： 与之前的API相似，改写原来的代码很简单。 扩展通知的内容。 本地推送和远程推送执行相同的回调方法。 简化代理方法。 更好的推送管理。app可以访问将被发送或者已经发送给用户的通知并且允许在更新通知的时候移除它。 通知内容可以展示app内的界面内容。 Registration如今，通知消息对用户来说是种干扰或者打断。因此，在你给用户发送通知消息之前得到用户的授权和允许是非常重要的。你可以向用户请求横幅、声音或者app角标的权限，这样用户可以第一时间看到你的推送通知。本地推送与远程推送都需要做注册操作。 注册代码编写很简单，只需要调用UN的userNotification对象的request方法，并传入正确的参数即可。注意，现在用户对于每个应用允许的权限可以在应用的设置菜单中单独设置，用户可以依据个人的偏好去开启或关闭通知。在iOS 10中，开发者可以获取用户设置的权限，因而可以依据用户的偏好设置而发送对应的通知消息。 本地推送的注册到此就结束了，但是远程推送还没有结束。注册远程推送需要连接网络跟APNS进行通信获取设备的device token，你需要将这个token发送给应用的服务端。这个token非常重要，远程推送通知的负载需要包含这个token。device token相当于验证你的设备和应用程序之间的钥匙。 12345678910// RequestAuthorizationUNUserNotificationCenter.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) in // ... &#125; // Access to user-defined settings UNUserNotificationCenter.current().getNotificationSettings &#123; (settings) in // ... &#125; // Register remote notifications UIApplication.shared().registerForRemoteNotifications() Content在iOS 10中，推送通知加入了subtitle，可以给用户展示更多的信息。 创建通知内容很简单，只需要创建UNMutableNotificationContent对象并且设置里面不同的属性就可以了。 123456// local notificationlet content = UNMutableNotificationContent()content.title = \"Introduction to Notifications\"content.subtitle = \"Session 707\"content.body = \"Woah! These new notifications look amazing! Don’t you agree?\"content.badge = 1 12345678910111213// remote notification payload&#123; \"aps\" : &#123; \"alert\" : &#123; \"title\" : \"Introduction to Notifications\", \"subtitle\" : \"Session 707\", \"body\" : \"Woah! These new notifications look amazing! Don’t you agree?\" &#125;, \"badge\" : 1 &#125;, my-attachment : https://example.com/phtos.jpg\"&#125; SchedulingiOS 10发送通知的过程可以总结如下： 注册通知申请权限。 设置通知的内容 设置触发器 设置通知标识符 发送通知 12345678910111213141516// Notification Delivery Summaryimport UserNotificationsUNUserNotificationCenter.current().requestAuthorization([.alert, .sound, .badge]) &#123; (granted, error) in // ... &#125;let content = UNMutableNotificationContent()content.title = \"Introduction to Notifications\"content.body = \"Let's talk about notifications!\"let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)let requestIdentifier = \"sampleRequest\"let request = UNNotificationRequest(identifier: requestIdentifier, content: content, trigger: trigger)UNUserNotificationCenter.current().add(request) &#123; (error) in // ... &#125; 以上说的是应用程序在后台的时候推送通知的产生过程。那要是应用程序在前台运行呢？这时候我们需要实现UNUserNotificationCenter的代理方法才能支持在前台中处理推送通知。代理方法中有个叫做willPresent notification:，该方法能让你获取推送通知中的内容。如果你想设置弹窗、声音或者in-app显示，可以通过调用handlerBlock方法设置不同的参数达到效果。 12345protocol UNUserNotificationCenterDelegate : NSObjectProtocolfunc userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: (UNNotificationPresentationOptions) -&gt; Void)&#123; // Roll banner and sound alert handlerBlock([.alert, .sound]) &#125; Management在iOS 10新的推送框架中，推送通知的管理可以做的事情很多： 访问推送消息 将要发送的通知 已经发送的通知移除推送消息更新修改推送消息 在推送通知管理中非常重要的一部分是request identifier。在本地推送中，请求标识符被设置在消息请求当中，在远程推送中，请求标识符被设置在新的HTTP/2请求头中——apns-collapse-id。系统通过这个标识符知道哪个通知是需要移除或者更新的。 在下面例子中，你的app想发送关于游戏的通知，它想通知游戏开始的时间。因此你创建推送请求并且将其放入系统的schedule中。但是，现在需要告知游戏被取消了。这时候就需要调用removePendingNotificationRequests方法并传入创建推送请求时传入的标识符。那如何更新游戏的开始时间呢？你需要创建新的请求，并传入与之前相同的标识符，设置新的时间并放入系统的schedule中。 1234567891011// Pending Notification Removallet gameStartIdentifier = \"game1.start.identifier\"let gameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: startTrigger)UNUserNotificationCenter.current().add(gameStartRequest) &#123; (error) in // ... &#125;// Game was cancelledUNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier])// Game start time was updatedlet updatedGameStartRequest = UNNotificationRequest(identifier: gameStartIdentifier, content: content, trigger: newStartTrigger)UNUserNotificationCenter.current().add(updatedGameStartRequest) &#123; (error) in // ... &#125; 下面再来说说通知已经发送出去的情况。我们举足球比分的例子来说明。你创建了通知请求并将其发送到系统。但是通知更新的是错误的比分，这时候你可以很简单地通过调用removeDeliveredNotifications来移除之前的通知。当然，你也可以创建新的推送请求更新原来通知的比分。当然，这两种做法都要传入相同的请求标识符。 12345678910111213// Delivered Notification Removallet gameScoreIdentifier = \"game1.score.identifier\"let gameScoreRequest = UNNotificationRequest(identifier: gameScoreIdentifier, content: scoreContent, trigger: trigger)UNUserNotificationCenter.current().add(gameScoreRequest) &#123; (error) in // ... &#125;// Wrong game score was publishedUNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [gameScoreIdentifier])// Score game was updatedlet updateGameScoreRequest = UNNotificationRequest(identifier: gameScoreIdentifier, content: newScoreContent, trigger: newTrigger)UNUserNotificationCenter.current().add(updateGameScoreRequest) &#123; (error) in // ... &#125; Actions下面介绍用户接收到推送通知后的处理操作。app可以识别用户对于通知消息处理的三种类型操作。 第一种类型操作是最常规的，那就是用户点击推送消息打开app。这个操作可以在设备解锁并且接收到推送消息，用户点击横幅时发生。也可以在锁屏状态下用户向右滑动消息，在下拉通知中心点击消息发生这个操作。 第二种类型操作是自定义快捷操作行为。这时候的推送消息就是可以执行操作的消息。这些自定义操作行为以按钮的形式出现在推送消息的下面。在iOS 9中引入了textinput action，这样用户可以快速回复消息。这些自定义的快捷操作行为可以在前台可以在后台中。 在后台中执行action会移除消息并且会给后台很短的一段时间去处理用户点击的action触发的事件。另一方面，在前台中执行action会移除消息并且启动app这样app就可以处理action触发的事件。 所有的自定义快捷操作都需要与category关联起来。category需要唯一的标识符，这个标识符会设置到所有你想要的action中。除此之外，你还可以设置intent标识符，关于intent的更多信息可以参考SiriKit Session。当你创建完所有的action和category时，你需要做的唯一的事情就是将它们注册到UNUserNotificationCenter对象中与你的应用程序相关联。 123let action = UNNotificationAction(identifier:”reply\",title:\"Reply\",options:[])let category = UNNotificationCategory(identifier: \"message\", actions: [action], minimalActions: [action], intentIdentifiers: [], options: [])UNUserNotificationCenter.current().setNotificationCategories([category]) 12345678910// Remote Notifications&#123; aps : &#123; alert : “Welcome to WWDC !”, category: \"message\" &#125;&#125;// Local Notificationscontent.categoryIdentifier = \"message\" 接下来说说如何将自定义的aciton展示给你的用户。在远程推送中，你需要在远程推送通知的APS字典中设置category标识符。现在这个标识符需要与之前注册的category标识符能匹配上。在本地推送中，你需要在创建的推送内容中设置category标识符。同样的，这个category标识符必须与注册的category标识符能匹配上。 第三种类型操作是dismiss行为。该行为在用户移除指定的通知消息时触发。比如说，你有个日历app，你给用户发送了一条关于即将到来的会议的远程推送通知。用户看到了这则通知并移除它时，你想要停止向该用户其他的设备再发送这条用户已经看到的远程推送通知。那用户如何才算是真正地移除通知消息呢？用户可以在锁屏界面或者下拉通知中心中从右向左滑动消息并点击“清除”按钮。 在之前讨论的注册不同的category时，我们提到一些选项，customDismissAction选项是其中的一个。我们需要做的是将customDismissAction添加到category中，那么当用户移除跟category关联的通知消息时，app将会接收到dismiss行为。 123customDismissAction: UNNotificationCategoryOptionslet category = UNNotificationCategory(identifier: \"message\", actions: [action],minimalActions: [action], intentIdentifiers: [], options: [.customDismissAction]) 以上就是关于自定义通知行为的三种类型的介绍。那么自定义行为的操作的处理在哪里进行呢？在UNUserNotificationCenter代理方法中有这样一个方法——didReceive response:,实现这个方法来处理自定义行为的操作。 12protocol UNUserNotificationCenterDelegate : NSObjectProtocol func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: () -&gt; Void) 我们把目光聚焦到该方法中的UNNotificationResponse上。这个对象中包含你创建的action的action identifier，如果这个action是text input action，那还会有user text属性。它还包含一个通知消息对象，消息对象中自然还包含请求对象以及标识符。 Service extension再来谈谈远程推送。iOS 10引入了service extension，它的作用是在远程推送中在推送通知展示到用户之前添加或者修改通知消息中的内容，同时，还会对消息中的内容进行端对端的加密。注意，它是在后台运行工作的。关于service extension工作原理的介绍已经在前一篇文章中解释过了。现在重点讲述如何代码实现service extension。 首先，你需要做的是在Xcode项目中添加新的target，如下图所示。 之后在这个模板中会有一个类。它是UNNotificationServiceExtension类的子类。它有两个主要的方法。第一个方法可以获取当前的推送请求对象，可以在其中修改推送消息的内容。当service extension运行超时时，第二个方法会被触发。 12345678910// Service Extensionimport UserNotificationsclass NotificationService: UNNotificationServiceExtension &#123; override func didReceive(request: UNNotificationRequest, withContentHandler contentHandler:(UNNotificationContent) -&gt; Void) &#123; // Modify the notification content &#125; override func serviceExtensionTimeWillExpire() &#123; // Called before the extension will be terminated by the system &#125;&#125; 接下来我们来看看如何在远程推送中真正地触发上面这段代码。下面是远程推送消息的简易版本，其中有一个新的mutable-content字段。你需要用这个字段来让系统知道你想要系统启动service extension去更新远程推送消息中的内容。当然你不必每次都去启动service extension服务，只需要在需要更新推送通知内容的时候再去启动它。 12345678// Example payload&#123; aps : &#123; alert : “New Message Available”, mutable-content : 1 &#125;, encrypted-content : “#myencryptedcontent”&#125; 我们再来看看如何去解密远程推送通知中加密的内容。在下面代码中，我们看到了didReceive方法。该方法是推送请求的方法，在这个方法中要做的事情就是解密远程推送通知中加密的内容。然后，我们创建一个UNMutableNotificationContent对象并将解密出来的内容赋给它。最后，我们调用contentHandler方法将解密的内容展示在用户面前。 12345678910// Decrypt Remote Notification Payload in Service Extension and Update Notification Contentoverride func didReceive(request: UNNotificationRequest, withContentHandler contentHandler:(UNNotificationContent) -&gt; Void) &#123; // Decrypt the payload let decryptedBody = decrypt(request.content.userInfo[“encrypted-content”]) let newContent = UNMutableNotificationContent() // Modify the notification content newContent.body = decryptedBody // Call content handler with updated content contentHandler(newContent)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"iOS 10推送通知小记（上）","slug":"iOS 10推送通知小记（上）","date":"2016-07-23T06:22:31.000Z","updated":"2016-09-22T12:30:30.000Z","comments":true,"path":"2016/07/23/iOS 10推送通知小记（上）/","link":"","permalink":"http://zakariyyasv.pub/2016/07/23/iOS 10推送通知小记（上）/","excerpt":"概览最近在体验iOS 10Beta版的过程中，我发现iOS 10在锁屏界面的变动比较大，与之前的交互逻辑完全不同。与此同时，推送通知消息也有了改进，比如支持3D Touch，可以展示更多的信息，通知内容可以包含图片等等。按照逻辑推断iOS 10推送通知的API会有变化，于是，我赶紧查阅了Xcode 8Beta中的文档以及WWDC2016的视频，果然发现了玄机。 推送机制","text":"概览最近在体验iOS 10Beta版的过程中，我发现iOS 10在锁屏界面的变动比较大，与之前的交互逻辑完全不同。与此同时，推送通知消息也有了改进，比如支持3D Touch，可以展示更多的信息，通知内容可以包含图片等等。按照逻辑推断iOS 10推送通知的API会有变化，于是，我赶紧查阅了Xcode 8Beta中的文档以及WWDC2016的视频，果然发现了玄机。 推送机制 推送机制在iOS 10上发生了一点变化。 iOS &lt; 10.0推送按照通知发送源分为本地推送和远程推送。 先说本地推送。本地推送是由设备上的app发起的，本地推送通知被加入到schedule中后，被诸如时间、位置、任务等触发通知而使其显示到设备上。当用户对通知消息做出反应，发起通知的app会得到回调。 再说远程推送。远程推送是由app的服务器通过网络连接发送的。app先注册远程通知得到APNS(Apple Push Notification Service)返回的device token，app的服务端将推送通知的负载连同device token发送给APNS。APNS根据device token将推送通知发送到用户的设备上。设备接收到通知后会展示在屏幕上供用户浏览和处理，之后app会得到用户处理的回调。 iOS &gt;= 10.0iOS 10新增了trigger。依据字面意思理解就是推送通知的触发器，告诉设备什么时候触发通知显示在设备上。iOS 10支持四种类型的trigger：push、timer interval、calendar and location。其中push属于远程推送，其他三种属于本地推送。 iOS 10推送通知的过程变成了这样：app注册通知，创建通知的内容，trigger，identifier，将这些放入UNNotificationRequest对象中，最后将其放入schedule。 Notification Service Extensions在iOS 10之前，推送通知的负载大小最多也就4KB，因而类似于声音、图像、视频等无法存储到推送通知当中。为了解决这个问题，iOS 10引入了新的扩展服务——Notification Service Extensions。Notification Service Extensions可以帮助我们在不打开app的情况下去下载或者是改变远程推送通知消息中的内容。由于推送通知的负载不足以存储多媒体文件本身，因而以URL的形式存储。一旦设备接收到来自于你的app的远程推送通知的负载，Notification Service Extensions便去下载URL当中的资源文件，然后会在用户查看通知消息时展现给用户。 那么它是如何工作的呢？在通知的服务端，发送的通知会被service extension加工成两个部分：1234567&#123; aps: &#123; alert: &#123;...&#125; mutable-content: 1 &#125; my-attachment: \"https://foo.bar/baz.jpg\"&#125; mutable-content字段告诉iOS在通知被发送之前通知中有内容要被service extension修改，my-attachment字段包含了被下载内容的URL。 为了能让app的扩展服务能够处理通知消息，我们需要在app的Xcode project中添加notification service extension。Xcode会生成一个包含UNNotificationServiceExtension子类的文件。123456789override func didReceive(_ request: UNNotificationRequest, withContentHandler contentHandler:(UNNotificationContent) -&gt; Void) &#123; // ...&#125;// ...override func serviceExtensionTimeWillExpire() &#123; // Called just before the extension will be terminated by the system. // Use this as an opportunity to deliver your \"best attempt\" at modified content, otherwise the original push payload will be used. // ...&#125; 这个文件包含两个需要被重写的方法。第一个方法用来下载URL中的内容并将其添加到通知当中。由于网络是不可靠的，因此我们还需要在此方法中处理网络发生错误的情况。第二个方法是用来处理第一个方法运行超时的情况，当attachment下载消耗太长的时间时，操作系统会执行serviceExtensionTimeWillExpire()方法终止下载并发送类似于”best attempt”内容的通知。 Media AttachmentsMedia Attachments是用来附着在推送通知上负责存储多媒体文件的URL。目前支持的多媒体文件类型包括常用的音频、视频和图片（包括GIF）格式。 1234567891011// Adding an attachment to a user notificationpublic class NotificationService: UNNotificationServiceExtension &#123; override public func didReceive(_ request: UNNotificationRequest,withContentHandler contentHandler: (UNNotificationContent) -&gt; Void) &#123; let fileURL = // ... let attachment = UNNotificationAttachment(identifier: \"image\",url: fileURL, options: nil) let content = request.content.mutableCopy as! UNMutableNotificationContent content.attachments = [ attachment ] contentHandler(content) &#125;&#125; Media Attachments在本地推送与远程推送的工作机制有轻微差别。在本地推送中，它的media attachment在app创建通知时就必须包含某个本地磁盘文件的URL。当通知生效时，那份文件会被拷贝一份随着通知一起发送出去。除此之外，不需要做别的工作。在远程推送中，远程通知服务会将media attachment作为APNS通知负载的一部分发送出去。media attachment中包含的URL的内容不限定必须是已经存在设备中的文件。然而，iOS 10无法自动发送attachment内容不存储在本地的通知，这就要借助到前面提到的Notification Service Extensions。 Notification Content Extensions如果我们想在通知中展现app中一样的界面内容时，该怎么办？Notification Content Extensions派上用场了。Notification Content Extensions与Notification Service Extensions在通知中提供新的内容方面有相似之处，但两者有两个重要的区别。第一，Notification Content Extensions在本地推送和远程推送当中都起作用，而Notification Service Extensions只在远程推送中工作。第二，Notification Content Extensions只能处理media attachment中的内容，而Notification Service Extensions不仅能处理media attachment中的内容，更能在通知详情中展示整个的UIViewController。 在上图中我们看到了日历通知的日历事件就是用到了Notification Content Extensions。在Xcode项目中添加Notification Content Extensions与Notification Service Extensions的操作类似。 12345678910111213// Minimal Content Extensionclass NotificationViewController: UIViewController, UNNotificationContentExtension &#123; @IBOutlet var label: UILabel? override func viewDidLoad() &#123; super.viewDidLoad() // Do any required interface initialization here. &#125; func didReceive(_ notification: UNNotification) &#123; label?.text = notification.request.content.body &#125;&#125; 创建成功后，Xcode会生成一个storyboard文件、代码文件以及可以自定义contentn extension内容的info.plist文件。代码文件中包含了一个实现UNNotificationContentExtension协议的UIViewController的子类。要想让它生效，我们需要实现协议中必须实现的方法，在storyboard中自定义view设置info.plist文件中的category ID。 结语原理部分的内容就这么多了，关于推送的UserNotifications.framework代码方面的内容会放到下一篇中。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"iOS 10 UICollectionView新特性小记","slug":"iOS 10 UICollectionView新特性小记","date":"2016-07-18T06:36:31.000Z","updated":"2016-10-14T12:42:10.000Z","comments":true,"path":"2016/07/18/iOS 10 UICollectionView新特性小记/","link":"","permalink":"http://zakariyyasv.pub/2016/07/18/iOS 10 UICollectionView新特性小记/","excerpt":"预览iOS 10对于UICollectionview的改进优化主要表现在以下三个方面： 平滑的滑动体验 self-sizing改进 interactive reordering 平滑的滑动体验1.卡顿的原因","text":"预览iOS 10对于UICollectionview的改进优化主要表现在以下三个方面： 平滑的滑动体验 self-sizing改进 interactive reordering 平滑的滑动体验1.卡顿的原因 在iOS 10之前我们在使用UICollectionview大幅度滑动加载复杂的视图时，很可能会出现卡顿掉帧的情况，这是很影响用户体验的。那为什么会出现这种情况呢？从下面的图可以看出，当cell准备显示到屏幕上时，cell的加载工作就已经完成了。但注意，在屏幕外加载的数据是一整行的cell。这样大量的加载工作在快速滑动的过程中便会稍显吃力，也就造成了卡顿和掉帧。 下图中绘制出了上图的实验数据。其中，x轴表示显示刷新事件，y轴表示主线程中CPU处理的时间。我们知道手机屏幕的刷新率在60FPS，也就意味着每16ms就要刷新一次，若CPU处理的时间超过16ms，便会将加载挤压到下一帧从而引起卡顿。从图中可以看到当屏幕快速滑动时，CPU处理时间超过16ms，会有卡顿，而在缓慢滑动过程中，CPU的处理时间很短，不会有卡顿。 那如何解决这个问题呢？我们需要将Cell的加载工作分摊，达到下图的效果，就可以解决这个问题了。那如何分摊cell的加载工作呢？这就要涉及到Cell的生命周期了。 2.Cell Life Cycle在iOS 10之前，当我们滑动UICollectionView时，就需要添加新的cell。我们将它从reuse队列中拿出来，然后调用prepareForReuse。这个方法让cell将其本身重置为默认状态，接收并加载app中的新数据。 接下来，我们会继续调用cellForItemAtIndexPath方法。这里主要是你做填充cell工作的地方，你可以加载数据模型，并将其设置到cell中，然后返回给系统。 之后，在cell显示到屏幕之前，我们会调用willDisplayCell方法。这个方法是让你做cell显示到屏幕上最后工作的地方。 当Cell从屏幕上滑出时，我们会调用didEndDisplayingCell方法。这就是iOS 10之前整个cell的生命周期。 在iOS 10中，当我们滑动UICollectionView需要添加新的cell时，我们会从reuse队列中拿出来，然后，调用prepareForReuse方法。 接下来，在cellForItemAtIndexPath方法中填充cell的内容。 用户继续滑动，接下来发生的事情有所不同。我们不再在创建cell的时候就调用willDisplayCell方法，该方法的调用时机放到cell显示到屏幕上的时候。 接着，用户继续滑动。当cell离开UICollectionview的可视区域时，我们会调用didEndDisplayingCell方法。在iOS 10之前，在此时cell就进入了reuse队列中。当这个cell需要重新显示数据的时候，我们就必须要重新进行一遍cell的生命周期。但是在iOS 10中，我们会将cell保持一段时间。在这段时间内，用户想查看已经滑出屏幕的cell往回滑动时，cell不需要再重新走一遍生命周期，只需要调用willDisplayCell即可。 在一行多列的情况中同样适用。我们一次加载一个cell而不是一行cell来获得更好的滑动体验。我们先加载第一个cell，加载完再加载第二个cell，当两个cell加载完成后并且cell即将显示到屏幕上时，我们调用两者的willDisplayCell方法。 下图是模拟iOS 10下系统加载cell的情况。可以看到iOS 10下的滑动相比iOS 9流畅很多，没有卡顿。 3.Cell Pre-FetchingiOS 10引入了Pre-Fetching，默认情况下是开启的。若你必须用到iOS 10之前老的生命周期，只需要在UICollectionview中添加isPrefetchingEnabled属性。 1collectionView.isPrefetchingEnabled = false 为了能最好地发挥这个特性，我们要做到在cellForItemAtIndexPath方法中做耗费资源和时间的工作，包括cell的所有内容的创建。另外，我们要确保在willDisplayCell和didEndDisplayCell方法中做轻量甚至不做工作。 更进一步，我们该如何处理繁重的data models？在cell内容创建的过程中需要处理繁重的任务，比如图片解码、连接数据库、从CoreData中加载数据。为了解决这个问题，iOS 10引入了新的API帮助告诉你的数据模型如何加载内容。 UICollectionView有两个组成部分：dataSource和delegate。iOS 10引入新的组成元素：prefetchDataSource。它是可选的，并且只必须实现一个方法。 12345678protocol UICollectionViewDataSourcePrefetching &#123; func collectionView(_ collectionView: UICollectionView, prefetchItemsAt indexPaths: [NSIndexPath]) optional func collectionView(_ collectionView: UICollectionView, cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])&#125;class UICollectionView : UIScrollView &#123; weak var prefetchDataSource: UICollectionViewDataSourcePrefetching? var isPrefetchingEnabled: Bool&#125; 第一个方法叫prefetchItemsAt indexPaths。该方法会在你异步预加载模型中的内容时在prefetch data source中调用。方法中的indexpath参数是有序数组可以帮助更好的读取模型中的数据。第二个方法叫cancelPrefetchingForItemsAt indexPaths（可选）。当我们决定不再滑动到某个indexPath集合时会被prefetch data source调用。你可以调用它来取消或者降低任何预加载的优先级。 需要注意的是，这不是对数据模型的代替。它只是对已经存在的异步加载数据方法的起到辅助作用。 下面总结一下使用预加载的注意点： 1.在调用方法时，确保所处理的工作都是在后台线程中进行。配合GCD和NSOperationQueue去处理多线程任务。2.记住pre-fetch是自适应技术。当滑动缓慢时，pre-fetch会做额外的工作去优化。当滑动快速时，需要频繁刷新屏幕，这时候就不再做pre-fetch。3.调用cancelPrefetchingForItemsAt indexPaths方法去处理用户滑动操作的切换。 在iOS 10中，与UICollectionview一脉相承的UItableview也加入了相同的API。1234567protocol UITableViewDataSourcePrefetching &#123; func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths:[NSIndexPath]) optional func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:[NSIndexPath])&#125;class UITableView : UIScrollView &#123; weak var prefetchDataSource: UITableViewDataSourcePrefetching?&#125; self-sizing cell在UICollectionView中有一个实体布局类UICollectionViewFlowLayout，它已经全面支持self-sizing cells。要开启这一特性，需要设置estimated item size为不为0的CGSize。它会告诉UICollectionView你想要在内容显示的时候动态计算布局。 1layout.estimatedItemSize = CGSize(width:50,height:50) 为了能够准确的得到cell的真实尺寸，有三种方法可以达到需求。 1.AutoLayout。当给cell的contentView的所有层级的视图添加约束后，自动布局系统自动计算出cell的大小。2.重写sizeThatFits()方法。如果你不想使用自动布局，并想手动控制就用这个方法。3.重写preferredLayoutAttributesFittingAttributes()方法。该方法不仅提供尺寸信息还能提供像变换、alpha等属性信息。 但是在实际操作中，我们很难去设置合适的estimated item size。如果flowlayout可以依据数学计算出的尺寸而不是根据布局内容的真实尺寸去适应那会非常棒。为此，iOS 10引入了新的API。 1layout.estimatedItemSize = UICollectionViewFlowLayoutAutomaticSize 我们需要做的就是将estimated item size设置为UICollectionViewFlowLayoutAutomaticSize，flowlayout会自动计算布局，它不仅能计算所有cell当前的size，还能依此动态预测接下来的cell的size大小。 接下来看两个例子更能明显看出差别。 在下图中可以看到在iOS 10之前，当单个cell的尺寸改变时，其他的cell没有变化，布局需要重新计算。 在iOS 10中，当第一个cell的size发生改变时，系统会自动计算出所有cell的size大小，然后刷新界面。 Interactive Reordering先看看iOS 9里面的API： 123456class UICollectionView : UIScrollView &#123; func beginInteractiveMovementForItem(at indexPath: NSIndexPath) -&gt; Bool func updateInteractiveMovementTargetPosition(_ targetPosition: CGPoint) func endInteractiveMovement() func cancelInteractiveMovement()&#125; 要想开启interactive movement，我们就需要调用beginInteractiveMovementForItem()方法，其中indexPath代表了我们将要移动走的cell。接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作。这时我们就需要调用updateInteractiveMovementTargetPosition()方法。我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用endInteractiveMovement()方法。 UICollectionView就会放下cell，处理完整个layout，此时你也可以重新刷新model或者处理数据model。如果中间突然手势取消了，那么这个时候就应该调用cancelInteractiveMovement()方法。如果我们重新把cell移动一圈之后又放回原位，其实就是取消了移动，那这个时候就应该在cancelInteractiveMovement()方法里面不用去刷新data source。 在iOS 10中，如果你使用UICollectionViewController，那么这个重排对于你来说会更加的简单。 123class UICollectionViewController : UIViewController &#123; var installsStandardGestureForInteractiveMovement: Bool&#125; 你只需要把installsStandardGestureForInteractiveMovement这个属性设置为True即可。CollectionViewController会自动为你加入手势，并且自动为你调用上面的方法。 iOS 10在iOS 9的基础上增加了翻页功能。 1collectionView.isPagingEnabled = true 开启分页前： 开启分页后： UIRefreshControlUIRefreshControl现在可以直接在CollectionView里面使用，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController。因为现在RefreshControl成为了ScrollView的一个属性了。 1234let refreshControl = UIRefreshControl()refreshControl.addTarget(self, action: #selector(refreshControlDidFire(_:)), for: .valueChanged)collectionView.refreshControl = refreshControl UIRefreshControl的使用方法很简单，先创建一个refreshControl，再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性即可。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"H5游戏接入技术小结（下）","slug":"H5游戏接入技术小结（下）","date":"2016-05-20T08:16:06.000Z","updated":"2016-10-14T12:09:35.000Z","comments":true,"path":"2016/05/20/H5游戏接入技术小结（下）/","link":"","permalink":"http://zakariyyasv.pub/2016/05/20/H5游戏接入技术小结（下）/","excerpt":"概览在上一篇H5游戏接入技术小结（上）中，主要介绍了H5游戏资源的下载和运行。本篇文章主要是介绍app与H5游戏的交互以及在线与其他玩家对战的技术总结。","text":"概览在上一篇H5游戏接入技术小结（上）中，主要介绍了H5游戏资源的下载和运行。本篇文章主要是介绍app与H5游戏的交互以及在线与其他玩家对战的技术总结。 app与H5游戏交互app与游戏交互本质上就是app与浏览器进行交互，交互的媒介自然是要靠JS。交互的内容倒并不复杂，复杂的在于iOS版本的适配。iOS中webview有两个类UIWebView和WKWebView，性能方面来说WKWebView会更好一些（如果你对UIWebView和WKWebView的区别不太了解，可以看这篇博文），但WKWebView是iOS 8之后才引入的，故iOS 8之前的版本只能采用UIWebView。JS与OC交互的类库用的较多的是JavaScriptCore和WebViewJavaScriptBridge，其中JavaScriptCore是iOS 7之后苹果开放的类库，而WebViewJavaScriptBridge则是第三方类库，并且作者也说明了对于WKWebView的支持上还存在bug。综合来看最佳的解决方案应该是WKWebView与JavaScriptCore的组合，然而在WKWebView中我们无法获取context，也就是说WKWebView不支持JavaScriptCore。综合考虑后，还是决定采用UIWebView与JavaScriptCore组合(iOS 7)与WKWebView与原生JS组合(iOS 8及以上)的方案。 UIWebView与JavaScriptCore交互相比于WebViewJavaScriptBridge，JavaScriptCore的学习成本要更低一些。JavaScriptCore中包含了以下几个类： JSContext JSManagedValue JSValue JSVirtualMachine JSContext对象代表了JS的运行环境，我们可以创建和使用JS上下文来执行OC或者swift代码中的JS脚本，访问JS中定义或者计算出的值，让JS可以访问原生的对象，方法或者函数。JSValue是对JS中的值的引用。你可以用JSValue类在JS和OC（或swift）进行值类型的转换来互相传递数据。你还可以用该类创建JS对象封装原生的自定义类的对象或方法。JSManagedValue对象是对JSValue对象的封装，增加了“条件持有”的行为来对值进行自动内存管理。该类最基本的使用场景是将JS值存储在OC（或swift）对象中并将其传递给JS代码。JSVirtualMachine对象代表的是独立的JS运行环境。使用这个类有两个目的：支持JS并发执行和管理在JS和OC（或swift）桥接对象的内存。 OC调用JSOC中调用JS代码主要依赖JSContext和JSValue类，一个 JSContext 是一个全局环境的实例。调用JS代码主要调用JSContext的evaluteScript方法，创建一个 JSContext 后，可以很容易地运行 JavaScript 代码来创建变量，做计算，甚至定义方法： 12345JSContext *context = [[JSContext alloc] init];[context evaluateScript:@\"var num = 5 + 5\"];[context evaluateScript:@\"var names = ['Grace', 'Ada', 'Margaret']\"];[context evaluateScript:@\"var triple = function(value) &#123; return value * 3 &#125;\"];JSValue *tripleNum = [context evaluateScript:@\"triple(num)\"]; 代码的最后一行，任何出自JSContext的值都被包裹在一个JSValue对象中。像JavaScript 这样的动态语言需要一个动态类型，所以JSValue包装了每一个可能的JavaScript值：字符串和数字；数组、对象和方法；甚至错误和特殊的JavaScript值诸如null和undefined。如果想将JSValue类型转为OC（或swift）下的数据类型，可以调用JSValue相关的方法实现： 若想调用JS代码中的方法，可以使用下标方式或者调用objectForKeyedSubscript:方法来实现。例如，我在JS文件中定义了求阶乘的方法： 1234567var factorial = function(n) &#123; if (n &lt; 0) return; if (n === 0) return 1; return n * factorial(n - 1)&#125;; 在OC中我们可以这样去调用计算阶乘的方法： 123456789JSContext context = [[JSContext alloc] init];// 执行指定路径下JS文件中的代码[context evaluateScript:[NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]];// 1.下标访问JSValue *function = self.context[@\"factorial\"];// 2.方法访问JSValue *function = [self.context objectForKeyedSubscript:@\"factorial\"];// 调用阶乘方法并传递参数JSValue *result = [function callWithArguments:@[@5]]; 同时，JSContext也提供对于引用和异常本身的回调处理——通过设置context的exceptionHandler属性。 123context.exceptionHandler = ^(JSContext *context, JSValue *exception)&#123; NSLog(@\"JS Error: %@\", exception);&#125;; JS调用OCJS访问客户端代码的方式主要有两种：block和JSExport协议。 先说第一种：block。当一个block被赋给JSContext里的一个标识符，JavaScriptCore会自动的把block封装在JS函数里。这使得在JS中可以简单的使用Foundation和Cocoa类，所有的桥接都为你做好了。例如下面代码中，弹出alertView的block被赋给context的”alert”，如果想要在JS中调用这个block，只需要调用alert()方法并传入参数即可。 123456context[@\"alert\"] = ^(NSString *str)&#123; UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@\"msg from js\" message:str delegate:nil cancelButtonTitle:@\"ok\" otherButtonTitles:nil]; [alert show];&#125;;NSLog(@\"%@\", [context evaluateScript:@\"alert('hello')\"]); block方式使用起来很简单，但也有需要注意的地方。由于block对变量是强引用，而JSContext也强引用所有的变量，因此很容易会产生循环引用问题。这里有些注意点总结如下： 1.在block中不要直接使用context，而是用[JSContext currentContext]得到当前上下文。12345678// 错误示范self.context[@\"name\"] = ^()&#123; JSValue *value = [JSValue valueWithObject:@\"aaa\" inContext:self.context];&#125;;// 正确做法self.context[@\"name\"] = ^()&#123; JSValue *value = [JSValue valueWithObject:@\"aaa\" inContext:[JSContext currentContext]];&#125;; 2.不要在block中引用外部变量，而是将其作为参数进行传递。 123456789JSValue *value = [JSValue valueWithObject:@\"ssss\" inContext:self.context];// 错误self.context[@\"name\"] = ^()&#123; NSLog(@\"%@\",value); &#125;;// 正确self.context[@\"name\"] = ^(NSString *str)&#123; NSLog(@\"%@\",str); &#125;; 再说第二种：JSExport协议。这个协议可以让JS代码访问OC的类实例，实例方法，类方法和属性。以下以Person类为例来说明。首先，需要定义PersonJSExpoert协议继承JSContext，这个协议指定哪些属性和方法在JS中是可用的。然后，Person类需要去遵守并实现PersonJSExpoert协议。 12345678910111213141516171819202122232425262728293031// Person.h @class Person;@protocol PersonJSExports &lt;JSExport&gt;@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property NSInteger ageToday;- (NSString *)getFullName;// create and return a new Person instance with `firstName` and `lastName`+ (instancetype)createWithFirstName:(NSString *)firstName lastName:(NSString *)lastName;@end@interface Person : NSObject &lt;PersonJSExports&gt;@property (nonatomic, copy) NSString *firstName;@property (nonatomic, copy) NSString *lastName;@property NSInteger ageToday;@end// Person.m @implementation Person- (NSString *)getFullName &#123; return [NSString stringWithFormat:@\"%@ %@\", self.firstName, self.lastName];&#125;+ (instancetype) createWithFirstName:(NSString *)firstName lastName:(NSString *)lastName &#123; Person *person = [[Person alloc] init]; person.firstName = firstName; person.lastName = lastName; return person;&#125;@end 这样在JS中就可以创建新的Person实例,在这个例子中，Objective-C的方法createWithFirstName:lastName:变成了在JavaScript中的createWithFirstNameLastName()： 12345678910var loadPeopleFromJSON = function(jsonString) &#123; var data = JSON.parse(jsonString); var people = []; for (i = 0; i &lt; data.length; i++) &#123; var person = Person.createWithFirstNameLastName(data[i].first, data[i].last); person.birthYear = data[i].year; people.push(person); &#125; return people;&#125; JavaScriptCore介绍完了，那么在UIWebView中若想要拿到JSContext对象，就要调用下面这个方法：1[webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"] 这里涉及到UIWebView创建JSContext上下文环境的时机问题，那么什么时候UIWebView会创建JSContext的上下文环境呢？默认情况下，在渲染网页时遇到&lt;script&gt;标签时，就会创建JSContext上下文环境去运行JS代码。还有就是调用[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]去获取JSContext环境时，这时无论是否遇到&lt;script&gt;标签，都会去创造出来一个JSContext环境，而且和遇到&lt;script&gt;标签创造的环境是同一个。 这时候又牵扯到何时注入JSContext的问题。我通常都会在- (void)webViewDidFinishLoad:(UIWebView *)webView中去注入交互对象，但是这时候网页还没加载完，JavaScript那边已经调用交互方法，这样就会调不到原生应用的方法而出现问题。如果改成在- (void)viewDidLoad中去注入交互对象，这样倒是解决了上面的问题，但是同时又引起了一个新的问题就是在一个网页内部点击链接跳转到另一个网页的时候，第二个页面需要交互，这时JSContext环境已经变化，但是- (void)viewDidLoad仅仅加载一次，跳转的时候，没有再次注入交互对象，这样就会导致第二个页面没法进行交互。当然你可以在- (void)viewDidLoad和- (void)webViewDidFinishLoad:(UIWebView *)webView都注入一次。 WKWebView与原生JS交互采用WKWebView与原生JS交互的原因在于WKWebView相比于UIWebView，其与JS交互的能力明显增强，并且在加载速度及内存占用上都有显著提升。WKWebView与JS交互主要依赖于两个概念：user scripts和script messages。 先说user scripts。简单来说，它是在WKWebView加载时被注入到web页面中的JS代码块。当然，user scripts也可以在页面内容(DOM)加载完成之前或者加载完成之后注入和运行。user scripts可以做到JS在页面中能做到的所有事情，包括操作DOM和调用页面中存在的已加载的任何JS方法。user scripts是原生app调用JS的方式。 再说script messages。script messages是web页面调用原生app的方式。一个script message与页面中的JS方法绑定，你需要在原生app中定义处理方法来负责处理web页面传过来的消息。script message可以由user script或者任何其他加载进页面的脚本触发。 以下我会以一个小demo来说明WKWebView与JS如何交互的。在demo中我要做到的是如何通过再原生app中调用JS方法来改变DOM元素的颜色并且同时监听html页面中的JS发送给原生app的异步消息。 为了能让web页面和WKWebView交互，我们需要两个主要的元素： 1.带有可以被WKWebView加载的JS代码的web页面2.可以与web页面进行通信交互的WKWebView原生app Web页面web页面的构成很简单，包含两个文件：index.html和main.js，index.html是页面文件，main.js被index.html调用。main.js文件的内容如下： 123456789101112131415function callNativeApp () &#123; try &#123; webkit.messageHandlers.callbackHandler.postMessage(\"Hello from JavaScript\"); &#125; catch(err) &#123; console.log('The native context does not exist yet'); &#125;&#125;setTimeout(function () &#123; callNativeApp();&#125;, 5000);function redHeader() &#123; document.querySelector('h1').style.color = \"red\";&#125; 当这段脚本代码被加载时，它会延迟5秒后调用callNativeApp方法。我们要注意的是”callbackHandler”，这是我们后面在原生app中定义的script message handler的名字。另外，我将回调”webkit.messageHandlers…..”封装进try-catch中来避免当脚本不再原生app的context下运行时会产生错误。最后还有一个改变html页面中h1标签颜色为红色的方法，后面我们会用到它。我将从本地服务器去加载它来模拟更真实的环境。 原生app关于WKWebView的使用在此就不赘述了，不了解的可以查阅苹果相关文档。首先我们要做的是创建WKWebView对象并指定测试的URL地址。 1234self.webView = WKWebView()var url = NSURL(string:\"http://localhost/WKJSDemo/\")var req = NSURLRequest(URL:url)self.webView!.loadRequest(req) 原生app调用JSWKWebView的初始化方法有一个参数叫configuration，接收的是WKWebViewConfiguration实例，通过这个实例我们可以设置webView是否开启调用JS。这里我们需要设置的是WKWebViewConfiguration的userContentController属性。这个属性接收WKUserContentController实例。该实例有个方法叫做addUserScript，我们调用该方法添加user script。下面给出示例代码： 1234567891011121314var contentController = WKUserContentController();var userScript = WKUserScript( source: \"redHeader()\", injectionTime: WKUserScriptInjectionTime.AtDocumentEnd, forMainFrameOnly: true)contentController.addUserScript(userScript)var config = WKWebViewConfiguration()config.userContentController = contentControllerself.webView = WKWebView( frame: self.containerView.bounds, configuration: config) 在WKUserScript初始化方法中redHeader()对应的JS文件中的同名方法。”injectionTime”参数告诉user script当HTML页面的body加载完时运行脚本代码。”forMainFrameOnly”参数是说脚本只会被注入HTML页面的主帧中。 现在我们运行代码，就会发现HTML页面的头部文字是红色的。 JS调用原生app我们已经知道原生app中如何调用JS代码，那么JS如何调用原生app呢？正如我们之前说过的，这要用到”script messages”。 为了能接收到来自JS的事件，控制器需要遵守WKScriptMessageHandler协议。这意味着两点，我们要继承WKScriptMessageHandler并且实现userContentController的代理方法。 12345func userContentController(userContentController: WKUserContentController!, didReceiveScriptMessage message: WKScriptMessage!) &#123; if(message.name == \"callbackHandler\") &#123; println(\"JavaScript is sending a message \\(message.body)\") &#125;&#125; 我们注意到代理方法会检查消息的名字是否为”callbackHandler”，回想之前的JS代码中有一行是这样的：”webkit.messageHandlers.callbackHandler.postMessage…”。原生app的方法会检查接收到的script message是否是想要的，如果是想要的，则在控制台打印消息的所有信息。 接下来，我们需要告诉webview开始监听来自JS的事件。这需要我们给contentController添加”script handler”。 1contentController.addScriptMessageHandler( self, name: \"callbackHandler\") 第一个参数self是指script message的代理是ViewController。如果你想在另一个类中处理接收到的消息，需要将该类的实例传入。第二个参数传入的是在JS中调用原生userContentController代理方法的名字。 写完后编译运行，5秒后控制台会打印出信息。 代码123456789101112131415161718// index.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; body &#123; padding-top: 40px; &#125; &lt;/style&gt; &lt;title&gt;WKWebView Demo&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;WKWebView Test&lt;/h1&gt; &lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516// main.jsfunction callNativeApp () &#123; try &#123; webkit.messageHandlers.callbackHandler.postMessage(\"Hello from JavaScript\"); &#125; catch(err) &#123; console.log('The native context does not exist yet'); &#125;&#125;setTimeout(function () &#123; callNativeApp();&#125;, 5000);function redHeader() &#123; document.querySelector('h1').style.color = \"red\";&#125; 123456789101112131415161718192021222324252627282930313233343536// ViewController.swiftimport UIKitimport WebKitclass ViewController: UIViewController, WKScriptMessageHandler &#123; @IBOutlet var containerView : UIView! = nil var webView: WKWebView? override func loadView() &#123; super.loadView() var contentController = WKUserContentController(); var userScript = WKUserScript(source: \"redHeader()\", injectionTime: WKUserScriptInjectionTime.AtDocumentEnd, forMainFrameOnly: true ) contentController.addUserScript(userScript) contentController.addScriptMessageHandler( self, name: \"callbackHandler\") var config = WKWebViewConfiguration() config.userContentController = contentController self.webView = WKWebView(frame: self.containerView.bounds,configuration: config) self.view = self.webView! &#125; override func viewDidLoad() &#123; super.viewDidLoad() var url = NSURL(string:\"http://localhost/~jornki/tests/WKDemo/\") var req = NSURLRequest(URL:url) self.webView!.loadRequest(req) &#125; func userContentController(userContentController: WKUserContentController!, didReceiveScriptMessage message: WKScriptMessage!) &#123; if(message.name == \"callbackHandler\") &#123; println(\"JavaScript is sending a message \\(message.body)\") &#125; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"H5游戏接入技术小结（上）","slug":"H5游戏接入技术小结（上）","date":"2016-05-17T08:17:55.000Z","updated":"2016-10-12T13:48:39.000Z","comments":true,"path":"2016/05/17/H5游戏接入技术小结（上）/","link":"","permalink":"http://zakariyyasv.pub/2016/05/17/H5游戏接入技术小结（上）/","excerpt":"概览这段时间忙着做游戏平台H5游戏的接入，趁着刚做完还热乎劲儿，将其中的技术要点总结下来。H5游戏的接入主要分为两个部分：游戏的下载和游戏对战。本篇博客着重讲述游戏的下载部分，下篇博客将着重讲述H5游戏与app通过JS进行数据交互以及在线对战的技术要点。 H5游戏资源本质上是由一些目录以及目录下的文件资源组成，要能够在app中运行H5游戏，就是要在WKWebView的浏览器中用HTTPServer搭建本地服务，然后去加载游戏资源根目录下的index.html文件，换句话说index.html文件是游戏的入口文件。","text":"概览这段时间忙着做游戏平台H5游戏的接入，趁着刚做完还热乎劲儿，将其中的技术要点总结下来。H5游戏的接入主要分为两个部分：游戏的下载和游戏对战。本篇博客着重讲述游戏的下载部分，下篇博客将着重讲述H5游戏与app通过JS进行数据交互以及在线对战的技术要点。 H5游戏资源本质上是由一些目录以及目录下的文件资源组成，要能够在app中运行H5游戏，就是要在WKWebView的浏览器中用HTTPServer搭建本地服务，然后去加载游戏资源根目录下的index.html文件，换句话说index.html文件是游戏的入口文件。HTTPServer我们采用的是开源的CocoaHTTPServer，关于在app中搭建HTTPServer服务的内容就不多赘述，感兴趣的可以去Github上了解。当然，这也需要H5与iOS开发人员沟通和调试才能真正地在WKWebView中流畅运行。 游戏资源下载思路知道了怎样在app中运行H5游戏，接下来最重要的就是游戏资源的下载。当用户进入一个游戏后，游戏的状态分为三种：未下载，已下载，暂停下载和需要更新。如何判断游戏此时的状态呢？首先我们需要区分每一个游戏，因此，约定将游戏资源的URL进行MD5加密后的字符串作为游戏的唯一标识符。之后，我们创建game.plist文件，文件中存储一个字典，字典的key为游戏的标识符，value为游戏资源的大小。每当一个游戏开始下载，则在plist文件中添加一条记录。检查游戏的状态时，拿游戏的标识符与plist文件中所有的记录进行对比，若未找到相同的记录则状态为未下载。否则，在存储游戏资源的文件夹中查找以游戏标识符命名的.zip压缩包，若找到将其包的大小与plist文件中找到的记录的大小进行比较，若大小不同，则状态为暂停下载，若未找到压缩包且未找到解压后的资源文件夹显示为未下载。否则，状态为已下载。至于更新的状态则需要与服务器端进行沟通和约定，在此就不讲了。 确定完当前进入游戏的状态后，当游戏处于未下载或者暂停的状态时，用户可以点击下载按钮进行下载。下载的过程分为两种情况：未下载开始下载和暂停继续下载。第一种情况的下载过程是这样：在资源下载目录下创建以游戏标识符命名的.zip压缩文件，用NSURLSession创建NSURLSessionDataTask任务负责资源数据的接收，用NSOutputStream负责数据流的写入工作。写入完毕后，关闭NSOutputStream服务，验证资源包数据的完整性。若资源包数据完整，则对其进行解压缩，得到游戏运行的全部资源文件后便可以开始游戏。第二种情况则是在资源下载目录下查找以游戏标识符命名的.zip压缩包，获取包文件的内容大小，将其放入NSURLRequest的HTTP请求头中，剩下的步骤与第一种情况相同。 游戏资源下载的代码实现思路厘清了，就需要用代码去实现它。因此，我创建了名为XRDownloadManger的类负责游戏资源的下载工作。为了更好的辅助XRDownloadManager工作，又创建了模型类XRSessionModel来存储游戏资源的相关数据。 下面列出的是XRSessionModel的类结构： 12345678910111213141516171819202122// XRSessionModel.htypedef enum &#123; DownloadStateStart = 0, /** 下载中 */ DownloadStateSuspended, /** 下载暂停 */ DownloadStateCompleted, /** 下载完成 */ DownloadStateFailed /** 下载失败 */&#125;DownloadState;@interface XRSessionModel : NSObject/** 流 */@property (nonatomic, strong) NSOutputStream *stream;/** 下载地址 */@property (nonatomic, copy) NSString *url;/** 游戏版本号*/@property (nonatomic, copy) NSString *update;/** 获得服务器这次请求 返回数据的总长度 */@property (nonatomic, assign) NSInteger totalLength;/** 下载进度 */@property (nonatomic, copy) void(^progressBlock)(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress);/** 下载状态 */@property (nonatomic, copy) void(^stateBlock)(DownloadState state);@end XRDownloadManger采用了单例设计模式，该类主要的工作包括开启任务下载游戏资源并回调下载进度和下载状态，获取资源大小，删除已下载资源，判断游戏资源是否下载完成等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@interface XRDownloadManager : NSObject/** * 单例 * @return 返回单例对象 */+ (instancetype)sharedInstance;/** * 开启任务下载资源 * @param url 下载地址 * @param progressBlock 回调下载进度 * @param stateBlock 下载状态 */- (void)download:(NSString *)url update:(NSString *)update progress:(void(^)(NSInteger receivedSize, NSInteger expectedSize, CGFloat progress))progressBlock state:(void(^)(DownloadState state))stateBlock;/** * 查询该资源的下载进度值 * @param url 下载地址 * @return 返回下载进度值 */- (CGFloat)progress:(NSString *)url;/** * 获取该资源总大小 * @param url 下载地址 * @return 资源总大小 */- (NSInteger)fileTotalLength:(NSString *)url;/** * 判断该资源是否下载完成 * @param url 下载地址 * @return YES: 完成 */- (BOOL)isCompletion:(NSString *)url;/** * 删除该资源 * @param url 下载地址 */- (void)deleteFile:(NSString *)url;/** * 清空所有下载资源 */- (void)deleteAllFile;/** * 根据下载地址查找该资源路径 **/- (NSString *)getPathWithUrl:(NSString *)url;@end XRDownloadManger实现文件中包含两个可变字典类型的成员变量tasks和sessionModels，tasks负责保存所有的下载任务，sessionModels负责保存所有的下载资源的相关信息。tasks和sessionModels均是以url为key，但value分别为NSURLSessionDataTask和XRSessionModel的键值对。123456789101112- (NSMutableDictionary *)tasks&#123; if (!_tasks) &#123; _tasks = [NSMutableDictionary dictionary]; &#125; return _tasks;&#125;- (NSMutableDictionary *)sessionModels&#123; if (!_sessionModels) &#123; _sessionModels = [NSMutableDictionary dictionary]; &#125; return _sessionModels;&#125; download:::方法是负责下载的主要方法。每一个NSURLSessionDataTask对象负责一个游戏资源的下载，并将该对象存入tasks中。当下载完成并验证压缩包内容的完整性后将NSURLSessionDataTask对象移除，当需要暂停的时候，以游戏URL的md5字符串为key拿到NSURLSessionDataTask对象并执行suspend方法将下载任务暂停。暂停后继续下载也与之类似，同样是从tasks中拿到NSURLSessionDataTask对象并执行resume方法继续下载任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 开启任务下载资源 */- (void)download:(NSString *)url update:(NSString *)update progress:(void (^)(NSInteger, NSInteger, CGFloat))progressBlock state:(void (^)(DownloadState))stateBlock&#123; if (!url) return; // 判断资源是否下载完成 if ([self isCompletion:url]) &#123; stateBlock(DownloadStateCompleted); return; &#125; // 暂停下载 if ([self.tasks valueForKey:XRFileName(url)]) &#123; [self handle:url]; return; &#125; // 创建缓存目录文件 [self createCacheDirectory]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc] init]]; // 创建流 NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:XRFileFullpath(url) append:YES]; // 创建URL请求 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:url]]; // 设置下载内容范围的请求头 NSString *range = [NSString stringWithFormat:@\"bytes=%zd-\", XRDownloadLength(url)]; [request setValue:range forHTTPHeaderField:@\"Range\"]; // 创建一个Data任务 NSURLSessionDataTask *task = [session dataTaskWithRequest:request]; NSUInteger taskIdentifier = arc4random() % ((arc4random() % 10000 + arc4random() % 10000)); [task setValue:@(taskIdentifier) forKeyPath:@\"taskIdentifier\"]; // 保存任务 [self.tasks setValue:task forKey:XRFileName(url)]; XRSessionModel *sessionModel = [[XRSessionModel alloc] init]; sessionModel.url = url; sessionModel.update = update; sessionModel.progressBlock = progressBlock; sessionModel.stateBlock = stateBlock; sessionModel.stream = stream; [self.sessionModels setValue:sessionModel forKey:@(task.taskIdentifier).stringValue]; [self start:url];&#125;/** * 判断该文件是否下载完成 */- (BOOL)isCompletion:(NSString *)url&#123; if ([self fileTotalLength:url] &amp;&amp; XRDownloadLength(url) == [self fileTotalLength:url]) &#123; return YES; &#125; return NO;&#125;// 若暂停则继续下载，若正在下载则暂停下载- (void)handle:(NSString *)url&#123; NSURLSessionDataTask *task = [self getTask:url]; if (task.state == NSURLSessionTaskStateRunning) &#123; [self pause:url]; &#125; else &#123; [self start:url]; &#125;&#125;/** * 根据url获得对应的下载任务 */- (NSURLSessionDataTask *)getTask:(NSString *)url&#123; return (NSURLSessionDataTask *)[self.tasks valueForKey:XRFileName(url)];&#125;/** * 开始下载 */- (void)start:(NSString *)url&#123; NSURLSessionDataTask *task = [self getTask:url]; [task resume]; [self getSessionModel:task.taskIdentifier].stateBlock(DownloadStateStart); // 删除暂停状态 NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:XRPausePath]) &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:XRPausePath]; [dict removeObjectForKey:XRFileName(url)]; [dict writeToFile:XRPausePath atomically:YES]; &#125;&#125;/** * 暂停下载 */- (void)pause:(NSString *)url&#123; NSURLSessionDataTask *task = [self getTask:url]; [task suspend]; [self getSessionModel:task.taskIdentifier].stateBlock(DownloadStateSuspended); // 存储暂停状态 NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:XRPausePath]; if (dict == nil) dict = [NSMutableDictionary dictionary]; dict[XRFileName(url)] = @\"pause\"; [dict writeToFile:XRPausePath atomically:YES];&#125;/** * 根据url获取对应的下载信息模型 */- (XRSessionModel *)getSessionModel:(NSUInteger)taskIdentifier&#123; return (XRSessionModel *)[self.sessionModels valueForKey:@(taskIdentifier).stringValue];&#125;/** * 查询该资源的下载进度值 */- (CGFloat)progress:(NSString *)url&#123; return [self fileTotalLength:url] == 0 ? 0.0 : 1.0 * XRDownloadLength(url) / [self fileTotalLength:url];&#125;/** * 获取该资源总大小 */- (NSInteger)fileTotalLength:(NSString *)url&#123; return [[NSDictionary dictionaryWithContentsOfFile:XRTotalLengthFullpath][XRFileName(url)] integerValue];&#125;/** * 根据下载地址查找该资源路径 **/-(NSString *)getPathWithUrl:(NSString *)url&#123; NSString *str = XRFileFullpath(url); return str;&#125; 整个网络数据的请求和处理都依赖于NSURLSessionDataDelegate的代理方法。请求得到反馈时根据response拿到游戏资源的完整大小，并将其写入到game.plist文件中。当客户端开始接收服务器返回的数据时，打开NSOutputStream并开始将接收到的数据写入到指定路径下的文件中，并返回下载进度。接收数据完成后对数据包进行解压缩，解压成功则将写入流关闭并将下载任务从tasks中移除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma mark - NSURLSessionDataDelegate/** * 接收到响应 */- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSHTTPURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler&#123; XRSessionModel *sessionModel = [self getSessionModel:dataTask.taskIdentifier]; // 打开流 [sessionModel.stream open]; // 获得服务器这次请求 返回数据的总长度 NSInteger totalLength = [response.allHeaderFields[@\"Content-Length\"] integerValue] + XRDownloadLength(sessionModel.url); sessionModel.totalLength = totalLength; // 存储总长度 NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:XRTotalLengthFullpath]; if (dict == nil) dict = [NSMutableDictionary dictionary]; dict[XRFileName(sessionModel.url)] = @(totalLength); [dict writeToFile:XRTotalLengthFullpath atomically:YES]; // 接收这个请求，允许接收服务器的数据 completionHandler(NSURLSessionResponseAllow);&#125;/** * 接收到服务器返回的数据 */- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; XRSessionModel *sessionModel = [self getSessionModel:dataTask.taskIdentifier]; // 写入数据 [sessionModel.stream write:data.bytes maxLength:data.length]; // 下载进度 NSUInteger receivedSize = XRDownloadLength(sessionModel.url); NSUInteger expectedSize = sessionModel.totalLength; CGFloat progress = 1.0 * receivedSize / expectedSize; sessionModel.progressBlock(receivedSize, expectedSize, progress);&#125;/** * 请求完毕（成功|失败） */- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; XRSessionModel *sessionModel = [self getSessionModel:task.taskIdentifier]; if (!sessionModel) return; if ([self isCompletion:sessionModel.url]) &#123; // 下载完成，解压缩 [SSZipArchive unzipFileAtPath:XRFileFullpath(sessionModel.url) toDestination:XRWebDirectory]; sessionModel.stateBlock(DownloadStateCompleted); &#125; else if (error)&#123; // 下载失败 sessionModel.stateBlock(DownloadStateFailed); &#125; // 关闭流 [sessionModel.stream close]; sessionModel.stream = nil; // 清除任务 [self.tasks removeObjectForKey:XRFileName(sessionModel.url)]; [self.sessionModels removeObjectForKey:@(task.taskIdentifier).stringValue];&#125; 结语以上是对下载过程实现的大概描述，其中的实现细节还有很多值得推敲和优化的地方，接下来会发时间去优化并会将优化后的效果总结出来。如果其中有错误的地方欢迎指正。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"庖丁解牛KVO（二）——KVO实现原理","slug":"庖丁解牛KVO（二）——KVO实现原理","date":"2016-04-23T08:38:13.000Z","updated":"2016-10-10T11:58:32.000Z","comments":true,"path":"2016/04/23/庖丁解牛KVO（二）——KVO实现原理/","link":"","permalink":"http://zakariyyasv.pub/2016/04/23/庖丁解牛KVO（二）——KVO实现原理/","excerpt":"概览在上一篇文章中，我们已经了解了KVO的使用场景以及使用方法。作为Objective-c中异常强大和重要的特性，我们有必要去了解和探索KVO底层的实现机制。 KVO的实现机制到底是怎么样的呢？依据苹果官方文档的介绍： Automatic key-value observing is implemented using a technique called isa-swizzling. The is a pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.","text":"概览在上一篇文章中，我们已经了解了KVO的使用场景以及使用方法。作为Objective-c中异常强大和重要的特性，我们有必要去了解和探索KVO底层的实现机制。 KVO的实现机制到底是怎么样的呢？依据苹果官方文档的介绍： Automatic key-value observing is implemented using a technique called isa-swizzling. The is a pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 总结一下，这段话的关键字是isa-swizzling，当某个对象的属性被另一个对象观察时，被观察者的isa指针会被修改，指向一个中间类而不是原来的类。至于这个中间类到底是怎么样的，文档没有描述，可见苹果并不想暴露KVO的实现细节。所以，要想了解KVO底层的实现原理，还需要自己动手去研究。 实现原理剖析KVO机制在NSObject类中已经实现，故而所有继承NSObject类的子类均可以直接使用KVO。既然是追本溯源，那就要从剖析NSObject类开始。查阅runtime文件时，发现了以下代码：123456789101112131415161718192021222324252627282930313233@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endifstruct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 从这段代码中我们可以看出，NSObject只有一个Class类型的isa变量，Class则是objc_class类型的指针，objc_class则是包含isa变量的结构体（实际上NSObject的底层实现比这要复杂得多）。根据文档的注释，Class代表的是一个Objective-c类，而objc_object则代表的是一个类的实例。由此也可推导出isa变量实际上指向的是对象本身所代表的类。 根据前面文档所说，KVO实现依赖的技术叫做isa-swizzling。也就是说KVO在isa上作了文章，那要探究KVO的底层实现，就要去追踪isa，看看在KVO的过程中isa指向的类到底发生了什么。由于isa是类的私有变量，无法直接访问。在查阅了runtime中关于NSOjbect.mm实现文件中找到了方法去间接访问isa变量。1234567891011121314- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; return _object_getClass(obj);&#125;static inline Class _object_getClass(id obj)&#123; if (obj) return obj-&gt;isa; else return Nil;&#125; 从这段代码中可以看出，我们可以调用object_getClass方法访问对象的isa指针，同时，这段代码也说明了isa本质上就是代表一个对象的类型。 以下是为追踪KVO实现过程编写的测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface Cat : NSObject@property (nonatomic,copy) NSString *name;@property (nonatomic,copy) NSString *age;@property (nonatomic,copy) NSString *weight;@end@implementation Cat@endstatic NSArray *classMethodNameList(Class c)&#123; NSMutableArray *array = [NSMutableArray array]; unsigned int methodCount = 0; Method *methodList = class_copyMethodList(c, &amp;methodCount); unsigned int i; for(i = 0; i &lt; methodCount; i++) [array addObject: NSStringFromSelector(method_getName(methodList[i]))]; free(methodList); return array;&#125;static void customDescription(NSString *name,id obj)&#123; NSString *str = [NSString stringWithFormat: @\"%@: %@\\n\\tNSObject class %s\\n\\tlibobjc class %s\\n\\timplements methods &lt;%@&gt;\", name, obj, class_getName([obj class]), class_getName(object_getClass(obj)), [classMethodNameList(object_getClass(obj)) componentsJoinedByString:@\", \"]]; printf(\"%s\\n\", [str UTF8String]);&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Cat *A = [[Cat alloc] init]; Cat *B = [[Cat alloc] init]; Cat *C = [[Cat alloc] init]; Cat *D = [[Cat alloc] init]; [A addObserver:A forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:NULL]; [B addObserver:A forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:NULL]; [C addObserver:B forKeyPath:@\"age\" options:NSKeyValueObservingOptionNew context:NULL]; customDescription(@\"A\", A); customDescription(@\"B\", B); customDescription(@\"C\", C); customDescription(@\"D\", D); &#125; return 0;&#125; 简单解释下这段代码，classMethodNameList方法返回的是在运行时类的方法列表，不过，方法列表中并不包含父类的方法。customDescription方法打印的是对象名，对象对应的类，在运行时对象指向的类，以及运行时对象指向的类所实现的所有方法。实例化四个Cat对象A、B、C、D，A、B、C分别以不同的方式去观察，D则没有观察者。 以下是运行的输出结果：12345678910111213141516A: &lt;Cat: 0x100500aa0&gt; NSObject class: Cat libobjc class: NSKVONotifying_Cat implements methods: &lt;setAge:, setName:, class, dealloc, _isKVOA&gt;B: &lt;Cat: 0x1005035f0&gt; NSObject class: Cat libobjc class: NSKVONotifying_Cat implements methods: &lt;setAge:, setName:, class, dealloc, _isKVOA&gt;C: &lt;Cat: 0x100503610&gt; NSObject class: Cat libobjc class: NSKVONotifying_Cat implements methods: &lt;setAge:, setName:, class, dealloc, _isKVOA&gt;D: &lt;Cat: 0x1005037a0&gt; NSObject class: Cat libobjc class: Cat implements methods: &lt;setWeight:, name, setName:, weight, .cxx_destruct, age, setAge:&gt; A、B被观察的属性都是”name”，而C被观察的属性是”age”。A、B、C在runtime下所指向的类均是NSKVONotifying_Cat，这个类应该就是isa-swizzling中的中间类。而并没有被观察的D在runtime下锁指向的仍然是Cat类。这说明只有在对象的属性被观察的时候才会动态创建中间类，对象的isa指针也就不再指向原来的类，而是指向这个中间类。被观察的属性中没有包括weight，而动态生成的中间类所实现的方法列表中也没有重写setWeight:方法，说明方法是按需动态重写的。此外，仔细观察，我们发现虽然A、B只有name属性被观察了，但是动态生成的中间类仍然实现了setAge:方法，说明A、B、C在运行时实际上指向的是同一个中间类。另外，方法列表中有一个叫做_isKVOA的方法引起我的注意，这应该是一个私有方法，无从得知关于这个方法更多的实现细节，暂时悬在这里，待日后有机会能解开这个疑惑。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"庖丁解牛KVO（一）——KVO概览和使用","slug":"庖丁解牛KVO（一）——KVO概览和使用","date":"2016-04-13T10:21:33.000Z","updated":"2016-10-10T11:58:25.000Z","comments":true,"path":"2016/04/13/庖丁解牛KVO（一）——KVO概览和使用/","link":"","permalink":"http://zakariyyasv.pub/2016/04/13/庖丁解牛KVO（一）——KVO概览和使用/","excerpt":"KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（-bind:toObject:withKeyPath:options:）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。 KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。 在通知机制中，KVO与NSNotification提供的通知机制类似，但是也存在很鲜明的区别。NSNotification是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。","text":"KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（-bind:toObject:withKeyPath:options:）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。 KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。 在通知机制中，KVO与NSNotification提供的通知机制类似，但是也存在很鲜明的区别。NSNotification是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。由于基类NSObject提供了对于KVO的基本实现，因而所有的cocoa对象本质上都能够使用KVO。为了能够接收到KVO的通知，你必须要做以下几件事： 你必须确保被观察类的属性符合KVO规则（KVO Compliance）。KVO规定被观察对象的类必须符合KVC规则（KVC Compliance）同时允许属性的自动观察者通知或者手动实现属性的KVO。 给值会发生改变的对象（即被观察者）添加观察者。你可以通过调用addObserver:forKeyPath:options:context:方法做到。 在观察者对象中，实现方法observeValueForKeyPath:ofObject:change:context:。该方法在被观察对象的属性值发生变化时会被调用。 第二点和第三点很好理解，第一点则需要多说一点。并不是说所有类的属性都满足KVO规则，他需要满足以下几个条件： 类的属性必须满足KVC规则。KVO与KVC支持的数据类型相同，包括OC对象、标量和结构体。 类要发送属性变化的KVO通知。 依赖的键需要被正确的注册。 关于第一点，何为满足KVC规则？对于一个满足KVC规则的指定属性，它必须实现valueForKey:和setValue:forKey:来作用于指定属性。更详细地： 对于対一关系的属性，它的类必须做到： 实现方法名为-&lt;key&gt;，-is&lt;key&gt;的方法，或者创建对象名为或者_的实例对象。 如果属性是可变的，那么它还需要实现-set&lt;key&gt;:方法。 -set&lt;Key&gt;:的方法实现不应该包含验证操作。 若key需要进行验证它的类还需要实现-validate&lt;Key&gt;:error:方法。 对于有索引的对多关系的属性，它的类必须要做到： 实现方法名为-&lt;key&gt;的方法并返回数组。 或者有变量名为或_的实例变量。 或者实现方法-countOf&lt;key&gt;和-objectIn&lt;key&gt;``-&lt;key&gt;AtIndexes:两个方法中的一个。 另外，你可以实现-get&lt;key&gt;:range:来优化性能。 对于无序的对多关系的属性，它的类需要做到： 实现方法名为-&lt;key&gt;的方法并并返回一个集合。 或者创建变量名为或_的实例变量。 或者实现方法-countOf&lt;key&gt;、-enumeratorOf&lt;key&gt;和-memberOf&lt;key&gt;:。若该属性还是可变的，它的类还需做到： 实现-add&lt;key&gt;Object:和-add&lt;key&gt;:中的一个或两个。 实现-remove&lt;key&gt;Object:和-remove&lt;key&gt;:中的一个或两个。 另外，你可以实现-intersect&lt;key&gt;:和-set&lt;key&gt;:来优化性能。 关于第二点，如何确保通知被发送？对于所有满足KVC规则的类的属性已经自动支持KVO。因此，只要你遵守标准Cocoa编码和命名规范，你可以使用自动变化通知（Automatic Change Notification）————你不需要编写额外的代码。以下代码示例会触发KVO变化通知被发送： 12345678910111213// Call the accessor method.[account setName:@\"Savings\"]; // Use setValue:forKey:.[account setValue:@\"Savings\" forKey:@\"name\"]; // Use a key path, where 'account' is a kvc-compliant property of 'document'.[document setValue:@\"Savings\" forKeyPath:@\"account.name\"]; // Use mutableArrayValueForKey: to retrieve a relationship proxy object.Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;;NSMutableArray *transactions = [account mutableArrayValueForKey:@\"transactions\"];[transactions addObject:newTransaction]; 在某些情况下，你想控制通知的进程，比如想减少不必要的原因而触发通知的次数，或者想把多个变化整合进一个通知当中。这时候自动变化通知就无法满足需求，而手动变化通知（Manual Change Notification）则派上用场了。在这种情况下，你需要重写NSObject的automaticallyNotifiesObserversForKey:方法。若你想将某个属性从自动变化通知中移除，则在automaticallyNotifiesObserversForKey:方法中返回NO。 12345678910+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey &#123; BOOL automatic = NO; if ([theKey isEqualToString:@\"balance\"]) &#123; automatic = NO; &#125; else &#123; automatic = [super automaticallyNotifiesObserversForKey:theKey]; &#125; return automatic;&#125; 为了实现手动变化通知，你需要在改变变量值�前触发willChangeValueForKey:方法并在改变变量值后触发didChangeValueForKey:方法。12345- (void)setBalance:(double)theBalance &#123; [self willChangeValueForKey:@\"balance\"]; _balance = theBalance; [self didChangeValueForKey:@\"balance\"];&#125; 你可以通过检验值是否发生改变来减少不必要的通知发送。1234567- (void)setBalance:(double)theBalance &#123; if (theBalance != _balance) &#123; [self willChangeValueForKey:@\"balance\"]; _balance = theBalance; [self didChangeValueForKey:@\"balance\"]; &#125;&#125; 若一个操作引起多个属性值发生变化，你必须像下面这样嵌套变化的通知：12345678- (void)setBalance:(double)theBalance &#123; [self willChangeValueForKey:@&quot;balance&quot;]; [self willChangeValueForKey:@&quot;itemChanged&quot;]; _balance = theBalance; _itemChanged = _itemChanged+1; [self didChangeValueForKey:@&quot;itemChanged&quot;]; [self didChangeValueForKey:@&quot;balance&quot;];&#125; 在有序的对多关系的属性中，你必须不仅指明改变的属性，而且还需指明改变的类型和涉及到的对象的索引值。改变的类型是NSKeyValueChange枚举，包含NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, NSKeyValueChangeReplacement。受影响的对象的索引值传入的是NSIndexSet对象。123456789- (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes &#123; [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@\"transactions\"]; // Remove the transaction objects at the specified indexes. [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@\"transactions\"];&#125; 关于第三点，在很多情况下某个属性依赖于另一个对象的一个或多个属性。如果一个属性值发生改变，那么受影响的属性其值也会发生改变。那么如何确保存在依赖关系的属性的KVO通知能正确发送？ 在対一关系中，为了触发自动通知你需要重写keyPathsForValuesAffectingValueForKey:方法。比如，一个人的名字包含姓和名。他的名字的全称可以用以下方法来写：123- (NSString *)fullName &#123; return [NSString stringWithFormat:@\"%@ %@\",firstName, lastName];&#125; 当firstName或者lastName属性值发生改变时，观察fullName的对象必须接收到通知。其中一个解决方法是重写keyPathsForValuesAffectingValueForKey:方法来指明fullName属性依赖于lastName和firstName属性。12345678910+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key &#123; NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@\"fullName\"]) &#123; NSArray *affectingKeys = @[@\"lastName\", @\"firstName\"]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; &#125; return keyPaths;&#125; 如上面代码示例中，你的重写方法实现中必须要触发super方法调用，并且返回的集合中要包含父类的keys。你还可以通过实现命名规则遵循keyPathsForValuesAffecting&lt;Key&gt;（Key为属性名并且首字母大写）的类方法来得到同样的结果。使用该方案对上面代码进行改写如下：123+ (NSSet *)keyPathsForValuesAffectingFullName &#123; return [NSSet setWithObjects:@\"lastName\", @\"firstName\", nil];&#125; 当你使用分类给现有的类添加属性时，不能重写keyPathsForValuesAffectingValueForKey:方法，因为在分类中不支持重写该方法。在这种情况下，只能通过实现keyPathsForValuesAffecting&lt;Key&gt;类方法来达到效果。 在对多关系中，keyPathsForValuesAffectingValueForKey:方法不支持。比如，你有一个Deprtment对象与employee对象的对多关系，并且employee有salary属性。在Department对象中有一个totalSalary属性依赖于所有的employee的salary的关系。这里有两种解决方案：1.你可以使用KVO注册父类（Department）为所有子类（employee）的salary属性的观察者。你必须在添加和移除子类对象的过程中添加和移除观察者。以下为示例代码：12345678910111213141516171819202122232425- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if (context == totalSalaryContext) &#123; [self updateTotalSalary]; &#125; else // deal with other observations and/or invoke super...&#125; - (void)updateTotalSalary &#123; [self setTotalSalary:[self valueForKeyPath:@\"employees.@sum.salary\"]];&#125; - (void)setTotalSalary:(NSNumber *)newTotalSalary &#123; if (_totalSalary != newTotalSalary) &#123; [self willChangeValueForKey:@\"totalSalary\"]; _totalSalary = newTotalSalary; [self didChangeValueForKey:@\"totalSalary\"]; &#125;&#125; - (NSNumber *)totalSalary &#123; return _totalSalary;&#125; 2.如果你使用Core Data，你可以注册父类为它管理对象上下文的观察者。当子类相关属性值发生改变其父类就会得到相应的通知，类似于KVO。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"Mac workflow小记","slug":"Mac workflow小记","date":"2016-03-12T12:11:39.000Z","updated":"2016-08-31T12:36:47.000Z","comments":true,"path":"2016/03/12/Mac workflow小记/","link":"","permalink":"http://zakariyyasv.pub/2016/03/12/Mac workflow小记/","excerpt":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。","text":"在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。 Homebrew Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。注：homebrew的安装程序需要用到Xcode的command line tools。 1234567brew install mysql // 安装MySQLbrew uninstall mysql // 卸载MySQLbrew search mysql // 搜索MySQLbrew upgrade mysql // 更新MySQLbrew list // 显示已经安装的软件列表brew update // 更新homebrewbrew deps mysql // 显示MySQL的包依赖 iTerm2 iTerm2是mac下的替代Terminal的终端工具，可以说iTerm2是Mac下最好的终端工具。它有一些特色功能如下： 标签变色iTerm2 的标签的颜色会变化，以指示该 tab 当前的状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。 智能选中在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。 巧用 Command 键按住⌘键:可以拖拽选中的字符串；点击 url：调用默认浏览器访问该网址；点击文件：调用默认程序打开文件；如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；点击文件夹：在 finder 中打开该文件夹；同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。 iTerm2的可定制化也是一大特色，详细的定制化步骤可以参见我的另一篇博客。 Alfred3 我对Alfred3的评价是Mac下最逆天的工具。如果你是个键盘党，Alfred绝对可以让你基本摆脱鼠标。丰富的workflow可以让你的操作变得得心应手而且高效。你可以去alfredworkflow上下载安装适合你的workflow。当然，你要是想自己制作workflow也很容易，简单易上手，这也是Alfred workflow资源丰富的原因所在。如果兜里不差钱还是建议去买个终身会员，绝对值得。如果囊中羞涩，这里提供一个破解版本供大家尝鲜。（下载链接） Dash Dash是Mac下的API文档查阅器，其储存了超过150种API离线文档。这可以说是程序员必备利器，不管是从操作体验以及资源的丰富程度都是Mac平台下最好用的。同时，配合Alfred使用，效率会更高。Dash提供免费版也带有付费插件，如果不差钱，支持一下也是无可厚非的。 CheatSheet CheatSheet是一款Mac上非常实用的快捷键快速提醒工具，只需要按住Command键，就会弹出当前应用所有的快捷键列表。所以，即使你记不住一些快捷键也没有关系，有CheatSheet就够了。 Sequel Pro Sequel Pro（原CocoaMySQL）是众多Mac程序员使用的MySQL管理软件，提供了比phpmyadmin更强大的管理能力，帮助用户轻松编辑数据库，表（字段和索引）和列，执行个性化查找以及导出/入数据，快速查询数据。 Sequel Pro它最大的优点是简单、易用。因为这款工具是苹果公司为了吸引Web开发者进入Mac平台而投资的项目。所以它处处体现了苹果公司简洁的设计哲学。说它是全世界最好用的MySQL数据库管理工具是一点也不夸张。 功能特点： 支持多达30种编码方式 快速导出/导入、备份/还原数据库的SQL/CSV文件 最高版本支持MySQL 5.6 内置强大的数据库查询编辑器，有自定义查询中的自动语句高亮功能，可自定义字体，自定义查询占位符. 允许你编辑数据库，表格（字段和索引）和列，执行个性化查找和导入导出数据 自动补全关键词，表名，域名 自动段落化查询命令 IP直连数据库 表触发机制 服务器运行监控Query Favourites for SQL reuse 包括检索功能在内的全表管理设计 快速在Mac上架设本地MySQL数据库 在MAMP/XAMP架构上连接数据库 SSH连接模式 Sublime Text 3 Sublime Text可以说是一款优雅高效地编辑器，越来越受到开发人员的欢迎。这款编辑器区别于其他编辑器的特性主要有以下几点： 随时保留文件的修改 多重选择，同时修改 智能选择 智能感知，一键注释 Goto Anything，智能搜索 自动完成，无处不在 HTML标签输入 标签输入，再简化 简单全面的插件体系 Lantern Lantern是一款免费开源的科学上网的软件，安装和使用极其简单。Lantern让用户能流畅地访问被封锁的互联网站点。Lantern自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern通过自有的服务器或者未封锁地区的用户运行的Lantern来提供访问。如果网站没有被封锁，Lantern选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。 iStat Menus iStat Menus 5 是一款由软件开发商 Bjango 制作的 System Monitor（工具，也是笔者电脑里的必装应用之一，它能让用户最快速、最直观地了解到几乎各硬件所有的运行状态，其中包括：CPU 中央处理器、GPU 图形处理器、Memory 虚拟内存、Network 网络、Battery 电池、Disks 硬盘等。 Cmd Markdown编辑器 Cmd Markdown是一款markdown编辑器，相比于同类markdown编辑器，Cmd Markdown编辑器的优势在于对中文支持比较好，实时的云端文稿，实时同步预览等等。 目前，也就只有这些了，后续如果发现好用的软件会继续更新的。","categories":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://zakariyyasv.pub/categories/Mac相关/"}],"tags":[],"keywords":[{"name":"Mac相关","slug":"Mac相关","permalink":"http://zakariyyasv.pub/categories/Mac相关/"}]},{"title":"深入理解NSMapTable、NSHashTable、NSPointerArray","slug":"深入理解NSMapTable、NSHashTable、NSPointerArray","date":"2016-03-10T02:19:45.000Z","updated":"2016-09-19T14:33:47.000Z","comments":true,"path":"2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","link":"","permalink":"http://zakariyyasv.pub/2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/","excerpt":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125;","text":"最近在学习YYCache中的YYDiskCache时，注意到了这段代码： 12345678910111213141516171819202122232425262728/// weak reference for all instancesstatic NSMapTable *_globalInstances;static dispatch_semaphore_t _globalInstancesLock;static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; YYDiskCache采用NSMapTable作为全局变量而并没有采用NSDictionary来存储cache变量，这样做的好处是避免_globalInstances与cache发生循环引用，造成内存无法释放。回顾之前自己的编码经历，基本没考虑过NSDictionary与其元素可能发生的循环引用问题，不得不说自己在这方面还是有欠缺。因而写下这篇blog总结这部分的内容。 我在总结的过程中发现了NSMapTable-NSDictionary、NSHashTable-NSSet、NSPointerArray-NSArray三组存在相似的关系，于是我就想干脆将这几个类总结在一起，便于理解。 NSMapTable - NSDictionary以下是苹果文档关于NSMapTable的描述： The NSMapTable class is a mutable collection modeled after NSDictionary, with the following differences: The major option is to have keys and/or values held “weakly” in a manner that entries are removed when one of the objects is reclaimed. Its keys or values may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its contents are not constrained to being objects). 总结一下，NSMapTable仿效的是NSDictionary，但它是可变的集合。它与NSDictionary有几点区别： 1.NSMapTable与NSDictionary最重要的区别在于前者可以将keys和values以弱引用的方式关联，当其中任一对象被回收了，其所有的内容都会被移除。我们可以通过mapTableWithKeyOptions:valueOptions:分别控制键和值的对象获取/保留行为。NSDictionary则会对keys和values执行retain操作，只有等到NSDictionary被release才会release它所持有的keys和values。 NSMapTable可以包含任意的指针并且指针的内容不限定必须是对象，然后用指针去做相等或者hasing检查，而NSDictionary的key必须是遵循NSCopying协议的对象。不仅如此，如果NSDictionary要使用KVC那么key必须是字符串。 当NSMapTable指定为NSMapTableCopyIn，它会通过NSCopying协议将添加进来的数据复制一份副本，NSDictionary则需要调用copy方法来复制数据。 NSHashTable - NSSet以下是苹果文档关于NSHashTable的描述： NSHashTable is modeled after NSSet but provides different options, in particular to support weak relationships. It can hold weak references to its members. Its members may be copied on input or may use pointer identity for equality and hashing. It can contain arbitrary pointers (its members are not constrained to being objects). Because of its options, NSHashTable is not a set because it can behave differently (for example, if pointer equality is specified two isEqual: strings will both be entered). 总结一下，NSHashTable效仿的是NSSet但提供更多不同的选项，尤其是支持weak关联。它支持对所有成员的弱引用，而NSSet对所有成员均是强引用。其他的不同点与前面NSMapTable与NSDictionary类似，可以参考对比，就不再码废话了。 NSPointerArray - NSArray以下是苹果文档关于NSPointerArray的描述： The NSPointerArray class represents a mutable collection modeled after NSArray, but can also hold nil values. nil values may be inserted or removed and contribute to the object’s count. An NSPointerArray object can also increase and decrease its count directly. A pointer array can be initialized to maintain strong or weak references to objects, or according to any of the memory or personality options defined by NSPointerFunctionsOptions. The NSCopying and NSCoding protocols are applicable only when a pointer array is initialized to maintain strong or weak references to objects. When enumerating a pointer array with NSFastEnumeration using for…in, the loop will yield any nil values present in the array. See Fast Enumeration Makes It Easy to Enumerate a Collection in Programming with Objective-C for more information. 总结一下，NSPointerArray效仿的是NSArray，但可以存储值为nil的元素。nil可以被插入和移除并且计入对象的数目中。而NSArray不可以存储nil，通常它会将nil看做数组的终止符，并且不会计入到对象的数目当中。NSPointerArray可以直接增加或减少元素的数量，与NSMutableArray类似。NSPointerArray最重要的特性与前面两组相同，均是可以对存储的对象采用弱引用。只有当NSPointerArray存储的是对象时NSCopying、NSCoding协议才会适用。还有一点要注意的，在快速遍历的for…in方法中，如果NSPointerArray存在nil则循环遍历会终止。 结语依据这三组类的不同也就归纳出它们各自的应用场景。若你的使用场景中可能会产生如实例代码中的循环引用问题，那就使用前者，若你的使用场景中存储的对象不遵循NSCopying协议或者就不是对象，而是指针之类，那就使用前者。其他大多数情况下还是使用后者。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"YYCache源码学习","slug":"YYCache源码学习","date":"2016-03-06T06:17:28.000Z","updated":"2016-09-19T14:33:19.000Z","comments":true,"path":"2016/03/06/YYCache源码学习/","link":"","permalink":"http://zakariyyasv.pub/2016/03/06/YYCache源码学习/","excerpt":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage","text":"这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看YYCache 设计思路。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。 代码结构YYCache文件数并不多，主要包含四个文件： YYCache YYDiskCache YYMemoryCache YYKVStorage 他们之间的关系可以用一张图来描述： YYCache是整个缓存框架的核心类，它是由YYDiskCache和YYMemeoryCache组成，而YYDiskCache需要借助YYKVStorage来实现对元素的读写。以下就依次对每个类进行详细的剖析，我觉得由下向上的去看代码理解起来会更方便，于是剖析的顺序依次是YYKVStorage、YYDiskCache、YYMemeoryCache、YYCache。 YYKVStorageYYKVStorage文件中包含两个类YYKVStorageItem和YYKVStorage，前者的作用是为后者提供存储键值对和元数据服务的。前者将每一个储存的数据包装成一个元素，是静态的，后者则是对前者的元素进行读写操作，是动态的。做个比喻，YYKVStorageItem就好比是仓库里的货物，而YYKVStorage则是仓库管理员。不过，该类并非是线程安全的，所以，需要确保该类同一时间只能由一个YYKVStorage对象去访问某个YYKVStorageItem元素。YYKVStorageItem的结构很简单：123456789@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; ///&lt; key@property (nonatomic, strong) NSData *value; ///&lt; value@property (nullable, nonatomic, strong) NSString *filename; ///&lt; filename (nil if inline)@property (nonatomic) int size; ///&lt; value's size in bytes@property (nonatomic) int modTime; ///&lt; modification unix timestamp@property (nonatomic) int accessTime; ///&lt; last access unix timestamp@property (nullable, nonatomic, strong) NSData *extendedData; ///&lt; extended data (nil if no extended data)@end key：唯一标示元素的标识符value：存储的二进制数据filename：存储数据文件的文件名size：限定存储数据的大小modTime：最后一次修改数据的时间戳accessTime：最后一次读取数据的时间戳extendedData：附加的数据 YYKVStorage类的结构如下：123456@interface YYKVStorage : NSObject#pragma mark - Attribute@property (nonatomic, readonly) NSString *path; ///&lt; The path of this storage.@property (nonatomic, readonly) YYKVStorageType type; ///&lt; The type of this storage.@property (nonatomic) BOOL errorLogsEnabled; ///&lt; Set `YES` to enable error logs for debug.@end path：存储的路径type：存储类型errorLogsEnabled：debug下是否打印错误信息注：由于写入速度方面sqlite比文件速度快，但是读取速度方面的性能则取决于数据的大小。在作者的测试当中，当数据大于20KB时，读取速度上文件要快于sqlite。为了从性能方面考虑，加入了YYKVStorageType枚举类型。1234567891011typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; /// The `value` is stored as a file in file system. YYKVStorageTypeFile = 0, /// The `value` is stored in sqlite with blob type. YYKVStorageTypeSQLite = 1, /// The `value` is stored in file system or sqlite based on your choice. YYKVStorageTypeMixed = 2,&#125;; 如果是要存储大量的小数据，用YYKVStorageTypeSQLite性能会更好，如果是要存储大文件（比如图片缓存），使用YYKVStorageTypeFile来获取更好的性能，当然也可以使用YYKVStorageTypeMixed来自己决定每一个item的存储方式。 YYKVStorage实现文件依据它的思路分为两部分：sqlite和文件，它们的存储结构如下：12345678910111213141516171819202122232425/* File: /path/ /manifest.sqlite /manifest.sqlite-shm /manifest.sqlite-wal /data/ /e10adc3949ba59abbe56e057f20f883e /e10adc3949ba59abbe56e057f20f883e /trash/ /unused_file_or_folder SQL: create table if not exists manifest ( key text, filename text, size integer, inline_data blob, modification_time integer, last_access_time integer, extended_data blob, primary key(key) ); create index if not exists last_access_time_idx on manifest(last_access_time); */ File和SQL共用一张manifest表，如果是用SQL方式存储数据，则manifest表中的filename字段为空。这样设计的好处是，查询和修改item的信息只要查询一张表，效率上会高一点。 注：manifest.sqlite-shm和manifest.sqlite-wal是自sqlite 3.7后加入的，-wal文件的意思是write-ahead log，当一个数据库采用WAL模式，所有连接数据的操作都必须使用WAL，然后在数据库文件夹下生成后缀为-wal的文件来保存操作日志，-shm则说的是共享内存的问题，有兴趣可以看看下面这段。 2.2 Write-Ahead Log (WAL) Files A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in WAL mode. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters “-wal” appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened. 2.3 Shared-Memory Files When operating in WAL mode, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters “-shm” appended. Shared memory files only exist while running in WAL mode. The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the VFS is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if PRAGMA locking_mode is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created. The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered. sqlite3部分涉及到sqlite3预编译，它的预编译过程分为以下几步： 1.通过sqlite3_prepare_v2()创建sqlite3_stmt对象2.通过sqlite3bind*()绑定预编译字段的值3.通过sqlite2_step()执行SQL语句4.通过sqlite3_reset()重置预编译语句，重复步骤2多次5.通过sqlite3_finalize()销毁资源 sqlite3bind*有多种形式，分别对应不同的类型：123456789int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*)); int sqlite3_bind_double(sqlite3_stmt*, int, double);int sqlite3_bind_int(sqlite3_stmt*, int, int);int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);int sqlite3_bind_null(sqlite3_stmt*, int);int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n); YYDiskCacheYYDiskCache是线程安全的底层依赖于SQLite和File系统（类似于NSURLCache的磁盘缓存）来存储键值对的缓存YYDiskCache有以下的特性： 使用LRU算法来移除对象 能够被开销、数量和寿命来控制 当没有多余的磁盘空间时它能够自动回收对象 能够自动决定为每个对象决定存储类型（sqlite还是文件）以达到更好的性能 YYDiskCache结构如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface YYDiskCache : NSObject#pragma mark - Attribute/** The name of the cache. Default is nil. */@property (nullable, copy) NSString *name;/** The path of the cache (read-only). */@property (readonly) NSString *path;/** * 如果对象的数据大小超过这个值，那对象就会被当做文件存储起来，否则对象会以sqlite形式存储起来。 0意味着所有的对象会被以单独的文件存储起来，NSIntegerMax意味着所有的对象都会以sqlite形式存储。 */@property (readonly) NSUInteger inlineThreshold;/** * 如果这个block不为空，那么这个block会被用来取代NSKeyedArchiver序列化对象。 * 你可以使用这个block来支持那些没有实现'NSCoding'协议的对象 */@property (nullable, copy) NSData *(^customArchiveBlock)(id object);/** * 反序列化那些没有遵从'NSCoding'协议的对象 */@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data);/** * 当一个对象需要以文件的形式存储起来时，这个block会被触发来以指定的key生成文件名。 如果block为空，缓存就使用md5加密的key来作为文件名 */@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key);#pragma mark - Limit/** * 缓存所拥有的对象的最大限制 默认值为NSIntegMax，这不是一个严格的限制——如果缓存超过了这个限制，一些对象会在后台队列中被回收 */@property NSUInteger countLimit;/** * 在缓存开始回收对象前它所能持有的所有代价 如果缓存超过这个限制，一些对象会在后台队列中被回收。 */@property NSUInteger costLimit;/** * 缓存中对象的生命周期 如果对象超过这个限制，它会在后台队列中被回收 */@property NSTimeInterval ageLimit;/** * 缓存保有的最小的空余磁盘空间大小 如果空余磁盘空间大小小于这个值，缓存会移除部分对象来释放磁盘空间。 */@property NSUInteger freeDiskSpaceLimit;/** * 缓存有一个内部的timer来检查缓存是否达到它的限制，如果达到限制，便开始回收对象。 */@property NSTimeInterval autoTrimInterval;/** Set `YES` to enable error logs for debug. */@property BOOL errorLogsEnabled; YYDiskCache实现部分采用dispatch_semaphore来控制同步的，而并没有采用性能非常好的OSSpinLock自旋锁，研究了一下原因。 OSSpinLock：得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段dispatch_semaphore：GCD用于控制多线程并发的信号量，允许通过wait/signal的信号事件控制并发执行的最大线程数，当最大线程数降级为1的时候则可当作同步锁使用，注意该信号量并不支持递归；性能虽不如OSSpinLock但性能表现也是出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制。 对于耗时较大又易冲突的读操作，可以使用dispatch_semaphore，对于性能要求苛刻，可以考虑使用OSSpinLock，但需要确保加锁片段的耗时足够小。由于YYDiskCache锁占用时间会比较长，使用OSSpinLock会造成CPU内存暴涨，相比之下，使用dispatch_semaphore性能上则会好很多。 YYMemoryCacheYYMemoryCache是一个高效的存储键值对的内存缓存。与NSDictionary相比，keys只被持有而并不进行拷贝, 其API和性能与NSCache接近，所有的方法都是线程安全的。它的特性如下： YYMemoryCache与NSCache在以下几个方面不同： 它使用LRU算法移除对象；NSCache的回收方法的策略是不确定的。 它可以被开销，数量和生命周期来控制；NSCache的限制是不确定的。 当收到内存警告和进入后台时，它可以自动回收对象。 YYMemoryCache使用pthread_mutex来控制同步。读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响。由于内存缓存属于多线程高并发的使用场景，因此使用pthread_mutex会更稳定。 pthread_mutex：POSIX标准的unix多线程库(pthread)中使用的互斥量，支持递归，需要特别说明的是信号机制pthread_cond_wait()同步方式也是依赖于该互斥量，pthread_cond_wait()本身并不具备同步能力； YYMemoryCache的实现主要基于双链表，将链表的节点按照时间先后顺序逆序链接，若有节点被访问，则将该节点挪到表头，若插入新节点而缓存已满，则从链表表尾开始删除节点腾出存储空间。12345678910@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; id _value; NSUInteger _cost; NSTimeInterval _time;&#125;@end YYMemoryCache创建一个YYMemoryCacheGetReleaseQueue来releaseCFMutableDictionaryRef对象，避免阻塞主线程。123static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; YYMemoryCache的实现部分有段代码引起了我的注意：12345678910111213141516171819- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125; 这段代码实现的很巧妙，removeObjectForKey:方法执行完之后，node指向的对象的引用计数为0需要被释放，但是由于在dispatch_async方法中的block中调用了[node class];，使得blcok持有node，其指向的对象也就不会释放，而此时只有dispatch_async的block持有node，也就自然node释放的过程发生在dispatch_async指定的线程当中。 YYCacheYYCache是线程安全的键值对缓存。它使用YYMemoryCache将对象存储在速度快但空间小的内存缓存中，使用YYDiskCache将对象持久化存储在速度慢但空间大的磁盘缓存中。其类结构也很简单：12345678@interface YYCache : NSObject/** The name of the cache, readonly. */@property (copy, readonly) NSString *name;/** The underlying memory cache. see `YYMemoryCache` for more information.*/@property (strong, readonly) YYMemoryCache *memoryCache;/** The underlying disk cache. see `YYDiskCache` for more information.*/@property (strong, readonly) YYDiskCache *diskCache;@end YYCache没有太复杂的实现细节，主要就是调用YYMemoryCache和YYDiskCache相关方法存储、查找、修改、删除对象。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"runtime对containsString方法的小改进","slug":"runtime对containsString方法的小改进","date":"2016-02-20T15:23:28.000Z","updated":"2016-09-19T15:24:32.000Z","comments":true,"path":"2016/02/20/runtime对containsString方法的小改进/","link":"","permalink":"http://zakariyyasv.pub/2016/02/20/runtime对containsString方法的小改进/","excerpt":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。","text":"最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是NSstring的containsString:方法在从中作梗。看了一下文档发现原来containsString:是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替containsString:方法： 1BOOL isContained = [aString rangeOfString:bString].location != NSNotFound 不过，我觉得要在每一个需要调用containsString:方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加containsString:方法就可以一劳永逸了。实现的原理也很简单，在iOS 7下判断NSString中是否存在containsString:实例方法，若不存在，则动态添加该方法。这样就不用再需要调用containsString:实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。 12345678910111213// NSString+containsStringCategory.h#import &lt;Foundation/Foundation.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@interface NSString (containsStringCategory)- (BOOL)containsString:(NSString *)str;@end#endif 1234567891011121314151617181920212223242526272829// NSString+containsStringCategory.m#import \"NSString+containsStringCategory.h\"#import &lt;objc/runtime.h&gt;#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 80000@implementation NSString (containsStringCategory)+ (void)load&#123; @autoreleasepool &#123; [self zs_modernizeSelector:@selector(containsString:) withSelector:@selector(zs_containsString:)]; &#125;&#125;+ (void)zs_modernizeSelector:(SEL)originSelector withSelector:(SEL)newSelector&#123; if (![NSString instancesRespondToSelector:originSelector]) &#123; Method newMethod = class_getInstanceMethod(self, newSelector); class_addMethod(self, originSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod)); &#125;&#125;- (BOOL)zs_containsString:(NSString *)str&#123; return [self rangeOfString:str].location != NSNotFound;&#125;@end#endif","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"ApplePay线上支付教程","slug":"ApplePay线上支付教程","date":"2016-01-14T12:33:39.000Z","updated":"2016-09-19T14:30:54.000Z","comments":true,"path":"2016/01/14/ApplePay线上支付教程/","link":"","permalink":"http://zakariyyasv.pub/2016/01/14/ApplePay线上支付教程/","excerpt":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。","text":"第一部分 准备阶段1）硬件要求：iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。 2）系统要求：iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。 3）配置支付环境1.进入苹果开发者中心，注册App ID。App ID必须是explicit类型，否则无法使用ApplePay服务。 2.勾选Apple Pay并点击continue，然后点击“submit”提交。 3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。 4.创建MerchantID。 5.配置Apple Pay服务，勾选Merchant ID。 6.App ID的apple pay选项变成enable表示配置成功。 7.创建Xcode项目，填入刚注册的BundleID。 8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。 第二部分 代码实现项目地址：https://github.com/ZakariyyaSv/ApplePayDemo 一、判断支付环境1.导入Passkit框架，加载view。1#import &lt;PassKit/PassKit.h&gt; 2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。1234567891011121314151617181920// 1.判断当前设备是否支持ApplePayif ([PKPaymentAuthorizationViewController canMakePayments]) &#123; // 2.判断是否添加了银行卡 if ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123; // 3.1添加支付按钮，点击跳转去支付 PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack]; [buyBtn addTarget:self action:@selector(buyOnClick) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:buyBtn]; &#125; else &#123; // 3.2添加设置按钮，点击跳转去wallet绑定银行卡 PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline]; [setupBtn addTarget:self action:@selector(jumpToWallet) forControlEvents:UIControlEventTouchUpInside]; [self.payView addSubview:setupBtn]; &#125;&#125;else &#123; NSLog(@\"The device cannot support ApplePay!\");&#125; 运行效果如下图所示： 3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。1234- (void)jumpToWallet&#123; PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init]; [walletLibrary openPaymentSetup];&#125; 4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。12345678910111213141516171819202122232425- (void)buyOnClick&#123; NSLog(@\"start to pay!\"); // 创建支付请求，配置请求信息。 PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init]; // 国家代码 payRequest.countryCode = @\"CN\"; // 货币代码 payRequest.currencyCode = @\"CNY\"; // 商家ID payRequest.merchantIdentifier = @\"merchant.com.zakariyya.fabrunMerchant\"; // 商家的处理方式 payRequest.merchantCapabilities = PKMerchantCapability3DS; // 商家支持的网络 payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay]; // 配置支付订单的详情 PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:@\"单反相机\" amount:[NSDecimalNumber decimalNumberWithString:@\"5999.0\"] type:PKPaymentSummaryItemTypeFinal]; PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:@\"佳能\" amount:[NSDecimalNumber decimalNumberWithString:@\"5999.0\"] type:PKPaymentSummaryItemTypeFinal]; payRequest.paymentSummaryItems = @[cameraItem,totalItem]; // 跳转并验证支付权限 PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest]; authViewController.delegate = self; [self presentViewController:authViewController animated:YES completion:nil];&#125; 支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。其中，merchantCapabilities是一个枚举值：123456typedef NS_OPTIONS(NSUInteger, PKMerchantCapability) &#123; PKMerchantCapability3DS = 1UL &lt;&lt; 0, // Merchant supports 3DS PKMerchantCapabilityEMV = 1UL &lt;&lt; 1, // Merchant supports EMV PKMerchantCapabilityCredit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 2, // Merchant supports credit PKMerchantCapabilityDebit NS_ENUM_AVAILABLE_IOS(9_0) = 1UL &lt;&lt; 3 // Merchant supports debit&#125; NS_ENUM_AVAILABLE(NA, 8_0); 这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。 supportedNetworks是一个包含常量字符串的数组：1234567extern NSString * const PKPaymentNetworkAmex NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkChinaUnionPay NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkDiscover NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkInterac NS_AVAILABLE(NA, 9_2);extern NSString * const PKPaymentNetworkMasterCard NS_AVAILABLE(NA, 8_0);extern NSString * const PKPaymentNetworkPrivateLabel NS_AVAILABLE(NA, 9_0);extern NSString * const PKPaymentNetworkVisa NS_AVAILABLE(NA, 8_0); 国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。 5.监听用户授权状态1234567891011121314151617181920#pragma mark - PKPaymentAuthorizationViewControllerDelegate// 用户授权成功后调用此方法- (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus))completion&#123; // 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。 BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125; else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125;&#125;// 用户授权成功或者用户取消授权操作时调用该方法- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123; NSLog(@\"Authorization did finished!\"); [self dismissViewControllerAnimated:YES completion:nil];&#125; 附：","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"UIButton之titleLabel、imageView解析","slug":"UIButton之titleLabel、imageView解析","date":"2015-12-28T02:28:19.000Z","updated":"2016-10-23T06:02:36.000Z","comments":true,"path":"2015/12/28/UIButton之titleLabel、imageView解析/","link":"","permalink":"http://zakariyyasv.pub/2015/12/28/UIButton之titleLabel、imageView解析/","excerpt":"前言UIButton是我们开发过程中使用频率很高的控件类。在使用UIButton实现需求时，通常会碰到需要改变UIButton中image和title位置和大小的需求。如果对UIButton中的titleLabel和imageView理解不到位的话，只能是不停地修改参数，不停地调试，陷入恶性循环，既低效又很难正确地去实现。为了解决这个问题，我研究出了两套方案，分别是用imageEdgeInsets、titleEdgeInsets组合的方案以及imageRectContentRet、titleRectContentRect组合的方案。","text":"前言UIButton是我们开发过程中使用频率很高的控件类。在使用UIButton实现需求时，通常会碰到需要改变UIButton中image和title位置和大小的需求。如果对UIButton中的titleLabel和imageView理解不到位的话，只能是不停地修改参数，不停地调试，陷入恶性循环，既低效又很难正确地去实现。为了解决这个问题，我研究出了两套方案，分别是用imageEdgeInsets、titleEdgeInsets组合的方案以及imageRectContentRet、titleRectContentRect组合的方案。 titleEdgeInsets、imageEdgeInsets组合这个方案是使用的比较多的解决方案，它主要依赖的是两个方法： titleEdgeInsets imageEdgeInsets 这个方案比较麻烦的地方在于很多人对这两个方法的理解不到位，导致使用的时候设置和显示的效果不一致。UIButton继承自UIControl，它因此也继承了两个属性contentVerticalAlignment和contentHorizontalAlignment。这两个属性是用来排列内部元素的,默认值都是Center，先看下它们的定义：12345678910111213typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123; UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,&#125;;typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) &#123; UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,&#125;; 按照4*4的组合分为16种选择结果。为了在计算过程中更方便点，我通常选择UIControlContentVerticalAlignmentTop、UIControlContentHorizontalAlignmentLeft的组合，这样符合我们以左上角作为坐标原点布局的思维。这里要纠正几个误区：第一，edgeinsets只是相对于当前位置的偏移量，并不是指距离UIButton边界的距离；第二，在同时存在图片还有文字的时候，只有UIButton的contentRect的宽度大于image和title的宽度才能正确显示，否则，文字由于无法进行拉伸收缩的原因只能显示…或者图片被压缩；第三、imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。 采用left-top方案初始情况下，image和title的位置如下图所示： 在初始状态下，imageEdgeInsets和titleEdgeInsets均为0，因此在计算偏移量的时候，image的top、left、right、bottom以及title的top、bottom、right均能以button的边界作为参考，而title的left是以image的left为参考的。搞清楚了之后，来做一下image在上，title在下的button：123456789CGFloat imageTop = (button.height-image.height-title.height) / 2;CGFloat titleTop = imageTop+image.height;CGFloat imageLeft = (button.width-image.width) / 2;// 这里减了image.width，因为title的left是以image的left为参考CGFloat titleLeft = (button.width-title.widht) / 2 - image.width;button.imageEdgeInsets = UIEdgeInsetsMake(imageTop, imageLeft, 0, 0);button.titleEdgeInsets = UIEdgeInsetsMake(titleTop, titleLeft, 0, 0); 这里还牵扯到一个问题，有人可能会觉得既然有left和top，那就不需要right和bottom了，实际不然。这实际上是涉及到约束的优先级。其定义如下： top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; imageView不能被压缩 top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; titleLabel水平方向不能被压缩 titleLabel垂直方向不能被压缩 &gt; 不能超出button边界 若有人运用发现image超出button边界，只需要同时调整contentEdgeInsets即可。 imageRectForContentRect、titleRectForContentRect组合第一个方案理解之后确实可以解决问题，不过，我觉得有些麻烦，就想着能不能有更方便的方案。于是，我翻阅文档和资料后，找到了更简单的方案，也就是这第二个方案。 第二个方案涉及到两个方法： (CGRect)titleRectForContentRect:(CGRect)contentRect (CGRect)imageRectForContentRect:(CGRect)contentRect 根据文档的解释，这两个方法返回值是矩形区域，区域内则是用来绘制image和title，返回值的参照系都是UIButton。要想自定义image和title在UIButton的位置和大小，只需要继承UIButton，重写这两个方法即可。 相比第一个方案，第二个方案确实方便不少，但是又有一个问题。要是想改变一个UIButton都得继承UIButton重写方法显得太麻烦，实际上并没有达到简便的目的。于是，我想能不能用runtime运行时机制，给UIButton添加两个变量，直接设置就可以修改image和title在UIButton中的rect，这样会方便很多。 先贴上实现代码： 12345678910111213// UIButton+RectOfImageAndTitle.h#import &lt;UIKit/UIKit.h&gt;@interface UIButton (RectOfImageAndTitle)@property (nonatomic,assign) CGRect btn_contentRect;@property (nonatomic,assign) CGRect btn_imageRect;@property (nonatomic,assign) CGRect btn_titleRect;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// UIButton+RectOfImageAndTitle.m#import \"UIButton+RectOfImageAndTitle.h\"#import &lt;objc/runtime.h&gt;static const char *btn_contentKey = \"btn_contentKey\";static const char *btn_imageKey = \"btn_imageKey\";static const char *btn_titleKey = \"btn_titleKey\";@implementation UIButton (RectOfImageAndTitle)+ (void)load&#123; @autoreleasepool &#123; [self exchangeIMPWithOriginSelector:@selector(contentRectForBounds:) newSelector:@selector(zs_contentRectForBounds:)]; [self exchangeIMPWithOriginSelector:@selector(imageRectForContentRect:) newSelector:@selector(zs_imageRectForContentRect:)]; [self exchangeIMPWithOriginSelector:@selector(titleRectForContentRect:) newSelector:@selector(zs_titleRectForContentRect:)]; &#125;&#125;+ (void)exchangeIMPWithOriginSelector:(SEL)originSeletor newSelector:(SEL)newSelector&#123; if ([UIButton instancesRespondToSelector:originSeletor]) &#123; Method oriMethod = class_getInstanceMethod(self, originSeletor); Method newMethod = class_getInstanceMethod(self, newSelector); method_exchangeImplementations(oriMethod, newMethod); &#125;&#125;#pragma mark - getter &amp; setter- (void)setBtn_contentRect:(CGRect)btn_contentRect&#123; objc_setAssociatedObject(self, &amp;btn_contentKey, [NSValue valueWithCGRect:btn_contentRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_contentRect&#123; if (!objc_getAssociatedObject(self, &amp;btn_contentKey)) &#123; objc_setAssociatedObject(self, &amp;btn_contentKey, [NSValue valueWithCGRect:CGRectZero], OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return [objc_getAssociatedObject(self, &amp;btn_contentKey) CGRectValue];&#125;- (void)setBtn_imageRect:(CGRect)btn_imageRect&#123; objc_setAssociatedObject(self, &amp;btn_imageKey, [NSValue valueWithCGRect:btn_imageRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_imageRect&#123; if (!objc_getAssociatedObject(self, &amp;btn_imageKey)) &#123; objc_setAssociatedObject(self, &amp;btn_imageKey, [NSValue valueWithCGRect:CGRectZero], OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return [objc_getAssociatedObject(self, &amp;btn_imageKey) CGRectValue];&#125;- (void)setBtn_titleRect:(CGRect)btn_titleRect&#123; objc_setAssociatedObject(self, btn_titleKey, [NSValue valueWithCGRect:btn_titleRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (CGRect)btn_titleRect&#123; return objc_getAssociatedObject(self, btn_titleKey) == nil ? CGRectZero : [objc_getAssociatedObject(self, btn_titleKey) CGRectValue];&#125;#pragma mark - private method- (CGRect)zs_contentRectForBounds:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_contentRect, CGRectZero)) &#123; return [self zs_contentRectForBounds:self.bounds]; &#125; else &#123; return self.btn_contentRect; &#125;&#125;- (CGRect)zs_imageRectForContentRect:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_imageRect, CGRectZero)) &#123; return [self zs_imageRectForContentRect:self.bounds]; &#125; else &#123; return self.btn_imageRect; &#125;&#125;- (CGRect)zs_titleRectForContentRect:(CGRect)contentRect&#123; if (CGRectEqualToRect(self.btn_titleRect, CGRectZero)) &#123; return [self zs_titleRectForContentRect:self.bounds]; &#125; else &#123; return self.btn_titleRect; &#125;&#125;@end 简要说下实现的思路：由于在category中重写imageRectForContentRect、titleRectForContentRect会覆盖原来的方法实现，并且无法使用super关键字，因此重写方法行不通。转而我采用自己实现两个方法并分别与这两个方法的实现进行交换，这样就不会破坏原有方法的实现。此外，动态添加三个实例变量可以直接在实例对象中直接设置来调用imageRectForContentRect、titleRectForContentRect两个方法。 使用的时候导入头文件，再相应的设置一下实例变量就可以达到效果，有没有很方便。 TIPS在开发过程中，我们经常会用到UIViewConentMode属性，有些人往往对属性值的意义不太了解，这里贴出一张图让你对此一目了然。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"UICollectionView Layout学习笔记","slug":"UICollectionView Layout学习笔记","date":"2015-12-17T03:25:04.000Z","updated":"2016-09-21T12:12:07.000Z","comments":true,"path":"2015/12/17/UICollectionView Layout学习笔记/","link":"","permalink":"http://zakariyyasv.pub/2015/12/17/UICollectionView Layout学习笔记/","excerpt":"概览UITableView是UIKit视图类中极其重要的一个，我们与之打交道的频率也是极高的。在UIKit视图类中有一个类与UITableview共享一套API设计，但相比UITableview，该类的视图布局更加灵活复杂。这就是UICollectionView。本篇的着重点也放在UICollectionView灵活强大的视图布局上面。","text":"概览UITableView是UIKit视图类中极其重要的一个，我们与之打交道的频率也是极高的。在UIKit视图类中有一个类与UITableview共享一套API设计，但相比UITableview，该类的视图布局更加灵活复杂。这就是UICollectionView。本篇的着重点也放在UICollectionView灵活强大的视图布局上面。 UICollectionView结构UICollectionView的结构可以分为两部分来看： 从数据和驱动角度能看到两部分： dataSource：数据源，遵循UICollectionViewDataSource协议，负责向collectionView提供数据以及视图。同时，还负责处理cells、supplementary views的创建和配置工作。 delegate：代理，遵循UICollectionViewDelegate协议，负责管理item视图的选中高亮状态以及item的点击事件。 从视图角度能看到三部分： Cells：在collection view的可视范围内负责展示数据的内容 Supplementary views：也是负责展示数据，但与cells不同，它无法被用户选中，类似于UITableview的header和footer Decoration views：属于装饰性view，不与collectionView的数据产生联系，更像是另一类的Supplementary views。注：Supplementary views、Decoration views必须是UICollectionReusableView的子类。 这些组成结构与UITableview比较，并没有太大的区别，真正的区别在于UICollectionLayout，这不仅是本篇笔记的着重点，也是UICollectionView的精髓。 UICollectionViewLayoutUICollectionViewLayout是一个抽象类，因此我们必须要继承并实现相关方法才能使用它。Layout的工作是确定Cells、supplementary views、decoration views在collectionView的bounds中的位置并且当collectionView需要时传递相关信息。collectionView根据传递过来的相关layout信息对views进行相应和处理以便能让他们在屏幕上能够显示出来。 UICollectionViewFlowLayout是苹果提供的继承于UICollectionViewLayout的子类。当你对layout的需求不是很复杂的时候，UICollectionViewFlowLayout往往可以满足需求，并且实现也比较简单，这里就不再讨论，感兴趣的可以查阅相关文档UICollectionviewFlowLayout。 自定义继承UICollectionViewLayout的子类必须重写以下方法：1234567891011121314151617181920- (void)prepareLayout// collectionView会在第一次布局向layout对象发送第一条消息时调用一次该方法，或者在invalidaed方法调用后在访问布局信息之前会再次调用该方法，重写该方法做些初始化的工作以确保layout实例的正确，子类重写必须调用super方法。- (CGSize)collectionViewContentSize// 返回collectionView的内容的尺寸。collectionView对它的content并不知情，因此需要提供滚动区域大小才能正确滚动。滚动区域大小必须包含内容的总大小，包括supplementary views 和 decoration views。- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect // 返回rect中的所有的元素的布局属性，其是包含UICollectionViewLayoutAttributes的数组。该方法传递一个自身坐标系的矩形进来，这个矩形也就是collectionView的bounds。这个方法涉及到所有类型的视图，即包括cells、supplementary views和decoration views。- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath// 返回对应于indexPath的位置的cell的布局属性。有时候collectionView会为某个特殊的视图向layout对象请求布局属性。你可以通过调用 +[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]这个方法，然后根据 index path 修改属性。为了得到需要显示在这个 index path 内的数据，你可能需要访问 collection view 的数据源。到目前为止，至少确保设置了 frame 属性，除非你所有的 cell 都位于彼此上方。- (UICollectionViewLayoutAttributes *)layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath *)indexPath// （可选）返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载- (UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString)decorationViewKind atIndexPath:(NSIndexPath )indexPath// （可选）返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds// 当collectionView的bounds发生改变时，是否应该重新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。 这些方法提供了collectionView在屏幕上展示内容所需要的基本布局信息。当collectionView中的数据发生改变并且items需要执行增删操作，collectionView会要求layout对象去更新layout布局信息。任何item被添加、移除、移动都必须更新它的布局信息来对应它正确的位置信息。当item被移动时，collectionView调用上面的方法来重新获取item更新后的布局属性，而item被插入或删除时，collectionView会调用不同的方法，也就是你需要重写的方法：1234567891011- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath;- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForAppearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath;- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath *)itemIndexPath;- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingDecorationElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)decorationIndexPath;- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingSupplementaryElementOfKind:(NSString *)elementKind atIndexPath:(NSIndexPath *)elementIndexPath; 此外，你也可以重写prepareForCollectionViewUpdates:方法来处理任何与布局相关的预处理操作，重写finalizeCollectionViewUpdates方法来添加动画或者实现布局相关的任务。 UICollectionViewLayoutAttributes重写的方法中涉及到一个类UICollectionViewLayoutAttributes。该类负责管理collectionView中给定item的布局相关的属性。当collectionView需要时，便会要求layout对象创建该类的实例对象。1234567891011121314151617181920@interface UICollectionViewLayoutAttributes : NSObject &lt;NSCopying, UIDynamicItem&gt;@property (nonatomic) CGRect frame;@property (nonatomic) CGPoint center;@property (nonatomic) CGSize size;@property (nonatomic) CATransform3D transform3D;@property (nonatomic) CGRect bounds NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGAffineTransform transform NS_AVAILABLE_IOS(7_0);@property (nonatomic) CGFloat alpha;@property (nonatomic) NSInteger zIndex; // default is 0@property (nonatomic, getter=isHidden) BOOL hidden; // As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES@property (nonatomic, strong) NSIndexPath *indexPath;@property (nonatomic, readonly) UICollectionElementCategory representedElementCategory;@property (nonatomic, readonly, nullable) NSString *representedElementKind; // nil when representedElementCategory is UICollectionElementCategoryCell+ (instancetype)layoutAttributesForCellWithIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForSupplementaryViewOfKind:(NSString *)elementKind withIndexPath:(NSIndexPath *)indexPath;+ (instancetype)layoutAttributesForDecorationViewOfKind:(NSString *)decorationViewKind withIndexPath:(NSIndexPath *)indexPath;@end 可以看出，UICollectionViewLayoutAttributes包含了Cell的frame、center、bounds等布局信息。 结语相比于UITableview，UICollectionview布局的复杂程度要更复杂得多，能很好的写出一个很不容易。正是由于UICollectionview布局的复杂性，我们更需要多去使用，在使用的过程中才能更好的理解UICollectionview本身这套API，也更好地学习苹果设计类的灵活性。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"UIImage加载图片方式的研究","slug":"UIImage加载图片方式的研究","date":"2015-10-20T11:56:39.000Z","updated":"2016-11-12T15:07:28.000Z","comments":true,"path":"2015/10/20/UIImage加载图片方式的研究/","link":"","permalink":"http://zakariyyasv.pub/2015/10/20/UIImage加载图片方式的研究/","excerpt":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。","text":"常用的UIImage加载图片的方式有以下几种： [UIImage imageNamed:name] [UIImage imageWithContentsOfFile:name] [UIImage imageWithData:data] [UIImage imageWithCGImage:imageRef] [UIImage imageWithCIImage:obj] 以上方法中imageNamed:和imageWitData:应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：imageWithContentsOfFile:从指定文件中创建对象，imageWithCGImage:以CGImageRef来创建对象，imageWithCIImage:以CIImage对象来创建对象。最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。 UIImage缓存原理1.[UIImage imageNamed:name]我通过查看imageNamed方法的调用栈以及查阅苹果相关文档后对UIImage的缓存实现有了清晰的认识。当调用imageNamed方法时，该方法会去内存缓存里去查找与参数一致的image对象并且返回最合适大小的image对象，如果没有找到，该方法则会去本地磁盘中查找然后加载图片并返回image对象，同时将image对象缓存到系统缓存中，以便下次重复使用。更底层一点的解释，当返回image对象时，并未对image的图片数据进行解码。它的解码过程发生在UIImage对象第一次显示到屏幕上的时候，而image对象的缓存也发生在这时候。当解码完成image显示在屏幕上后，应用程序会将image的解码结果保存到缓存中。通常缓存会在收到内存警告时才会被清空。 2.[UIImage imageWithData:data]在查看imageWithData方法的调用栈时发现了有意思的东西。通过二进制数据创建image对象时，实际上在底层调用的是ImageIO/ImageIO.h的CGImageSourceCreateWithData()方法。该方法的第二个参数可以传入key为kCGImageSourceShouldCache的键值对，它的值是CFBooleanRef类型的，默认情况下，在64位机器上它的值为kCFBooleanTrue，而在32位机器上它的值为kCFBooleanFalse。也就是说在64位机器上是会缓存的，而在32位机器上则是不会缓存的。与imageNamed方法类似，图片会在第一次显示到屏幕上时才会进行解码，随后再被缓存到CGImage里面。依据是CGImageSourceCreateWithData()方法第二个参数可以传入key为kCGImageSourceShouldCacheImmediately的键值对，默认情况下它的值是kCFBooleanFalse。 UIImage不缓存 [UIImage imageWithContentsOfFile:name]与前面两个方法略有不同，该方法是同步的（synchronous）。当在主线程（UI）中调用该方法时，会阻塞主线程并从磁盘中加载图片数据，若磁盘数据较大会造成卡顿或者延迟。通常的解决方法是另开一个线程异步完成磁盘加载图片数据的任务，然后在主线程中刷新UI。下面代码给出了一个例子： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; UIImage *image = [UIImage imageWithContentsOfFile:imagePath]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.button setBackgroundImage:image forState:UIControlStateNormal]; &#125;);&#125;); 当图片显示在屏幕上时，系统并不会对其进行缓存。当图片数据被加载到内存中，它会被标记为可清除（purgeable）。如果数据被清除了且需要再次加载，image对象会再次从指定的文件路径获取数据并加载进内存中。根据它的实现原理，通常该方法的使用场景是图片不需要重复展示，或者图片的数据较大会造成内存警告。当然，这并不是说imageWithContentsOfFile:一定比imageNamed:方法高效，imageWithContentsOfFile:方法的问题在于它会将图片文件全尺寸展示在屏幕上即使是512*512的图片都要占到1M多的内存，加载会影响程序的性能，造成不好的用户体验。针对图片尺寸太大带来的性能问题，比较好的解决方案是用CGImageSource的有关方法，将图片的尺寸缩减到适合的尺寸，减小数据大小。123456789101112131415161718192021#import &lt;ImageIO/ImageIO.h&gt;NSURL *imageFileURL = [NSURL fileURLWithPath:...];CGImageSourceRef imageSource = CGImageSourceCreateWithURL((CFURLRef)imageFileURL, NULL);if (imageSource == NULL) &#123; // Error loading image ... return;&#125;NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:NO], (NSString *)kCGImageSourceShouldCache, nil];CFDictionaryRef imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, (CFDictionaryRef)options);if (imageProperties) &#123; NSNumber *width = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelWidth); NSNumber *height = (NSNumber *)CFDictionaryGetValue(imageProperties, kCGImagePropertyPixelHeight); NSLog(@\"Image dimensions: %@ x %@ px\", width, height); CFRelease(imageProperties);&#125;CFRelease(imageSource);","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]},{"title":"Xcode-Target、Project、WorkSpace、Scheme","slug":"Xcode-Target、Project、WorkSpace、Scheme","date":"2015-10-18T08:20:46.000Z","updated":"2016-12-20T05:55:54.000Z","comments":true,"path":"2015/10/18/Xcode-Target、Project、WorkSpace、Scheme/","link":"","permalink":"http://zakariyyasv.pub/2015/10/18/Xcode-Target、Project、WorkSpace、Scheme/","excerpt":"前言开发iOS有一段时间了，Xcode用得也越发熟练，但对于Xcode中的一些常用项目结构的概念如Target、Project等却还是一知半解。故将其摘出来搞清楚，避免以后犯概念性错误。","text":"前言开发iOS有一段时间了，Xcode用得也越发熟练，但对于Xcode中的一些常用项目结构的概念如Target、Project等却还是一知半解。故将其摘出来搞清楚，避免以后犯概念性错误。 Target一个Target对应一个编译的product并且包含将Project或workspace中的文件编译成product的指令。Project可以包含一个或多个Target，而每个Target对应一个product。 编译product的指令包含了Build Settings和Build Phases，我们可以在Xcode的编辑器中进行编辑和修改。Target继承了project中的Build Settings中的所有设置，我们也可以在Target中自行修改Project中的设定。同一时间只能有一个活动的Target，Xcode中通过schema来指定这个Target。 Target和它所创建的product可以与另一个Target相关联。如果一个Target需要另一个Target的输出来完成编译，那就可以说第一个Target依赖于第二个Target。如果两个Target处在同一个WorkSpace中，那么当Xcode编译是，便可以发现它们之间的依赖关系。这种关系也可称为隐式依赖。当然，我们也可以在Build Settings中指定显式依赖关系，Xcode中存在显式依赖关系的两个Target实际上并没有依赖。例如，在同一个WorkSpace中，你可以编译一个类库和一个应用并将那个类库链接进来。Xcode可以发现它们的关系并自动先编译那个类库。然而，如果你只是想链接这个类库的某一个版本而不是WorkSpace中编译的那个，你可以在Build Settings在创建显式依赖并覆盖隐式依赖。 ProjectXcode的Project是编译一个或多个软件产品不可或缺的所有文件、资源和信息的存储库。一个Project包含用来编译产品的所有元素和保存元素之间的关联信息。一个Project包含一个或多个Target，Project指定了项目中所有Target默认的编译设置。 一个Xcode Project包含以下信息： 源文件的索引： 源代码，包含头文件和实现文件 类库和框架，内部的和外部的 资源文件 图像文件 xib、storyboard文件 用来组织在结构导航中的源文件的组 项目级编译配置。你可以指定Project不止一种编译配置，例如，你可以设定Project有debug和release两种配置。 Targets，其中包含： 项目编译生成的product的索引 编译product所需要的源文件的索引 用来编译项目的编译配置，包含对其他Target的依赖和其他设置；项目级编译设定只会在Target编译配置没有重设时才会应用。 用于debug和测试项目的可执行环境 一个Project可以独立存在或者包含在WorkSpace中。你可以使用Scheme来给定模式下哪个Target、编译配置和可执行环境配置处于活跃状态。 WorkspaceWorkSpace是Xcode将project和其他文档组合在一起的文档，以便可以让它们协同工作。WorkSpace可以包含任何数目的project，可以添加任何你想引入的文件。此外，为了在每个Xcode项目中组织所有的文件，WorkSpace在project和它们的Target之间提供了显式和隐式关系。 此外，WorkSpace扩展了很多重要的Xcode工作流的范围。例如，因为索引贯穿整个的WorkSpace，因此代码提示、跳到定义和所有其他内容上的特性在整个WorkSpace中无缝使用。因为重构操作贯穿整个WorkSpace的内容中，你可以重构项目中框架的API并让所有使用该框架的项目都只需执行一次重构操作。当编译时，一个项目可以使用WorkSpace中其他project的product。 WorkSpace文档包含指向包含的项目和其他文件的指针，而没有其他数据。一个Project可以属于不止一个WorkSpace。 默认情况下，在WorkSpace中的所有Xcode项目编译在同一个目录下。每个WorkSpace都有自己的编译目录。因为在同一个WorkSpace中的所有项目的所有文件在相同的编译目录下，所以所有这些文件对于每个项目都是可见的。因而，如果两个或者更多的project使用同一个类库，你不需要单独在每个项目中都拷贝一份。 在WorkSpace中的project都可以继续保有自己独立的实体。如果不想被其他项目影响或者不想影响别的项目，我们可以不在WorkSpace中打开project，或者也可以将project添加到别的WorkSpace中。 Schemescheme定义编译的Target的集合，编译时使用的配置以及测试的集合。 你可以有很多的scheme，只要你想要，但是在同一时间只能有一个是活跃状态。你可以指定一个scheme是否应该保存在项目中。当你指定一个活跃的scheme，你还可以选择运行目标。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://zakariyyasv.pub/categories/开发工具/"}],"tags":[],"keywords":[{"name":"开发工具","slug":"开发工具","permalink":"http://zakariyyasv.pub/categories/开发工具/"}]},{"title":"UINavigationBar背景色设置","slug":"UINavigationBar背景色设置","date":"2015-09-24T03:22:21.000Z","updated":"2016-12-20T07:51:49.000Z","comments":true,"path":"2015/09/24/UINavigationBar背景色设置/","link":"","permalink":"http://zakariyyasv.pub/2015/09/24/UINavigationBar背景色设置/","excerpt":"前言最近关于UINavigationBar背景色随tableView滚动而渐变的风格很流行，自己也想着研究去实现它，并决定把研究的结果写进这篇文章中。渐变的实现很简单，思路无非是监听tableView的contentOffset属性，在scrollViewDidScroll方法中更新navigationbar背景色的alpha值，我们的重点放在设置navigationbar背景色上。","text":"前言最近关于UINavigationBar背景色随tableView滚动而渐变的风格很流行，自己也想着研究去实现它，并决定把研究的结果写进这篇文章中。渐变的实现很简单，思路无非是监听tableView的contentOffset属性，在scrollViewDidScroll方法中更新navigationbar背景色的alpha值，我们的重点放在设置navigationbar背景色上。 关于translucent属性在iOS 7后translucent属性默认为YES，如果你给navigtionbar设置自定义的背景图片，若该图片的alpha值小于1，那么显示时会使用图片本身的alpha值，若该图片不透明，显示时则会应用系统设置的透明度到图片上。如果设置translucent为NO，那么背景图片显示将会正常。 上面是苹果官方文档对于translucent属性的解释，我通过Reveal查看并在控制台打印两种情况下UINavigationbar的视图结构，结果也印证了文档中的说明。 translucent为NO 1234567&lt;UINavigationBar: 0x7fe045a02530; frame = (0 20; 375 44); autoresize = W; gestureRecognizers = &lt;NSArray: 0x608000049ae0&gt;; layer = &lt;CALayer: 0x61000003e120&gt;&gt; | &lt;_UIBarBackground: 0x7fe042405e20; frame = (0 -20; 375 64); userInteractionEnabled = NO; layer = &lt;CALayer: 0x61000003e000&gt;&gt; | | &lt;UIImageView: 0x7fe0424061c0; frame = (0 64; 375 0.5); userInteractionEnabled = NO; layer = &lt;CALayer: 0x61000003fba0&gt;&gt; | &lt;&lt;UINavigationItemView: 0x7fe045809b00; frame = (170 8; 35 27); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x61800003d6a0&gt;&gt;: item=&lt;&lt;UINavigationItem: 0x6100001c78f0&gt;: title:'标题'&gt; title=标题&gt; | | &lt;UILabel: 0x7fe04580a110; frame = (0 3.5; 35 21.5); text = '标题'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x61800009bc60&gt;&gt; | | | &lt;_UILabelContentLayer: 0x60800003db80&gt; (layer) | &lt;_UINavigationBarBackIndicatorView: 0x7fe042507680; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60800003dfa0&gt;&gt; 从视图结构可以看出，UINavigationbar主要由_UIBarBackground、UINavigationItemView、_UINavigationBarBackIndicatorView三部分组成，很简单。 translucent为YES 12345678910&lt;UINavigationBar: 0x7fcc06e07280; frame = (0 20; 375 44); opaque = NO; autoresize = W; gestureRecognizers = &lt;NSArray: 0x610000044710&gt;; layer = &lt;CALayer: 0x61800002e560&gt;&gt; | &lt;_UIBarBackground: 0x7fcc06d01980; frame = (0 -20; 375 64); userInteractionEnabled = NO; layer = &lt;CALayer: 0x6080000303c0&gt;&gt; | | &lt;UIImageView: 0x7fcc06d03920; frame = (0 64; 375 0.5); userInteractionEnabled = NO; layer = &lt;CALayer: 0x6080000308c0&gt;&gt; | | &lt;UIVisualEffectView: 0x7fcc06d09e60; frame = (0 0; 375 64); layer = &lt;CALayer: 0x608000030980&gt;&gt; | | | &lt;_UIVisualEffectBackdropView: 0x7fcc08901a90; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;UICABackdropLayer: 0x61000002fac0&gt;&gt; | | | &lt;_UIVisualEffectFilterView: 0x7fcc06d09490; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x608000030c40&gt;&gt; | &lt;&lt;UINavigationItemView: 0x7fcc08e007f0; frame = (170 8; 35 27); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x61800002e740&gt;&gt;: item=&lt;&lt;UINavigationItem: 0x6180001c1fe0&gt;: title:'标题'&gt; title=标题&gt; | | &lt;UILabel: 0x7fcc08e00d30; frame = (0 3.5; 35 21.5); text = '标题'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x618000095f40&gt;&gt; | | | &lt;_UILabelContentLayer: 0x61800002fb80&gt; (layer) | &lt;_UINavigationBarBackIndicatorView: 0x7fcc06c05f30; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60000002e780&gt;&gt; 相比于trasulent为NO时，UINavigationbar在_UIBarBackground中多了一层UIVisualEffectView。我们都知道UIVisualEffectView类是给背景图层提供虚化效果的，这也解释了文档中对于trasulent为YES时的说明。 设置navigationbar背景色问题通常要设置navigationbar背景颜色，我们会调用[self.navigationController.navigationBar setBackgroundColor:[UIColor redColor]];方法。运行看看，效果好像跟预想的不太一样。 transulent=YES transulent=NO 在transulent=YES时，还能看见一点红色，而在transulent=NO时，则完全没效果。这是为嘛呢？回头看看前面UINavigationbar视图结构，你也许就有答案了。 从上图可以看到，UINavigationBar实际上被前面的_UIBarBackground挡住了，故而没有效果。 设置navigationbar背景色解决方案既然找到了问题的缘由，自然也就有对应的解决方案。我这里只提供两种解决方法，实际上解决方法不止两种，而我选择这两种解决方法是因为一种很便利，一种可扩展性强，基本上这两种解决办法可以满足我们大部分的需求。 先说第一种便利的解决办法。既然_UIBarBackground对象挡住了navigationbar，那就设置_UIBarBackground对象的backgroundColor。由于API中并没有提供关于_UIBarBackground对象，我们只能通过KVC的方式，通过断点调试我们发现UINavigationbar的成员变量如下： 12345678@implementation UINavigationBar (ZS_BackgroundColor)- (void)setZS_BackgroundColor:(UIColor *)color&#123; UIView *originView = [self valueForKey:@\"_barBackgroundView\"]; originView.backgroundColor = color;&#125;@end 从图中我们可以看出有个叫_barBackgroundView的_UIBarBackground对象，就它了。通过category去设置_barBackgroundView的背景色，貌似这样就能成功了。编译运行，结果大跌眼镜，并没有任何变化。猜想应该是内部在显示之前重置了_barBackgroundView的背景色，那就意味着此路不通，PASS。 第二种方案是在_barBackgroundView上面插入自定义的view，通过这个view来控制navigationbar的背景色。实现上在category中运行runtime机制将view与指定的key动态绑定，以便可以做更多扩展性的事情，比如QQ空间中UIActivityView加载等。 123456789101112131415161718192021222324252627#import \"UINavigationBar+BackgroundColor.h\"#import &lt;objc/runtime.h&gt;@implementation UINavigationBar (ZS_BackgroundColor)static char overlayKey;- (UIView *)overlay&#123; return objc_getAssociatedObject(self, &amp;overlayKey);&#125;- (void)setOverlay:(UIView *)overlay&#123; objc_setAssociatedObject(self, &amp;overlayKey, overlay, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (void)setZS_BackgroundColor:(UIColor *)backgroundColor&#123; if (!self.overlay) &#123; // insert an overlay into the view hierarchy self.overlay = [[UIView alloc] initWithFrame:CGRectMake(0, -20, [UIScreen mainScreen].bounds.size.width, self.bounds.size.height + 20)]; [self insertSubview:self.overlay aboveSubview:[self valueForKey:@\"_barBackgroundView\"]]; &#125; self.overlay.backgroundColor = backgroundColor;&#125;@end 设置编译运行，看看效果，没有问题，问题解决！ 结语在UINavigationbar的视图层中插入自定义view是很好的解决方案，一方面不破坏视图结构，另一方面提供了更多的扩展性，例如下图QQ空间中的activityView。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}],"tags":[],"keywords":[{"name":"iOS","slug":"iOS","permalink":"http://zakariyyasv.pub/categories/iOS/"}]}]}