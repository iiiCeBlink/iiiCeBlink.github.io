<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Mach-O 文件解析]]></title>
      <url>https://iiiceblink.github.io/2018/11/10/analyzeMachoFile/</url>
      <content type="html"><![CDATA[<h3 id="0x00-概要"><a href="#0x00-概要" class="headerlink" title="0x00 概要"></a>0x00 概要</h3><p><code>Mach-O</code> 是 <code>Mach object</code> 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。作为 <code>a.out</code> 格式的替代品， <code>Mach-O</code> 提供了更好的扩展性，并提升了符号表中信息的访问速度。</p>
<p>每个 <code>Mach-O</code> 文件都包含一个 <code>Mach-O</code> 头，然后是载入命令(<code>Load Commands</code>),最后是数据块(<code>Data</code>)。</p>
<p><img src="/images/macho/macho.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>Header : 保存了 <code>Mach-O</code> 的一些基本信息，包括了平台、文件类型、 <code>LoadCommands</code> 的个数等等。</li>
<li>LoadCommands：这一段紧跟 <code>Header</code> ，加载 <code>Mach-O</code> 文件时会使用这里的数据来确定内存的分布。</li>
<li>Data：每一个 <code>segment</code> 的具体数据都保存在这里，这里包含了具体的代码、数据等等。</li>
</ul>
<p><strong>注意</strong>：如果是一个 Fat <code>Mach-O</code> 文件，则它的结构会稍有不同，会多出一个 <code>Fat Header</code> 。</p>
<p>为了更好地说明 <code>Mach-O</code> 的文件格式，下面会借助于 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="external">MachOView</a> 来展示其内部的结构。</p>
<p><img src="/images/macho/machoOverview.jpg" alt=""></p>
<h3 id="0x01-Fat-Header"><a href="#0x01-Fat-Header" class="headerlink" title="0x01 Fat Header"></a>0x01 Fat Header</h3><p><code>Fat Header</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/machine.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC	0xcafebabe</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM	0xbebafeca	</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> fat_header &#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	magic;		<span class="comment">/* FAT_MAGIC */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	nfat_arch;	<span class="comment">/* number of structs that follow */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> fat_arch &#123;</div><div class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier (int) */</span></div><div class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier (int) */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	offset;		<span class="comment">/* file offset to this object file */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	size;		<span class="comment">/* size of this object file */</span></div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>	align;		<span class="comment">/* alignment as a power of 2 */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> KERNEL</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach_types.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> vnode;</div><div class="line"></div><div class="line"><span class="comment">/* XXX return type should be load_return_t, but mach_loader.h is not in scope */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatfile_getarch_affinity</span><span class="params">(<span class="keyword">struct</span> vnode *vp, <span class="keyword">vm_offset_t</span> data_ptr,</span></span></div><div class="line">		<span class="keyword">struct</span> fat_arch *archret, <span class="keyword">int</span> affinity);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatfile_getarch</span><span class="params">(<span class="keyword">struct</span> vnode *vp, <span class="keyword">vm_offset_t</span> data_ptr,</span></span></div><div class="line">		<span class="keyword">struct</span> fat_arch *archret);</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fatfile_getarch_with_bits</span><span class="params">(<span class="keyword">struct</span> vnode *vp, <span class="keyword">integer_t</span> archbits,</span></span></div><div class="line">		<span class="keyword">vm_offset_t</span> data_ptr, <span class="keyword">struct</span> fat_arch *archret);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* KERNEL */</span></span></div></pre></td></tr></table></figure>
<p>由代码定义我们可以看出 <code>fat_header</code> 主要包含两部分：</p>
<ul>
<li><code>magic</code> : 标识当前文件是 Fat <code>Mach-O</code> 文件</li>
<li><code>nfat_arch</code> : 当前文件中包含的架构的数目</li>
</ul>
<h3 id="0x02-Header"><a href="#0x02-Header" class="headerlink" title="0x02 Header"></a>0x02 Header</h3><p><code>Header</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * The 32-bit mach header appears at the very beginning of the object file for</div><div class="line"> * 32-bit architectures.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> mach_header &#123;</div><div class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></div><div class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></div><div class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></div><div class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></div><div class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_MAGIC	0xfeedface	<span class="comment">/* the mach magic number */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM	0xcefaedfe	<span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * The 64-bit mach header appears at the very beginning of object files for</div><div class="line"> * 64-bit architectures.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> mach_header_64 &#123;</div><div class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></div><div class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></div><div class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></div><div class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></div><div class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64 0xcffaedfe <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></div></pre></td></tr></table></figure>
<p>由源码可以看出 <code>Header</code> 的主要作用就是帮助系统迅速的定位 <code>Mach-O</code> 文件的运行环境，文件类型。</p>
<p><img src="/images/macho/header.jpg" alt=""></p>
<p>由此我们可以看出 <code>Header</code> 主要由以下几部分组成：</p>
<ul>
<li><code>magic number</code> : 确定是 32 位还是 64 位平台上的文件。 <code>0xfeedfacf</code> 代表 64 位， <code>0xfeedface</code> 代表 32 位。</li>
<li><code>CPU type</code> <code>CPU subtype</code> : 确定文件运行的 CPU 架构，这里是 x86_64 架构。</li>
<li><code>File Type</code> : 标识文件的类型。它所有的值定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_OBJECT	0x1		<span class="comment">/* relocatable object file */</span>  <span class="comment">//  编译过程中产生的*.obj文件 </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_EXECUTE	0x2		<span class="comment">/* demand paged executable file */</span>  <span class="comment">// 可执行二进制文件</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_FVMLIB	0x3		<span class="comment">/* fixed VM shared library file */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_CORE		0x4		<span class="comment">/* core file */</span>      <span class="comment">//  崩溃时的Dump文件 </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PRELOAD	0x5		<span class="comment">/* preloaded executable file */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLIB	0x6		<span class="comment">/* dynamically bound shared library */</span>  <span class="comment">// 动态库</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLINKER	0x7		<span class="comment">/* dynamic link editor */</span>    <span class="comment">// 动态链接器</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_BUNDLE	0x8		<span class="comment">/* dynamically bound bundle file */</span>   <span class="comment">// bundle 文件</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLIB_STUB	0x9		<span class="comment">/* shared library stub for static */</span></span></div><div class="line">					<span class="comment">/*  linking only, no section contents */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DSYM		0xa		<span class="comment">/* companion file with only debug */</span></span></div><div class="line">					<span class="comment">/*  sections */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_KEXT_BUNDLE	0xb		<span class="comment">/* x86_64 kexts */</span>  <span class="comment">//  内核扩展文件</span></span></div></pre></td></tr></table></figure>
<ul>
<li><code>Flags</code> : 指定了 dyld 的加载参数，其所有参数如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Constants for the flags field of the mach_header */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* the object file has no undefined</span></span></div><div class="line">					   references */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_INCRLINK	0x2		<span class="comment">/* the object file is the output of an</span></span></div><div class="line">					   incremental link against a base file</div><div class="line">					   and can't be link edited again */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK	0x4		<span class="comment">/* the object file is input for the</span></span></div><div class="line">					   dynamic linker and can't be staticly</div><div class="line">					   link edited again */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDATLOAD	0x8		<span class="comment">/* the object file's undefined</span></span></div><div class="line">					   references are bound by the dynamic</div><div class="line">					   linker when loaded. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBOUND	0x10		<span class="comment">/* the file has its dynamic undefined</span></span></div><div class="line">					   references prebound. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS	0x20		<span class="comment">/* the file has its read-only and</span></span></div><div class="line">					   read-write segments split */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_LAZY_INIT	0x40		<span class="comment">/* the shared library init routine is</span></span></div><div class="line">					   to be run lazily via catching memory</div><div class="line">					   faults to its writeable segments</div><div class="line">					   (obsolete) */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL	0x80		<span class="comment">/* the image is using two-level name</span></span></div><div class="line">					   space bindings */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT	0x100		<span class="comment">/* the executable is forcing all images</span></span></div><div class="line">					   to use flat name space bindings */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOMULTIDEFS	0x200		<span class="comment">/* this umbrella guarantees no multiple</span></span></div><div class="line">					   defintions of symbols in its</div><div class="line">					   sub-images so the two-level namespace</div><div class="line">					   hints can always be used. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOFIXPREBINDING 0x400	<span class="comment">/* do not have dyld notify the</span></span></div><div class="line">					   prebinding agent about this</div><div class="line">					   executable */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBINDABLE  0x800           <span class="comment">/* the binary is not prebound but can</span></span></div><div class="line">					   have its prebinding redone. only used</div><div class="line">                                           when MH_PREBOUND is not set. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLMODSBOUND 0x1000		<span class="comment">/* indicates that this binary binds to</span></span></div><div class="line">                                           all two-level namespace modules of</div><div class="line">					   its dependent libraries. only used</div><div class="line">					   when MH_PREBINDABLE and MH_TWOLEVEL</div><div class="line">					   are both set. */ </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SUBSECTIONS_VIA_SYMBOLS 0x2000<span class="comment">/* safe to divide up the sections into</span></span></div><div class="line">					    sub-sections via symbols for dead</div><div class="line">					    code stripping */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CANONICAL    0x4000		<span class="comment">/* the binary has been canonicalized</span></span></div><div class="line">					   via the unprebind operation */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES	0x8000		<span class="comment">/* the final linked image contains</span></span></div><div class="line">					   external weak symbols */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000	<span class="comment">/* the final linked image uses</span></span></div><div class="line">					   weak symbols */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* When this bit is set, all stacks </span></span></div><div class="line">					   in the task will be given stack</div><div class="line">					   execution privilege.  Only used in</div><div class="line">					   MH_EXECUTE filetypes. */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ROOT_SAFE 0x40000           <span class="comment">/* When this bit is set, the binary </span></span></div><div class="line">					  declares it is safe for use in</div><div class="line">					  processes with uid zero */</div><div class="line">                                         </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SETUID_SAFE 0x80000         <span class="comment">/* When this bit is set, the binary </span></span></div><div class="line">					  declares it is safe for use in</div><div class="line">					  processes when issetugid() is true */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_REEXPORTED_DYLIBS 0x100000 <span class="comment">/* When this bit is set on a dylib, </span></span></div><div class="line">					  the static linker does not need to</div><div class="line">					  examine dependent dylibs to see</div><div class="line">					  if any are re-exported */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PIE 0x200000			<span class="comment">/* When this bit is set, the OS will</span></span></div><div class="line">					   load the main executable at a</div><div class="line">					   random address.  Only used in</div><div class="line">					   MH_EXECUTE filetypes. */</div></pre></td></tr></table></figure>
<p>条目比较长，这里介绍几个常见的：</p>
<table>
<thead>
<tr>
<th>Flag Type</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_NOUNDEFS</td>
<td>目标没有未定义的符号，不存在链接依赖</td>
</tr>
<tr>
<td>MH_DYLDLINK</td>
<td>该目标文件是 dyld 的输入文件，无法被再次的静态链接</td>
</tr>
<tr>
<td>MH_PIE</td>
<td>允许随机的地址空间</td>
</tr>
<tr>
<td>MH_ALLOW_STACK_EXECUTION</td>
<td>栈内存可执行代码，一般是默认关闭的</td>
</tr>
<tr>
<td>MH_NO_HEAP_EXECUTION</td>
<td>堆内存无法执行代码</td>
</tr>
<tr>
<td>MH_BINDS_TO_WEAK</td>
<td>最终链接文件包含弱符号</td>
</tr>
<tr>
<td>MH_WEAK_DEFINES</td>
<td>文件包含外部弱符号</td>
</tr>
<tr>
<td>MH_TWOLEVEL</td>
<td>两级名称空间绑定</td>
</tr>
</tbody>
</table>
<h3 id="0x03-Load-Commands"><a href="#0x03-Load-Commands" class="headerlink" title="0x03 Load Commands"></a>0x03 Load Commands</h3><p>其数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> load_command &#123;</div><div class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></div><div class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/images/macho/loadcmd.jpg" alt=""></p>
<p>这些加载命令在 <code>Mach-O</code> 文件加载解析时，被内核加载器或者动态链接器调用，指导如何设置加载对应的二进制数据段。从内部逻辑来说，它是根据 <code>cmd</code> 的类型去调用相对应的函数来加载。以下列出一些常见的 <code>cmd</code> ：</p>
<table>
<thead>
<tr>
<th>Command类型</th>
<th>处理函数或结构体</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>LC_SEGMENT；LC_SEGMENT_64</td>
<td>load_segment</td>
<td>将 segment 中的数据加载并映射到进程的内存空间去</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>load_dylinker</td>
<td>启动动态加载链接器 /usr/lib/dyld 程序</td>
</tr>
<tr>
<td>LC_UUID</td>
<td>load_uuid</td>
<td>加载128-bit的唯一ID，标示该二进制文件</td>
</tr>
<tr>
<td>LC_THREAD</td>
<td>load_thread</td>
<td>开启一个MACH线程，但是不分配栈空间。</td>
</tr>
<tr>
<td>LC_UNIXTHREAD</td>
<td>load_unixthread</td>
<td>开启一个UNIX线程</td>
</tr>
<tr>
<td>LC_CODE_SIGNATURE</td>
<td>load_code_signature</td>
<td>进行数字签名</td>
</tr>
<tr>
<td>LC_ENCRYPTION_INFO</td>
<td>set_code_unprotect</td>
<td>加密二进制文件</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td></td>
<td>加载符号表和字符串表</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td></td>
<td>动态符号表信息 创建导入表，包含符号表上已被加载的数据</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>struct dylib_command</td>
<td>加载的动态库，包括动态库地址、名称、版本号等</td>
</tr>
<tr>
<td>LC_FUNCTION_STARTS</td>
<td></td>
<td>函数地址起始表</td>
</tr>
<tr>
<td>LC_MAIN</td>
<td>struct entry_point_command</td>
<td>可执行文件的主函数main()的位置</td>
</tr>
</tbody>
</table>
<p>至于 <code>cmdsize</code> 字段是表示 <code>command</code> 整个大小，用于计算出到下一个 <code>command</code> 的偏移量。</p>
<h3 id="0x04-Segments"><a href="#0x04-Segments" class="headerlink" title="0x04 Segments"></a>0x04 Segments</h3><p>加载数据时，主要加载的就是 <code>LC_SEGMET</code> 或者 <code>LC_SEGMENT_64</code>，其数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> segment_command &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></div><div class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></div><div class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></div><div class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></div><div class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></div><div class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></div><div class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></div><div class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></div><div class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></div><div class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> segment_command_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></div><div class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></div><div class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></div><div class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></div><div class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></div><div class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></div><div class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></div><div class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></div><div class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></div><div class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从定义可以看出它的大部分作用是定义了一些 <code>Mach-O</code> 文件的数据、地址和内存保护属性，这些数据在动态链接器加载程序时被映射到了虚拟内存中。主要要关注的是 <code>nsects</code> 字段，标示了 <code>Segment</code> 中有多少 <code>secetion</code>。 <code>section</code> 是具体有用的数据存放的地方。这里提一下 <code>vmaddr</code> 变量， <code>vmaddr</code> 段的虚存地址（未偏移），由于 <code>ALSR</code> ，程序会在进程加上一段偏移量（<code>slide</code>），真实的地址 <code>= vm address + slide</code> 。</p>
<p><code>LC_SEGMENT</code> 意味着这部分文件需要映射到进程的地址空间去。一般有以下段名：</p>
<ul>
<li><code>__PAGEZERO</code> :　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 <code>NULL</code> 指针的引用。</li>
<li><code>__TEXT</code> :　包含了执行代码以及其他只读数据。该段数据可以 <code>VM_PROT_READ</code>(读)、<code>VM_PROT_EXECUTE</code>(执行)，不能被修改。</li>
<li><code>__DATA</code> :　程序数据，该段可写 <code>VM_PROT_WRITE/READ/EXECUTE</code>。</li>
<li><code>__LINKEDIT</code> :　链接器使用的符号以及其他表</li>
</ul>
<h3 id="0x05-Section"><a href="#0x05-Section" class="headerlink" title="0x05 Section"></a>0x05 Section</h3><p><code>Section</code> 的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></div><div class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></div><div class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></div><div class="line">	<span class="keyword">uint32_t</span>	addr;		<span class="comment">/* memory address of this section */</span></div><div class="line">	<span class="keyword">uint32_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></div><div class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></div><div class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></div><div class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> section_64 &#123; <span class="comment">/* for 64-bit architectures */</span></div><div class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></div><div class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></div><div class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* memory address of this section */</span></div><div class="line">	<span class="keyword">uint64_t</span>	size;		<span class="comment">/* size in bytes of this section */</span></div><div class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></div><div class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></div><div class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></div><div class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></div><div class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* reserved */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了同样有帮助内存映射的变量外，在了解 <code>Mach-O</code> 格式的时候，只需要知道不同的 <code>Section</code> 有着不同的作用就可以了。</p>
<ul>
<li><code>__text</code> : 代码</li>
<li><code>__cstring</code> : 硬编码的字符串</li>
<li><code>__const</code> : const 关键词修饰过的变量</li>
<li><code>__DATA.__bss</code> : bss段</li>
</ul>
<table>
<thead>
<tr>
<th>Section</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Text.__text</code></td>
<td>主程序代码</td>
</tr>
<tr>
<td><code>Text.__stub_helper</code></td>
<td>用于动态链接的存根</td>
</tr>
<tr>
<td><code>Text.__objc_methname</code></td>
<td>方法名列表</td>
</tr>
<tr>
<td><code>Text.__objc_classname</code></td>
<td>类名列表</td>
</tr>
<tr>
<td><code>Text.__objc_methtype</code></td>
<td>方法签名列表</td>
</tr>
<tr>
<td><code>Text.__cstring</code></td>
<td>c 字符串</td>
</tr>
<tr>
<td><code>Text.__stubs</code></td>
<td>桩代码</td>
</tr>
<tr>
<td><code>Data.__objc_classlist</code></td>
<td>类列表</td>
</tr>
<tr>
<td><code>Data.__objc_nlclslist</code></td>
<td><code>Objective-C</code> 的 <code>+load</code> 函数列表，比 <code>__mod_init_func</code> 更早执行</td>
</tr>
<tr>
<td><code>Data.__data</code></td>
<td>初始化可变的数据</td>
</tr>
<tr>
<td><code>Data._got</code></td>
<td>存储引用符号的实际地址，类似于动态符号表</td>
</tr>
<tr>
<td><code>Data.__cfstring</code></td>
<td><code>Core Foundation</code> 用到的字符串（OC字符串）</td>
</tr>
<tr>
<td><code>Data.__objc_imageinfo</code></td>
<td>镜像信息</td>
</tr>
<tr>
<td><code>Data.__la_symbol_ptr</code></td>
<td>懒加载符号指针表，通过 <code>dyld_stub_binder</code> 辅助链接</td>
</tr>
<tr>
<td><code>Data.__nl_symbol_ptr</code></td>
<td>非懒加载符号指针表</td>
</tr>
<tr>
<td><code>Data.__mod_init_func</code></td>
<td>初始化的全局函数地址，在 <code>main</code> 之前被调用</td>
</tr>
<tr>
<td><code>Data.__objc_const</code></td>
<td><code>Objective-C</code> 的常量</td>
</tr>
</tbody>
</table>
<h3 id="0x06-二进制文件符号查找"><a href="#0x06-二进制文件符号查找" class="headerlink" title="0x06 二进制文件符号查找"></a>0x06 二进制文件符号查找</h3><p>我们可以结合 <code>fishhook</code> 的一张图来分析。</p>
<p><img src="/images/macho/fishhook.png" alt=""></p>
<p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p>
<ol>
<li>从 <code>__DATA</code> 段中的 <code>lazy</code> 符号指针表中查找某个符号，获得这个符号的偏移量 1061 ，然后在每一个 <code>section_64</code> 中查找 <code>reserved1</code> ，通过这两个值找到 <code>Indirect Symbol Table</code> 中符号对应的条目</li>
<li>在 <code>Indirect Symbol Table</code> 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</li>
<li>然后通过符号表中的偏移量，获取字符串表中的符号 <code>_close</code></li>
</ol>
<p>从代码角度来看，整个过程大致是这样的。首先从镜像中查找 <code>linkedit_segment</code> <code>symtab_command</code> 和 <code>dysymtab_command</code> ；在开始查找之前，要先跳过 <code>mach_header_t</code> 长度的位置，然后将当前指针强转成 <code>segment_command_t</code> ，通过对比 <code>cmd</code> 的值，来找到需要的 <code>segment_command_t</code> 。在 <code>linkedit_segment</code> 结构体中获得其虚拟地址以及文件偏移量，然后通过一下公式来计算当前 <code>__LINKEDIT</code> 段的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slide + vmaffr - fileoff</div></pre></td></tr></table></figure>
<p>类似地，在 <code>symtab_command</code> 中获取符号表偏移量和字符串表偏移量，从 <code>dysymtab_command</code> 中获取间接符号表（<code>indirect symbol table</code>）偏移量，就能够获得<em>符号表</em>、<em>字符串表</em>以及<em>间接符号表</em>的引用了。</p>
<ul>
<li>间接符号表中的元素都是 <code>uint32_t *</code>，指针的值是对应条目 <code>n_list</code> 在符号表中的位置</li>
<li>符号表中的元素都是 <code>nlist_t</code> 结构体，其中包含了当前符号在字符串表中的下标</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> nlist_64 &#123;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">    	<span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></div><div class="line">	&#125; n_un;</div><div class="line">	<span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></div><div class="line">	<span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></div><div class="line">	<span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></div><div class="line">	<span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>字符串表中的元素是 <code>char</code> 字符</li>
</ul>
<p>总结一下就是：</p>
<ol>
<li>通过 i<code>ndirect_symtab + section-&gt;reserved1</code> 获取 <code>indirect_symbol_indices *</code>，也就是符号表的数组</li>
<li>通过 <code>(void **)((uintptr_t)slide + section-&gt;addr)</code> 获取函数指针列表 <code>indirect_symbol_bindings</code></li>
<li>遍历符号表数组 <code>indirect_symbol_indices *</code> 中的所有符号表中，获取其中的符号表索引 <code>symtab_index</code></li>
<li>通过符号表索引 <code>symtab_index</code> 获取符号表中某一个 <code>n_list</code> 结构体，得到字符串表中的索引 <code>symtab[symtab_index].n_un.n_strx</code></li>
<li>最后在字符串表中获得符号的名字 <code>char *symbol_name</code></li>
</ol>
<p>以上就是查找符号的整个过程。不过，以上的过程有个限定条件，那就是该符号是存在于外部动态链接库中的。如果你所要查找的符号包含于当前的镜像中，则不需要 <code>dyld</code> 解决函数地址的问题，它是直接从其他代码地址跳转到了当前函数的实现中。</p>
<h3 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h3><p>要想继续深入 iOS 底层，<code>Mach-O</code> 是绕不开的一环。深入了解 <code>Mach-O</code> 后，为后续安装包瘦身，动态修改函数指针等打下坚实的基础。</p>
<h3 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h3><p><a href="https://feicong.github.io/2017/01/13/macho/" target="_blank" rel="external">Mach-O文件格式</a><br><a href="https://opensource.apple.com/source/xnu/xnu-1228.15.4/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="external">Apple Open Source</a><br><a href="https://draveness.me/fishhook" target="_blank" rel="external">动态修改 C 语言函数的实现</a><br><a href="https://amywushu.github.io/2017/02/27/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-fishhook-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html" target="_blank" rel="external">Hook 原理之 fishhook 源码解析</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为 Objective-C 下的 protocol 添加默认实现]]></title>
      <url>https://iiiceblink.github.io/2018/10/24/protocolExtension/</url>
      <content type="html"><![CDATA[<p>最近有业务有需求需要为 <code>UIViewController</code> 的 <code>UIViewControllerTransitioningDelegate</code> 协议提供默认的实现，使用 swift 开发默认是支持给协议添加默认实现的，但是，目前主项目中使用的是 Objective-C 做开发，而 Objective-C 下是不支持给协议添加默认实现的。调研一番后，找到了合适的解决方案—— <code>PKProtocolExtension</code> 。</p>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p><code>PKProtocolExtension.h</code> 中的内容如下：</p>
<a id="more"></a>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// For a magic reserved keyword color, use @defs(your_protocol_name)</span></div><div class="line"><span class="meta">#define defs _pk_extension</span></div><div class="line"></div><div class="line"><span class="comment">// Interface</span></div><div class="line"><span class="meta">#define _pk_extension($protocol) _pk_extension_imp($protocol, _pk_get_container_class($protocol))</span></div><div class="line"></div><div class="line"><span class="comment">// Implementation</span></div><div class="line"><span class="meta">#define _pk_extension_imp($protocol, $container_class) \</span></div><div class="line">    protocol $protocol; \</div><div class="line">    <span class="class"><span class="keyword">@interface</span> $<span class="title">container_class</span> : <span class="title">NSObject</span> &lt;$<span class="title">protocol</span>&gt; @<span class="title">end</span> \</span></div><div class="line">    <span class="class"><span class="keyword">@implementation</span> $<span class="title">container_class</span> \</span></div><div class="line">    + (<span class="keyword">void</span>)load &#123; \</div><div class="line">        _pk_extension_load(<span class="class"><span class="keyword">@protocol</span>($<span class="title">protocol</span>), $<span class="title">container_class</span>.<span class="title">class</span>); \</span></div><div class="line">    &#125; \</div><div class="line"></div><div class="line"><span class="comment">// Get container class name by counter</span></div><div class="line"><span class="meta">#define _pk_get_container_class($protocol) _pk_get_container_class_imp($protocol, __COUNTER__)</span></div><div class="line"><span class="meta">#define _pk_get_container_class_imp($protocol, $counter) _pk_get_container_class_imp_concat(__PKContainer_, $protocol, $counter)</span></div><div class="line"><span class="meta">#define _pk_get_container_class_imp_concat($a, $b, $c) $a ## $b ## _ ## $c</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> _pk_extension_load(Protocol *protocol, Class containerClass);</div></pre></td></tr></table></figure>
<p>首先是定义了保留关键字 <code>@defs</code> 来封装真正的实现宏。<code>defs</code> 、 <code>_pk_extension($protocol)</code> 、 <code>_pk_extension_imp($protocol, $container_class)</code> 三个宏组合后的作用是创建自定义的容器类，然后实现协议的方法，这些实现即为该协议的默认实现。而容器类的名字则是由 <code>_pk_get_container_class($protocol)</code> 、 <code>_pk_get_container_class_imp($protocol, $counter)</code> 和 <code>_pk_get_container_class_imp_concat($a, $b, $c)</code> 三个宏来决定。这里面的 <code>__COUNTER__</code> 是累加数字宏，默认是 0 ，每调用一次，就会在之前的结果上加一。 <code>##</code> 是连接符，将符号两边的参数连接起来，如果有一个参数为空，它会自动把空余的部分吃掉。以上面的代码为例，如果 $b 为空，则实际的字符串为 $a_$c 。</p>
<p>为了更直观地看到宏的作用，我们来写一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Protocol</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Forkable</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)fork;</div><div class="line"></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (<span class="built_in">NSString</span> *)github;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Protocol Extension</span></div><div class="line"></div><div class="line"><span class="keyword">@defs</span>(Forkable)</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)fork &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Forkable protocol extension: I'm forking (%@)."</span>, <span class="keyword">self</span>.github);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)github &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"This is a required method, concrete class must override me."</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>展开宏定义后如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Protocol</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Forkable</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)fork;</div><div class="line"></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (<span class="built_in">NSString</span> *)github;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Protocol Extension</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Forkable</span>; @<span class="title">interface</span> <span class="title">__PKContainer_Forkable_0</span> : <span class="title">NSObject</span> &lt;<span class="title">Forkable</span>&gt; @<span class="title">end</span> </span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">__PKContainer_Forkable_0</span> + (<span class="title">void</span>)<span class="title">load</span> </span>&#123; _pk_extension_load(<span class="class"><span class="keyword">@protocol</span>(<span class="title">Forkable</span>), <span class="title">__PKContainer_Forkable_0</span>.<span class="title">class</span>); &#125;</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)fork &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Forkable protocol extension: I'm forking (%@)."</span>, <span class="keyword">self</span>.github);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)github &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">@"This is a required method, concrete class must override me."</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="提取协议方法及实现"><a href="#提取协议方法及实现" class="headerlink" title="提取协议方法及实现"></a>提取协议方法及实现</h4><p>从宏定义预编译之后的代码可以看出，核心方法是 <code>_pk_extension_load</code> 。该方法的作用是将容器类遵循的协议方法和实现保存到一个全局数组 <code>allExtendedProtocols</code> 中，数组元素的类型定义为一个结构体 <code>PKExtendedProtocol</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    Protocol *__unsafe_unretained protocol;</div><div class="line">    Method *instanceMethods;</div><div class="line">    <span class="keyword">unsigned</span> instanceMethodCount;</div><div class="line">    Method *classMethods;</div><div class="line">    <span class="keyword">unsigned</span> classMethodCount;</div><div class="line">&#125; PKExtendedProtocol;</div></pre></td></tr></table></figure>
<p>提取的逻辑处理则是依赖于 <code>_pk_extension_create_merged</code> 和 <code>_pk_extension_merge</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Method *_pk_extension_create_merged(Method *existMethods, <span class="keyword">unsigned</span> existMethodCount, Method *appendingMethods, <span class="keyword">unsigned</span> appendingMethodCount) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (existMethodCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> appendingMethods;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">unsigned</span> mergedMethodCount = existMethodCount + appendingMethodCount;</div><div class="line">    Method *mergedMethods = malloc(mergedMethodCount * <span class="keyword">sizeof</span>(Method));</div><div class="line">    memcpy(mergedMethods, existMethods, existMethodCount * <span class="keyword">sizeof</span>(Method));</div><div class="line">    memcpy(mergedMethods + existMethodCount, appendingMethods, appendingMethodCount * <span class="keyword">sizeof</span>(Method));</div><div class="line">    <span class="keyword">return</span> mergedMethods;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> _pk_extension_merge(PKExtendedProtocol *extendedProtocol, Class containerClass) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// Instance methods</span></div><div class="line">    <span class="keyword">unsigned</span> appendingInstanceMethodCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 获取宿主类实现的协议方法列表</span></div><div class="line">    Method *appendingInstanceMethods = class_copyMethodList(containerClass, &amp;appendingInstanceMethodCount);</div><div class="line">    </div><div class="line">    Method *mergedInstanceMethods = _pk_extension_create_merged(extendedProtocol-&gt;instanceMethods,</div><div class="line">                                                                extendedProtocol-&gt;instanceMethodCount,</div><div class="line">                                                                appendingInstanceMethods,</div><div class="line">                                                                appendingInstanceMethodCount);</div><div class="line">    free(extendedProtocol-&gt;instanceMethods);</div><div class="line">    extendedProtocol-&gt;instanceMethods = mergedInstanceMethods;</div><div class="line">    extendedProtocol-&gt;instanceMethodCount += appendingInstanceMethodCount;</div><div class="line">    </div><div class="line">    <span class="comment">// Class methods</span></div><div class="line">    <span class="keyword">unsigned</span> appendingClassMethodCount = <span class="number">0</span>;</div><div class="line">    Method *appendingClassMethods = class_copyMethodList(object_getClass(containerClass), &amp;appendingClassMethodCount);</div><div class="line">    Method *mergedClassMethods = _pk_extension_create_merged(extendedProtocol-&gt;classMethods,</div><div class="line">                                                             extendedProtocol-&gt;classMethodCount,</div><div class="line">                                                             appendingClassMethods,</div><div class="line">                                                             appendingClassMethodCount);</div><div class="line">    free(extendedProtocol-&gt;classMethods);</div><div class="line">    extendedProtocol-&gt;classMethods = mergedClassMethods;</div><div class="line">    extendedProtocol-&gt;classMethodCount += appendingClassMethodCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="注入协议的方法和实现"><a href="#注入协议的方法和实现" class="headerlink" title="注入协议的方法和实现"></a>注入协议的方法和实现</h4><p>成功提取相关协议的方法和实现后，怎么注入并且何时注入到相应的类中呢？我们知道在 main 方法调用之前，所有的类都已经注册到 runtime 中了，那么，在执行 main 方法之前去注入无疑是比较恰当的时机，但是，这个时机又必须得比加载 load 方法晚，否则，还没提取完协议方法，就到了注入环节无疑是不正确的。要完成这个目标，就需要借助于 <code>__attribute__((constructor))</code> 。被该属性修饰过的方法会在 <code>load</code> 方法之后 main 方法之前被调用。我们在注入方法中获取所有注册类，然后循环遍历找到符合条件的类，再将对应的协议方法和实现注入到该类中即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">__attribute__((constructor)) <span class="keyword">static</span> <span class="keyword">void</span> _pk_extension_inject_entry(<span class="keyword">void</span>) &#123;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;protocolsLoadingLock);</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> classCount = <span class="number">0</span>;</div><div class="line">    Class *allClasses = objc_copyClassList(&amp;classCount);</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> protocolIndex = <span class="number">0</span>; protocolIndex &lt; extendedProtcolCount; ++protocolIndex) &#123;</div><div class="line">            PKExtendedProtocol extendedProtcol = allExtendedProtocols[protocolIndex];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> classIndex = <span class="number">0</span>; classIndex &lt; classCount; ++classIndex) &#123;</div><div class="line">                Class <span class="keyword">class</span> = allClasses[classIndex];</div><div class="line">                <span class="keyword">if</span> (!class_conformsToProtocol(<span class="keyword">class</span>, extendedProtcol.protocol)) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                _pk_extension_inject_class(<span class="keyword">class</span>, extendedProtcol);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;protocolsLoadingLock);</div><div class="line">    </div><div class="line">    free(allClasses);</div><div class="line">    free(allExtendedProtocols);</div><div class="line">    extendedProtcolCount = <span class="number">0</span>, extendedProtcolCapacity = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _pk_extension_inject_class(Class targetClass, PKExtendedProtocol extendedProtocol) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>; methodIndex &lt; extendedProtocol.instanceMethodCount; ++methodIndex) &#123;</div><div class="line">        Method method = extendedProtocol.instanceMethods[methodIndex];</div><div class="line">        SEL selector = method_getName(method);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (class_getInstanceMethod(targetClass, selector)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        IMP imp = method_getImplementation(method);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</div><div class="line">        class_addMethod(targetClass, selector, imp, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Class targetMetaClass = object_getClass(targetClass);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>; methodIndex &lt; extendedProtocol.classMethodCount; ++methodIndex) &#123;</div><div class="line">        Method method = extendedProtocol.classMethods[methodIndex];</div><div class="line">        SEL selector = method_getName(method);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (selector == <span class="keyword">@selector</span>(load) || selector == <span class="keyword">@selector</span>(initialize)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (class_getInstanceMethod(targetMetaClass, selector)) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        IMP imp = method_getImplementation(method);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</div><div class="line">        class_addMethod(targetMetaClass, selector, imp, types);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>protocolExtension</code> 依赖于 <code>runtime</code> ，在 <code>load</code> 方法执行之后向已经在 <code>runtime</code> 中注册类中挑选合适的类进行注入操作。但是，这种做法本身也有一些值得商榷的地方，比如，在注入方法中遍历所有已注册的类的操作，本身就是耗时操作，会影响 App 的启动速度。有想过使用 <code>runtime</code> 的消息转发机制来进行懒加载，但是，这么做的问题在于如果某个实现子类重写了消息转发机制的相关方法，并且没有调用父类的相关方法，则该类的注入操作便会失败。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[反射如何工作]]></title>
      <url>https://iiiceblink.github.io/2018/10/22/HowMirrorWorks/</url>
      <content type="html"><![CDATA[<p>原文地址 <a href="https://swift.org/blog/how-mirror-works/?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more" target="_blank" rel="external">https://swift.org/blog/how-mirror-works/?utm_source=mybridge&amp;utm_medium=blog&amp;utm_campaign=read_more</a></p>
<p>虽然 swift 是一门特别强调静态类型的语言，但是它同时也支持丰富的元数据类型，也就是说允许在运行时检查代码和操作任意值。这种特性通过 <code>Mirror</code> API 暴露给开发人员。你可能会很好奇，<code>Mirror</code> 是如何在如此强调静态类型的语言中工作的？让我们来一探究竟。</p>
<h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3><p>接下来所讲得内容是内部实现的细节，所涉及的代码是在当前版本中的写法，在将来可能会发生改变。当 ABI 稳定后，元数据将变成固定和可信赖的格式，但是现在它仍会发生改变。如果你写常规的 swift 代码，不要依赖于元数据。如果你要编写的代码所要实现的是比 <code>Mirror</code> API 所提供的更复杂的反射机制的话，本篇文章将会启发你它们是如何一起配合的，但是要记住所有一切在未来都可能发生改变。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><code>Mirror(reflecting:)</code> 初始化器得参数接受任意值。返回的 <code>Mirror</code> 实例提供关于这个值的信息，主要是它所包含的子项。每个子项包含一个值和一个可选的标签。然后，你就可以在不需要知道编译时的任何类型信息的情况下，使用 <code>Mirror</code> 去遍历一个对象的所有子项。</p>
<p><code>Mirror</code> 允许类型在遵守 <code>CustomReflectable</code> 协议的条件下，提供自定义的表现。这种特性对于那些希望展示比从内省中获得更多信息的类来说是特别有用的。例如，<code>Array</code> 遵守 <code>CustomReflectable</code> 协议并且将所有的元素暴露为未标签化的子项。 <code>Dictionary</code> 使用这种特性将所有的键值对暴露为标签化的子项。</p>
<p>对于所有其他的类型而言， <code>Mirror</code> 在值的真实内容基础上做了一些魔法操作生成一列子项。对于结构体和类而言，它将存储的属性作为子项展示。对于元组而言，它展示的是元组的元素。枚举则是展示每种情况和其对应的值（如果有的话）。</p>
<p>黑魔法是如何工作的？让我们来看一看。</p>
<a id="more"></a>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>反射 API 是由 swift 和 c++ 一起实现的。swift 在实现 swift 式的接口和使得很多任务更容易的方面更合适。更底层的 swift 运行时是由 c++ 实现的，并且从 swift 直接访问那些 c++ 类是不可能的，因此 C 语言层用来连接这两者。swift 层面的实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/ReflectionMirror.swift" target="_blank" rel="external">ReflectionMirror.swift</a> ， c++ 层面的实现在 <a href="https://github.com/apple/swift/blob/master/stdlib/public/runtime/ReflectionMirror.mm" target="_blank" rel="external">ReflectionMirror.mm</a> 。</p>
<p>这两者通过暴露给 swift 的很小的 c++ 函数集合来相互沟通。它们不用 swift 内置的 C 桥接，而是用一个指令去声明 swift，这个指令会指定一个自定义的符号名称。然后， swift 可以直接调用与该符号名称相关联的 c++ 函数。虽然这个特性允许两者可以直接沟通而不需要担心桥接器背后到底对值做了什么，但是，它要求我们要正确了解 swift 是如何传递参数和返回值的。除非你的代码在运行时需要它，否则不要轻易尝试。</p>
<p>接下来我们来举例说明，我们来看一下 <code>ReflectionMirror.swift</code> 中的 <code>_getChildCount</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></div></pre></td></tr></table></figure>
<p><code>@_silgen_name</code> 属性告诉 swift 编译器将这个函数映射为 <code>swift_reflectionMirror_count</code> 的符号，而不是常规的 <code>_getChildCount</code> 符号。注意，该属性一开始的下划线表示该属性是由标准库保留。在 c++ 层面，函数看起来像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">SWIFT_CC</span>(swift) <span class="type">SWIFT_RUNTIME_STDLIB_INTERFACE</span></div><div class="line">intptr_t swift_reflectionMirror_count(<span class="type">OpaqueValue</span> *value,</div><div class="line">                                      const <span class="type">Metadata</span> *type,</div><div class="line">                                      const <span class="type">Metadata</span> *<span class="type">T</span>) &#123;</div></pre></td></tr></table></figure>
<p><code>SWIFT_CC(swift)</code> 告诉编译器该函数使用 swift 调用规则而不是 c/c++ 调用规则。 <code>SWIFT_RUNTIME_STDLIB_INTERFACE</code> 标记该函数为 swift 层面接口中的一部分，并且具有与 <code>extern &quot;C&quot;</code> 一样的作用，那就是避免 c++ 名字改编并且确保这个函数的符号名称是 swift 所期望的。仔细安排 C++ 参数以匹配基于 Swift 声明调用此函数的方式。当 swift 代码调用 <code>_getChildCount</code> 时，c++ 函数会被调用，并且会伴随三个参数，一个指向 swift 值指针的 value , 一个包含值的类型参数的 type ，以及类型 T 。</p>
<p><code>Mirror</code> 中包含的 swift 和 c++ 之间的所有接口如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_normalizedType"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getNormalizedType</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Any</span>.<span class="type">Type</span></div><div class="line"></div><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_count"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChildCount</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T, type: Any.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">Int</span></div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="keyword">typealias</span> <span class="type">NameFreeFunc</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">CChar</span>&gt;?) -&gt; <span class="type">Void</span></div><div class="line"></div><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_subscript"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getChild</span>&lt;T&gt;<span class="params">(</span></span></div><div class="line">  of: T,</div><div class="line">  type: Any.<span class="keyword">Type</span>,</div><div class="line">  index: Int,</div><div class="line">  outName: UnsafeMutablePointer&lt;UnsafePointer&lt;CChar&gt;?&gt;,</div><div class="line">  outFreeFunc: UnsafeMutablePointer&lt;NameFreeFunc?&gt;</div><div class="line">) -&gt; <span class="type">Any</span></div><div class="line"></div><div class="line"><span class="comment">// Returns 'c' (class), 'e' (enum), 's' (struct), 't' (tuple), or '\0' (none)</span></div><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_displayStyle"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getDisplayStyle</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">CChar</span></div><div class="line"></div><div class="line">@_silgen_name(<span class="string">"swift_reflectionMirror_quickLookObject"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_getQuickLookObject</span>&lt;T&gt;<span class="params">(<span class="number">_</span>: T)</span></span> -&gt; <span class="type">AnyObject</span>?</div><div class="line"></div><div class="line">@_silgen_name(<span class="string">"_swift_stdlib_NSObject_isKindOfClass"</span>)</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">_isImpl</span><span class="params">(<span class="number">_</span> object: AnyObject, kindOf: AnyObject)</span></span> -&gt; <span class="type">Bool</span></div></pre></td></tr></table></figure>
<h3 id="奇怪的动态分发"><a href="#奇怪的动态分发" class="headerlink" title="奇怪的动态分发"></a>奇怪的动态分发</h3><p>没有单一通用的获取任何类型信息的方式。元组、结构体、类以及枚举等在众多的任务中都需要不同的代码，比如，查询它们子项的数目。当然还有很多更微妙的地方，比如，swift 和 Objective-C 类的不同处理方式。</p>
<p>所有这些函数都需要基于检查后的类型来分发不同实现的代码。这听起来很像方法的动态分发，不过，选择哪个实现去调用比检查对象的类和被使用的方法要更复杂。反射代码尝试通过 c++ 动态分发的方式，即以包含以上接口的 c++ 版本的抽象基类和一簇包含所有不同情况的子类来简化工作。单一的函数将一个 swift 类型转换成那些 c++ 类中某个类的实例。调用该实例的方法便会去调度对应的实现。</p>
<p>映射方法被称为 <code>call</code> 并且它的声明如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">template&lt;typename <span class="type">F</span>&gt;</div><div class="line">auto call(<span class="type">OpaqueValue</span> *passedValue, const <span class="type">Metadata</span> *<span class="type">T</span>, const <span class="type">Metadata</span> *passedType,</div><div class="line">          const <span class="type">F</span> &amp;f) -&gt; decltype(f(nullptr))</div></pre></td></tr></table></figure>
<p><code>passedValue</code> 是一个指向实际传入的 swift 值的指针， T 是该值的静态类型，与 swift 层面的泛型参数 <t> 相对应。 <code>passedType</code> 是在 swift 端显示传入的并会被用在真正反射的那一步。当使用父类 <code>Mirror</code> 作为子类的实例时，此类型将与对象的实际运行时类型不同。最后， f 参数是会被用到的，它传入的是该函数查找的实现对象的引用。当该函数被调用时， f 返回的是什么，该函数就会返回什么，这样使得用户更容易获取到返回值。</t></p>
<p><code>call</code> 的实现并没有太惊艳的地方。它主要是使用 switch 条件语句以及额外的代码来处理特殊情况。重要的一点是它最终会调用 f 和 <code>ReflectionMirrorImpl</code> 子类的实例，这个实例会调用它的实例方法来完成真正的工作。</p>
<p>下面是 <code>ReflectionMirrorImpl</code> 的结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReflectionMirrorImpl</span> </span>&#123;</div><div class="line">  const <span class="type">Metadata</span> *type;</div><div class="line">  <span class="type">OpaqueValue</span> *value;</div><div class="line"></div><div class="line">  virtual char displayStyle() = <span class="number">0</span>;</div><div class="line">  virtual intptr_t <span class="built_in">count</span>() = <span class="number">0</span>;</div><div class="line">  virtual <span class="type">AnyReturn</span> <span class="keyword">subscript</span>(intptr_t index, const char **outName,</div><div class="line">                              void (**outFreeFunc)(const char *)) = <span class="number">0</span>;</div><div class="line">  virtual const char *enumCaseName() &#123; <span class="keyword">return</span> nullptr; &#125;</div><div class="line"></div><div class="line">#<span class="keyword">if</span> <span class="type">SWIFT_OBJC_INTEROP</span></div><div class="line">  virtual id quickLookObject() &#123; <span class="keyword">return</span> <span class="literal">nil</span>; &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">  virtual ~<span class="type">ReflectionMirrorImpl</span>() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那些作为 swift 和 c++ 组件之间的接口来服务的函数会调用 <code>call</code> 来触发对应的方法。例如，下面是 <code>swift_reflectionMirror_count</code> 的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">SWIFT_CC</span>(swift) <span class="type">SWIFT_RUNTIME_STDLIB_INTERFACE</span></div><div class="line">intptr_t swift_reflectionMirror_count(<span class="type">OpaqueValue</span> *value,</div><div class="line">                                      const <span class="type">Metadata</span> *type,</div><div class="line">                                      const <span class="type">Metadata</span> *<span class="type">T</span>) &#123;</div><div class="line">  <span class="keyword">return</span> call(value, <span class="type">T</span>, type, [](<span class="type">ReflectionMirrorImpl</span> *impl) &#123;</div><div class="line">    <span class="keyword">return</span> impl-&gt;<span class="built_in">count</span>();</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元组反射"><a href="#元组反射" class="headerlink" title="元组反射"></a>元组反射</h3><p>让我们开始元组反射的内容，这也许是最简单的部分。它通过返回 t 来标志其为元组来开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TupleImpl</span> : <span class="title">ReflectionMirrorImpl</span> </span>&#123;</div><div class="line">  char displayStyle() &#123;</div><div class="line">    <span class="keyword">return</span> 't';</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>使用像这样的硬编码常量是不正常的，但是考虑到 c++ 和 swift 都有一个地方引用这个值，并且它们之间不通过桥接来沟通，因而这是个靠谱的选择。</p>
<p>接下来是 <code>count</code> 方法。现在我们已经知道了 <code>type</code> 真正的是 <code>TupleTypeMetadata *</code> 类型而不是 <code>Metadata *</code> 类型。<code>TupleTypeMetadata</code> 有一个 <code>TupleTypeMetadata</code> 字段，该字段保存元组中元素的个数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">intptr_t</span> count() &#123;</div><div class="line">  <span class="keyword">auto</span> *Tuple = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TupleTypeMetadata *&gt;(type);</div><div class="line">  <span class="keyword">return</span> Tuple-&gt;NumElements;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>subscript</code> 方法作用更多一点。它同样使用 <code>static_cast</code> 开始：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AnyReturn subscript(intptr_t i, const char **outName,</div><div class="line">                    void (**outFreeFunc)(const char *)) &#123;</div><div class="line">  auto *Tuple = static_cast&lt;const TupleTypeMetadata *&gt;(type);</div></pre></td></tr></table></figure>
<p>接下来，通过边界检查来确保调用者访问的索引是元组所包含的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span> || (<span class="keyword">size_t</span>)i &gt; Tuple-&gt;NumElements)</div><div class="line">  swift::crash(<span class="string">"Swift mirror subscript bounds check failure"</span>);</div></pre></td></tr></table></figure>
<p><code>subscriptd</code> 有两个工作：获取值和对应的名称。对于一个结构体或者类而言，名称是存储的属性的名字。对于元组而言，名称是元组某个元素的标签或者是数字索引(如果没有标签的话)。</p>
<p>标签以空格分割存储在元数据的 <code>Labels</code> 字段中。下面的代码是追踪列表中第 i 个字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Determine whether there is a label.</span></div><div class="line"><span class="keyword">bool</span> hasLabel = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">char</span> *labels = Tuple-&gt;Labels) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">intptr_t</span> j = <span class="number">0</span>; j != i &amp;&amp; space; ++j) &#123;</div><div class="line">    labels = space + <span class="number">1</span>;</div><div class="line">    space = <span class="built_in">strchr</span>(labels, <span class="string">' '</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If we have a label, create it.</span></div><div class="line">  <span class="keyword">if</span> (labels &amp;&amp; space &amp;&amp; labels != space) &#123;</div><div class="line">    *outName = strndup(labels, space - labels);</div><div class="line">    hasLabel = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有标签，则生成对应的数字名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!hasLabel) &#123;</div><div class="line">  <span class="comment">// The name is the stringized element number '.0'.</span></div><div class="line">  <span class="keyword">char</span> *str;</div><div class="line">  asprintf(&amp;str, <span class="string">".%"</span> PRIdPTR, i);</div><div class="line">  *outName = str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我们使用的是 swift 和 c++ 混编，因而我们无法做到自动内存管理。虽然 swift 有 ARC 而 c++ 有 RAII ，但是两者无法相处。 <code>outFreeFunc</code> 允许 c++ 代码向调用者提供用来释放返回名称的函数。标签需要通过 <code>free</code> 来释放，因而下面的代码便是据此来设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*outFreeFunc = [](<span class="keyword">const</span> <span class="keyword">char</span> *str) &#123; <span class="built_in">free</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(str)); &#125;;</div></pre></td></tr></table></figure>
<p>令人惊讶的是值的获取更容易。元组元数据包含一个返回指定索引指向元素的信息的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> &amp;elt = Tuple-&gt;getElement(i);</div></pre></td></tr></table></figure>
<p><code>elt</code> 包含一个偏移量，该值可以应用到元组元素值上来获取指向该元素值的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(value);</div><div class="line"><span class="keyword">auto</span> *eltData = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> OpaqueValue *&gt;(bytes + elt.Offset);</div></pre></td></tr></table></figure>
<p>此外， <code>elt</code> 包含元素的类型。通过该类型和指向该值的指针，使得构建包含该值的新的 <code>Any</code> 成为了可能。类型包含了一些函数指针，这些指针主要用来分配和初始化存储。下面的代码使用那些函数将值拷贝到 <code>Any</code> 中，然后返回它给调用者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    Any result;</div><div class="line"></div><div class="line">    result.Type = elt.Type;</div><div class="line">    <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</div><div class="line">    result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</div><div class="line">                                       <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(eltData));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AnyReturn(result);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="swift-getFieldAt"><a href="#swift-getFieldAt" class="headerlink" title="swift_getFieldAt"></a>swift_getFieldAt</h3><p>查找结构体、类和枚举中的元素是非常复杂的。它的复杂性在于缺少在这些类型和字段描述符（包含类型信息）之间的直接引用。 <code>swift_getFieldAt</code> 辅助函数根据给定的类型去查找对应的字段描述符。一旦我们添加了直接引用，这个函数应当消失，然而，同时，它提供了一个有趣的视角来观察运行时代码是如何能够使用语言的元数据来查找类型信息。</p>
<p>函数原型看起来像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> swift::_swift_getFieldAt(</div><div class="line">    <span class="keyword">const</span> Metadata *base, <span class="keyword">unsigned</span> index,</div><div class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(llvm::StringRef name, FieldType fieldInfo)&gt;</div><div class="line">        callback) &#123;</div></pre></td></tr></table></figure>
<p>它包含了检查的类型和要查找的字段索引。它还包含了一个在查找信息时会被触发的回调。</p>
<p>第一个任务是获取该类型的类型上下文描述符，它包含了该类型的额外信息，之后会被用到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> *baseDesc = base-&gt;getTypeContextDescriptor();</div><div class="line"><span class="keyword">if</span> (!baseDesc)</div><div class="line">  <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>这个工作会被拆分为两个部分。首先，它会查找类型的字段描述符。字段描述符包含了该类型的字段的所有信息。一旦字段描述符可以被获取，该方法就可以从描述符中查找到必要的信息。</p>
<p>从描述符中查找信息的功能被封装到叫做 <code>getFieldAt</code> 的辅助函数中。其他代码在搜索适当的字段描述符时可以从各个地方调用。让我们开始搜索。首先是获取一个 <code>demangler</code> ，它的作用是将支离破碎的类型名称转换成实际的类型引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> dem = getDemanglerForRuntimeTypeResolution();</div></pre></td></tr></table></figure>
<p>它还包含缓存来加速多搜索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> &amp;cache = FieldCache.get();</div></pre></td></tr></table></figure>
<p>如果缓存已经包含了字段描述符，那就调用 <code>getFieldAt</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Value = cache.FieldCache.find(base)) &#123;</div><div class="line">  getFieldAt(*Value-&gt;getDescription());</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了使搜索的代码更加简单，这里提供一个辅助函数。它包含了 <code>FieldDescriptor</code> 参数，并且来检查它是否是要搜索的那个。如果描述符匹配上了，它将描述符放入到缓存中，调用 <code>getFieldAt</code> 函数，然后给调用者返回成功。匹配是一个复杂的过程，但是可以归结为比较错名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> isRequestedDescriptor = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</div><div class="line">  assert(descriptor.hasMangledTypeName());</div><div class="line">  <span class="keyword">auto</span> mangledName = descriptor.getMangledTypeName(<span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!_contextDescriptorMatchesMangling(baseDesc,</div><div class="line">                                         dem.demangleType(mangledName)))</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">  cache.FieldCache.getOrInsert(base, &amp;descriptor);</div><div class="line">  getFieldAt(descriptor);</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div></pre></td></tr></table></figure>
<p>字段描述符可以在运行时注册或者在编译时打成二进制数据。这两种方式会循环搜索所有已知的字段描述符来进行匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;section : cache.DynamicSections.snapshot()) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *descriptor : section) &#123;</div><div class="line">    <span class="keyword">if</span> (isRequestedDescriptor(*descriptor))</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;section : cache.StaticSections.snapshot()) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;descriptor : section) &#123;</div><div class="line">    <span class="keyword">if</span> (isRequestedDescriptor(descriptor))</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果最后没有找到匹配的，那么就打印一个警告，并且触发一个附带空元组的回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">auto</span> typeName = swift_getTypeName(base, <span class="comment">/*qualified*/</span> <span class="literal">true</span>);</div><div class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to find field metadata for type '%*s'\n"</span>,</div><div class="line">             (<span class="keyword">int</span>)typeName.length, typeName.data);</div><div class="line">  callback(<span class="string">"unknown"</span>,</div><div class="line">           FieldType()</div><div class="line">             .withType(TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;))</div><div class="line">             .withIndirect(<span class="literal">false</span>)</div><div class="line">             .withWeak(<span class="literal">false</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>刚才的方法是负责搜索字段描述符。 <code>getFieldAt</code> 将字段描述符转换成名称和字段类型，然后传递给回调。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> getFieldAt = [&amp;](<span class="keyword">const</span> FieldDescriptor &amp;descriptor) &#123;</div><div class="line">  <span class="keyword">auto</span> &amp;field = descriptor.getFields()[index];</div></pre></td></tr></table></figure>
<p>名称可以直接从记录中获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> name = field.getFieldName(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>如果字段是枚举的情况，它可能不会有类型。先检查它的类型然后触发响应回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!field.hasMangledTypeName()) &#123;</div><div class="line">  callback(name, FieldType().withIndirect(field.isIndirectCase()));</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字段记录存储字段类型作为错名。回调期望得到一个指向元数据的指针，因而，错名会被修改为真正的类型。 <code>_getTypeByMangledName</code> 函数处理大部分的工作，但是它要求调用者去处理被该类型所使用到的任意泛型。这要求把类型中嵌套的所有泛型上下文抽出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> ContextDescriptor *&gt; descriptorPath;</div><div class="line">&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> *parent = <span class="keyword">reinterpret_cast</span>&lt;</div><div class="line">                          <span class="keyword">const</span> ContextDescriptor *&gt;(baseDesc);</div><div class="line">  <span class="keyword">while</span> (parent) &#123;</div><div class="line">    <span class="keyword">if</span> (parent-&gt;isGeneric())</div><div class="line">      descriptorPath.push_back(parent);</div><div class="line"></div><div class="line">    parent = parent-&gt;Parent.get();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在获取错名和类型，通过 lambda 传入来解决泛型参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> typeName = field.getMangledTypeName(<span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> typeInfo = _getTypeByMangledName(</div><div class="line">    typeName,</div><div class="line">    [&amp;](<span class="keyword">unsigned</span> depth, <span class="keyword">unsigned</span> index) -&gt; <span class="keyword">const</span> Metadata * &#123;</div></pre></td></tr></table></figure>
<p>如果请求的深度已经超过了描述符路径的大小，那就会失败：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (depth &gt;= descriptorPath.size())</div><div class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</div></pre></td></tr></table></figure>
<p>否则，从包含字段的类型中获取泛型参数。这要求将索引和深度转换成单一的胖索引，这个工作通过遍历描述符路径和将每个点上的泛型参数个数的值增加，直到给定的路径到达了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> currentDepth = <span class="number">0</span>;</div><div class="line"><span class="keyword">unsigned</span> flatIndex = index;</div><div class="line"><span class="keyword">const</span> ContextDescriptor *currentContext = descriptorPath.back();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *context : llvm::reverse(descriptorPath)) &#123;</div><div class="line">  <span class="keyword">if</span> (currentDepth &gt;= depth)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"></div><div class="line">  flatIndex += context-&gt;getNumGenericParams();</div><div class="line">  currentContext = context;</div><div class="line">  ++currentDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果索引在给定的路径上超过了可获取的泛型参数，那会失败：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (index &gt;= currentContext-&gt;getNumGenericParams())</div><div class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</div></pre></td></tr></table></figure>
<p>否则，从基本类型中获取合适的泛型参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">return</span> base-&gt;getGenericArgs()[flatIndex];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>像之前那样，如果类型无法找到，使用空的元组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (typeInfo == <span class="literal">nullptr</span>) &#123;</div><div class="line">  typeInfo = TypeInfo(&amp;METADATA_SYM(EMPTY_TUPLE_MANGLING), &#123;&#125;);</div><div class="line">  warning(<span class="number">0</span>, <span class="string">"SWIFT RUNTIME BUG: unable to demangle type of field '%*s'. "</span></div><div class="line">             <span class="string">"mangled type name is '%*s'\n"</span>,</div><div class="line">             (<span class="keyword">int</span>)name.size(), name.data(),</div><div class="line">             (<span class="keyword">int</span>)typeName.size(), typeName.data());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，带着找到的类型去触发回调：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  callback(name, FieldType()</div><div class="line">                     .withType(typeInfo)</div><div class="line">                     .withIndirect(field.isIndirectCase())</div><div class="line">                     .withWeak(typeInfo.isWeak()));</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>结构体的实现是类似的，但更复杂一点。有些结构类型根本不支持反射，在结构体中查找名称和偏移需要花费更多精力，结构体可以包含反射代码需要能够提取的弱引用。</p>
<p>首先有一个辅助函数用来检查该结构体是否支持反射。这被存储在一个 flag 中，可以通过访问结构体元数据来得到它。与上面的元组代码类似，我们知道 <code>type</code> 实际上是 <code>StructMetadata *</code> ，因而我们可以转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> StructImpl : ReflectionMirrorImpl &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isReflectable</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;Description = Struct-&gt;getDescription();</div><div class="line">    <span class="keyword">return</span> Description-&gt;getTypeContextDescriptorFlags().isReflectable();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>结构体的显示类型为 s ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">displayStyle</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'s'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子项的数目被元数据所记录的字段的数目，如果该类型不支持反射，则会返回 0 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">intptr_t</span> count() &#123;</div><div class="line">  <span class="keyword">if</span> (!isReflectable()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> *Struct = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> StructMetadata *&gt;(type);</div><div class="line">  <span class="keyword">return</span> Struct-&gt;getDescription()-&gt;NumFields;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像之前那样， <code>subscript</code> 方法是比较复杂的部分。它的开始很类似，做边界检查然后查找偏移量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AnyReturn subscript(intptr_t i, const char **outName,</div><div class="line">                    void (**outFreeFunc)(const char *)) &#123;</div><div class="line">  auto *Struct = static_cast&lt;const StructMetadata *&gt;(type);</div><div class="line"></div><div class="line">  if (i &lt; 0 || (size_t)i &gt; Struct-&gt;getDescription()-&gt;NumFields)</div><div class="line">    swift::crash("Swift mirror subscript bounds check failure");</div><div class="line"></div><div class="line">  // Load the offset from its respective vector.</div><div class="line">  auto fieldOffset = Struct-&gt;getFieldOffsets()[i];</div></pre></td></tr></table></figure>
<p>获取结构体字段的类型信息更复杂一点。这个工作通过 <code>_swift_getFieldAt</code> 函数来完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Any result;</div><div class="line"></div><div class="line">_swift_getFieldAt(type, i, [&amp;](llvm::StringRef name, FieldType fieldInfo) &#123;</div></pre></td></tr></table></figure>
<p>一旦它有字段信息，接下来的流程和元组类似。填写名称并且计算指向字段存储的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*outName = name.data();</div><div class="line">*outFreeFunc = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> *bytes = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(value);</div><div class="line"><span class="keyword">auto</span> *fieldData = <span class="keyword">reinterpret_cast</span>&lt;OpaqueValue *&gt;(bytes + fieldOffset);</div></pre></td></tr></table></figure>
<p>在将字段的值拷贝进 <code>Any</code> 返回值来处理弱引用时还有额外的步骤。 <code>loadSpecialReferenceStorage</code> 函数会处理这些事情。如果它没有加载该值，则该值具有正常存储，并且该值可以正常复制到返回值中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">      <span class="keyword">bool</span> didLoad = loadSpecialReferenceStorage(fieldData, fieldInfo, &amp;result);</div><div class="line">      <span class="keyword">if</span> (!didLoad) &#123;</div><div class="line">        result.Type = fieldInfo.getType();</div><div class="line">        <span class="keyword">auto</span> *opaqueValueAddr = result.Type-&gt;allocateBoxForExistentialIn(&amp;result.Buffer);</div><div class="line">        result.Type-&gt;vw_initializeWithCopy(opaqueValueAddr,</div><div class="line">                                           <span class="keyword">const_cast</span>&lt;OpaqueValue *&gt;(fieldData));</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> AnyReturn(result);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类与结构体类似，<code>ClassImpl</code> 中的代码也大致相同。由于 <code>Objective-c</code> 互操作而需要注意的有两处不同。一个是它有 <code>quickLookObject</code> 的实现，该实现会触发 <code>Objective-c</code> 的 <code>debugQuickLookObject</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if SWIFT_OBJC_INTEROP</span></div><div class="line"><span class="keyword">id</span> quickLookObject() &#123;</div><div class="line">  <span class="keyword">id</span> object = [*reinterpret_cast&lt;<span class="keyword">const</span> <span class="keyword">id</span> *&gt;(value) <span class="keyword">retain</span>];</div><div class="line">  <span class="keyword">if</span> ([object respondsToSelector:<span class="keyword">@selector</span>(debugQuickLookObject)]) &#123;</div><div class="line">    <span class="keyword">id</span> quickLookObject = [object debugQuickLookObject];</div><div class="line">    [quickLookObject <span class="keyword">retain</span>];</div><div class="line">    [object release];</div><div class="line">    <span class="keyword">return</span> quickLookObject;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>另一个则是如果该类是 <code>Objective-c</code> 的子类那么字段偏移量可以在 <code>Objective-c</code> 运行时获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">uintptr_t</span> fieldOffset;</div><div class="line">  <span class="keyword">if</span> (usesNativeSwiftReferenceCounting(Clas)) &#123;</div><div class="line">    fieldOffset = Clas-&gt;getFieldOffsets()[i];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">#<span class="keyword">if</span> SWIFT_OBJC_INTEROP</div><div class="line">    Ivar *ivars = class_copyIvarList((Class)Clas, <span class="literal">nullptr</span>);</div><div class="line">    fieldOffset = ivar_getOffset(ivars[i]);</div><div class="line">    <span class="built_in">free</span>(ivars);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    swift::crash(<span class="string">"Object appears to be Objective-C, but no runtime."</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>在该文件中还有三种实现，大部分都没做什么工作。 <code>ObjCClassImpl</code> 处理 <code>Objective-c</code> 类。它甚至不会尝试返回任何的子项，因为 <code>Objective-c</code> 给 ivar 的内容留下太多的余地。 <code>Objective-c</code> 类允许做一些事情，比如让一个悬垂的指针永远在那里，用一些单独的逻辑告诉实现不要去访问值。尝试返回这样的一个值作为 <code>Mirror</code> 的子项会违反内存安全保证。</p>
<p><code>MetatypeImpl</code> 处理元类型。如果你在确切的类型上使用 <code>Mirror</code> ，比如 <code>Mirror(reflecting: String.self)</code> ，那就使用它。类似的， <code>OpaqueImpl</code> 处理不透明的类型和返回空。</p>
<h3 id="swift-接口"><a href="#swift-接口" class="headerlink" title="swift 接口"></a>swift 接口</h3><p>在 swift 层面， <code>Mirror</code> 调用 c++ 实现的接口函数来获取它需要的信息，然后以友好的形式展现出来。这项工作在 <code>Mirror</code> 的初始化中完成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(internalReflecting subject: <span class="type">Any</span>,</div><div class="line">            subjectType: <span class="type">Any</span>.<span class="type">Type</span>? = <span class="literal">nil</span>,</div><div class="line">            customAncestor: <span class="type">Mirror</span>? = <span class="literal">nil</span>)</div><div class="line">&#123;</div></pre></td></tr></table></figure>
<p><code>subjectType</code> 是将用于反映主体值的类型。这通常是值的运行时类型，但如果调用者使用 <code>superclassMirror</code> 来遍历类层次结构，则它将是超类。如果调用者未传入 <code>subjectType</code> ，则此代码要求 C++ 代码获取主体类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> subjectType = subjectType ?? _getNormalizedType(subject, type: type(of: subject))</div></pre></td></tr></table></figure>
<p>然后通过获取子项的数目来构建 <code>children</code> ，并且创建集合来懒加载每个独立的子项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> childCount = _getChildCount(subject, type: subjectType)</div><div class="line"><span class="keyword">let</span> children = (<span class="number">0</span> ..&lt; childCount).<span class="built_in">lazy</span>.<span class="built_in">map</span>(&#123;</div><div class="line">  getChild(of: subject, type: subjectType, index: $<span class="number">0</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">self</span>.children = <span class="type">Children</span>(children)</div></pre></td></tr></table></figure>
<p><code>getChild</code> 函数是 c++ 函数 <code>_getChild</code> 的封装，该函数主要是将包含标签名称的 C 字符串转换成 swift 的 <code>string</code> 。 </p>
<p><code>Mirror</code> 有一个 <code>superclassMirror</code> 属性，该属性返回一个 <code>Mirror</code> ，用于检查类层次结构中下一个类的属性。在内部，它有一个 <code>_makeSuperclassMirror</code> 属性，该属性存储一个闭包，可以根据需要构造父类 <code>Mirror</code>。该闭包首先获取 <code>subjectType</code> 的父类。没有父类的非类类型和类不能有父类镜像，因此它们为 nil：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>._makeSuperclassMirror = &#123;</div><div class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> subjectClass = subjectType <span class="keyword">as</span>? <span class="type">AnyClass</span>,</div><div class="line">        <span class="keyword">let</span> superclass = _getSuperclass(subjectClass) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>调用者可以指定一个自定义祖先表示，它是一个可以作为父类镜像直接返回的 <code>Mirror</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> customAncestor = customAncestor &#123;</div><div class="line">  <span class="keyword">if</span> superclass == customAncestor.subjectType &#123;</div><div class="line">    <span class="keyword">return</span> customAncestor</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> customAncestor._defaultDescendantRepresentation == .suppressed &#123;</div><div class="line">    <span class="keyword">return</span> customAncestor</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>否则，以相同的值返回一个新 <code>Mirror</code> ，但使用父类作为 <code>subjectType</code> 的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">return</span> <span class="type">Mirror</span>(internalReflecting: subject,</div><div class="line">                subjectType: superclass,</div><div class="line">                customAncestor: customAncestor)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，它获取并且解析展示类型，并且设置 <code>Mirror</code> 保留的属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">let</span> rawDisplayStyle = _getDisplayStyle(subject)</div><div class="line">  <span class="keyword">switch</span> <span class="type">UnicodeScalar</span>(<span class="type">Int</span>(rawDisplayStyle)) &#123;</div><div class="line">  <span class="keyword">case</span> <span class="string">"c"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">class</span></div><div class="line">  <span class="keyword">case</span> <span class="string">"e"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">enum</span></div><div class="line">  <span class="keyword">case</span> <span class="string">"s"</span>: <span class="keyword">self</span>.displayStyle = .<span class="keyword">struct</span></div><div class="line">  <span class="keyword">case</span> <span class="string">"t"</span>: <span class="keyword">self</span>.displayStyle = .tuple</div><div class="line">  <span class="keyword">case</span> <span class="string">"\0"</span>: <span class="keyword">self</span>.displayStyle = <span class="literal">nil</span></div><div class="line">  <span class="keyword">default</span>: <span class="built_in">preconditionFailure</span>(<span class="string">"Unknown raw display style '\(rawDisplayStyle)'"</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">self</span>.subjectType = subjectType</div><div class="line">  <span class="keyword">self</span>._defaultDescendantRepresentation = .generated</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用 KVO 解决 swizzle 失效问题]]></title>
      <url>https://iiiceblink.github.io/2018/09/12/%E5%88%A9%E7%94%A8KVO%E8%A7%A3%E5%86%B3swizzle%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近碰到一个需求，类似于下图所示，几个 <code>UIButton</code> 排列在一起，在某个事件触发时，隐藏或者显示中间的 <code>button</code> ，重点是隐藏中间的 <code>button</code> 时，上下 <code>button</code> 之间的间距保持为原来的间距。比较好的做法是重写 <code>alignmentRectInsets</code> 的 get 方法，当然更新约束的方法也是 OK 的。直接创建子类去重写 <code>alignmentRectInsets</code> 的 get 方法不够优雅，因而想到创建分类， swizzle <code>UIView</code> 的 <code>alignmentRectInsets</code> 的 get 方法，在自己的自定义方法中去完成真正的修改逻辑。</p>
<p><img src="/images/KVOSwizzle/button.gif" alt=""></p>
<p>原以为写完分类，在项目中调用再 run 一下就大功告成了，然而，我还是 naive 啊。运行项目后，发现竟然没有 work ，打断点调试，发现 swizzle method 没有调用。没有调用的原因在于 <code>UIButton</code> 类本身的实现已经重写了 <code>alignmentRectInsets</code> 的 get 方法，所以，不会再调用 <code>UIView</code> 的相同方法了。那怎么办呢？最简单的办法就是给 <code>UIButton</code> 创建分类而不是 <code>UIView</code> ，但是感觉这样写不是很好，有些冗余。</p>
<p>经过一番研究后，想到可以利用 KVO 的机制来解决这个问题。</p>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于 KVO 的具体细节不是本文的重点，如果不是很了解，可以参考<a href="https://www.jianshu.com/p/829864680648" target="_blank" rel="external">这篇文章</a>。这里提一点，苹果在 KVO 的底层实现上，会创建一个子类对象，类名类似于 <code>NSKVONotifying_xxxxx</code> ，并将原来对象的 isa 指针指向这个子类对象。有了这个特性，就可以解决我们之前的问题啦！</p>
<p>那解决的思路是怎么样的呢？主要还是围绕 KVO 会动态创建子类的特性。具体思路可以分为以下几步：</p>
<ol>
<li>让苹果为我们的目标类的对象动态创建子类对象</li>
<li>获取目标对象真正的类</li>
<li>拿到需要 swizzle 的 <code>alignmentRectInsets</code> 方法的函数签名</li>
<li>在 KVO 子类添加该方法和对应的 IMP</li>
</ol>
<p>第一步很简单，只要一个对象观察某个键值，苹果就会为这个对象动态创建子类对象。但这里有个地方需要注意，当某个对象观察某个键值时，需要在该对象 <code>dealloc</code> 方法中移除对该键值的观察，否则，会导致 <code>KVO still registering when deallocated</code> 的 crash 。第二步依赖于第一步中的动态创建的子类对象，调用 <code>class_getSuperclass()</code> 方法来获取目标对象真正的类。第三步承接第二步，知道了目标对象的真正类，则可以拿到 swizzle 的 <code>alignmentRectInsets</code> 的 get 方法的函数签名，这没什么问题。第四步将完整的 <code>selector</code> 、函数签名以及自己实现的 IMP 添加到 KVO 子类的方法列表中即可。</p>
<h3 id="如何解决-KVO-属性移除"><a href="#如何解决-KVO-属性移除" class="headerlink" title="如何解决 KVO 属性移除"></a>如何解决 KVO 属性移除</h3><p>刚才有提到，KVO 观察的键值，需要在对象 <code>dealloc</code> 时移除，但是，在 category 中是无法重写 <code>dealloc</code> 方法的。那怎么解决这个问题呢？我们知道，一个对象 A 持有另一个对象 B ，且 B 仅被 A 持有，那么当对象 A 释放时，也会释放对 B 的持有，也就表示在 A 的 <code>dealloc</code> 触发时，B 的 <code>dealloc</code> 方法也会触发。按照这个思想，我们可以创建一个单例对象作为 <code>observer</code> ，再实例化一个对象 <code>remover</code> 去持有该单例对象，而让目标对象去持有该实例化的对象 <code>remover</code>，在 <code>remover</code> 的 <code>dealloc</code> 方法中执行移除 KVO 键值的操作。当目标对象销毁时，就会释放 <code>remover</code> ，也就会触发 <code>remover</code> 的 <code>dealloc</code> 方法。对这两个类的定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ICFakeKVOObject.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ICFakeKVOObserver</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)shared;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ICFakeKVORemover</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/// unsafe_unretained makes sure that targe can call method in dealloc()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) <span class="keyword">id</span> target;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *keyPath;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ICFakeKVOObject.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"ICFakeKVOObject.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ICFakeKVOObserver</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)shared &#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">id</span> sharedInstance;</div><div class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"></div><div class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">	sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">	&#125;);</div><div class="line">	<span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ICFakeKVORemover</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line"></div><div class="line">	[_target removeObserver:[ICFakeKVOObserver shared] forKeyPath:_keyPath];</div><div class="line">	_target = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>注意，<code>ICFakeKVORemover</code> 中的 target 的修饰符要用 <code>unsafe_unretained</code> 而不能用 <code>weak</code> ，否则，在 <code>dealloc</code> 方法执行时， _target 已经置为 nil 而无法移除键值观察。至于其中的详细细节，可以参考我的另一篇文章<a href="https://iiiceblink.github.io/2017/10/04/Weak%20%E5%B1%9E%E6%80%A7%E5%9C%A8%20dealloc%20%E8%83%8C%E5%90%8E%E7%9A%84%E9%80%BB%E8%BE%91/">Weak 属性在 dealloc 背后的逻辑</a>。这样当 <code>ICFakeKVOObserver</code> 单例对象销毁时，<code>ICFakeKVORemover</code> 对象的 <code>dealloc</code> 方法也会触发。</p>
<h3 id="在-KVO-子类添加-alignmentRectInsets-方法和对应的-IMP"><a href="#在-KVO-子类添加-alignmentRectInsets-方法和对应的-IMP" class="headerlink" title="在 KVO 子类添加 alignmentRectInsets 方法和对应的 IMP"></a>在 KVO 子类添加 <code>alignmentRectInsets</code> 方法和对应的 IMP</h3><p>如何在子类中添加目标方法以及相应的 IMP 已经在上面提过，核心代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/// NSKVONotifying_xxxxx</span></div><div class="line">Class kvoCls = object_getClass(<span class="keyword">self</span>);</div><div class="line"></div><div class="line"><span class="comment">/// original class</span></div><div class="line">Class originCls = class_getSuperclass(kvoCls);</div><div class="line"></div><div class="line"><span class="comment">/// get original type encoding</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *originAlignmentRectInsetsEncoding = method_getTypeEncoding(class_getInstanceMethod(originCls, <span class="keyword">@selector</span>(alignmentRectInsets)));</div><div class="line"></div><div class="line"><span class="comment">/// add IMP for KVO class</span></div><div class="line">class_addMethod(kvoCls, <span class="keyword">@selector</span>(alignmentRectInsets),</div><div class="line">                   (IMP)ic_alignmentRectInsets,</div><div class="line">                   originAlignmentRectInsetsEncoding);</div></pre></td></tr></table></figure>
<p>这里面有个需要注意的点，那就是如何创建符合要求的 <code>IMP</code> ？我们知道 OC 语言的核心在于消息传递，我们调用的方法本质上是会转变成消息发送给目标对象，依据消息中的 <code>selector</code> 找到对应的 <code>IMP</code> ，然后调用它。我们所写的方法实现在经过 clang 编译之后会变成 C 函数，而函数参数也会发生变化。比如 <code>- (void)viewWillAppear:(BOOL)animated</code> 编译后会变成 <code>static void viewWillAppear(UIViewController *self, SEL sel, bool animated)</code> ，其中函数名不变，返回值则会在 OC 和 C 之间做转换，而参数列表则多了两个参数 <code>self</code> 和 <code>sel</code> 分别代表了当前方法的调用者和对应的方法名。编译后的函数实现可以理解为就是真正的 <code>IMP</code> 。那么我们要创建自己的 <code>IMP</code> ，则只需要按照要求在函数参数中加上 <code>self</code> 和 <code>sel</code> 即可。这里的 <code>ic_alignmentRectInsets</code> <code>IMP</code> 代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">UIEdgeInsets</span> ic_alignmentRectInsets(<span class="built_in">UIView</span> *kvo_self, SEL _sel) &#123;</div><div class="line">	</div><div class="line">	Class kvo_cls = object_getClass(kvo_self);</div><div class="line">	Class origin_cls = class_getSuperclass(kvo_cls);</div><div class="line">	</div><div class="line">	IMP origin_imp = method_getImplementation(class_getInstanceMethod(origin_cls, _sel));</div><div class="line">	assert(origin_imp != <span class="literal">NULL</span>);</div><div class="line">	</div><div class="line">  <span class="built_in">UIEdgeInsets</span> (*func)(<span class="built_in">UIView</span> *, SEL) = (<span class="built_in">UIEdgeInsets</span> (*)(<span class="built_in">UIView</span> *, SEL))origin_imp;</div><div class="line">	</div><div class="line">  AlignmentRectInsetsBlock block = kvo_self.yc_alignmentRectInsetsBlock;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (block) &#123;</div><div class="line">      <span class="keyword">return</span> block();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> func(kvo_self, _sel);;</div><div class="line">  &#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写完 category 再调用一下，大功告成！没想到由于 <code>UIButton</code> 的 <code>alignmentRectInsets</code> 在 category 中的失效问题竟然学习到了这么多知识，酥服。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[探究 iOS 11 下的 UIDebuggingInformationOverlay]]></title>
      <url>https://iiiceblink.github.io/2017/11/18/%E6%8E%A2%E7%A9%B6%20iOS%2011%20%E4%B8%8B%E7%9A%84%20UIDebuggingInformationOverlay/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自 iOS 9 以后，Apple 加入了悬浮窗调试工具，也就是 <code>UIDebuggingInformationOverlay</code> 。利用它我们可以做到很多事情，例如：查看视图层级，控制器层级，页面中的变量，测量等等。那么我们如何开启这个调试工具呢？只需要添加如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> overlayClass = <span class="type">NSClassFromString</span>(<span class="string">"UIDebuggingInformationOverlay"</span>) <span class="keyword">as</span>? <span class="type">UIWindow</span>.<span class="type">Type</span></div><div class="line"><span class="number">_</span> = overlayClass?.perform(<span class="type">NSSelectorFromString</span>(<span class="string">"prepareDebuggingOverlay"</span>))</div><div class="line"><span class="keyword">let</span> overlay = overlayClass?.perform(<span class="type">NSSelectorFromString</span>(<span class="string">"overlay"</span>)).takeUnretainedValue() <span class="keyword">as</span>? <span class="type">UIWindow</span></div><div class="line"><span class="number">_</span> = overlay?.perform(<span class="type">NSSelectorFromString</span>(<span class="string">"toggleVisibility"</span>))</div></pre></td></tr></table></figure>
<p>这段代码的实际意义可以转换成以下两行代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">UIDebuggingInformationOverlay</span> prepareDebuggingOverlay];</div><div class="line">[[<span class="built_in">UIDebuggingInformationOverlay</span> overlay] toggleVisibility];</div></pre></td></tr></table></figure>
<p>调用成功后，我们就能看到悬浮窗的庐山真面目了。</p>
<a id="more"></a>
<p><img src="http://ryanipete.com/blog/assets/images/uidebugginginformationoverlay_0.png" alt=""></p>
<p>然而，在 iOS 11 后，上面的代码就不再 work 了。获取信息后得知是 Apple 添加了验证机制，想以此来确保只有内部的 App 链接到 <code>UIKit</code> 后才可以访问这些私有类。在 iOS 11之后，我们还有办法去使用这种调试工具吗？</p>
<h3 id="内部实现探究"><a href="#内部实现探究" class="headerlink" title="内部实现探究"></a>内部实现探究</h3><p>利用 LLDB 尝试去逆向 <code>-[UIDebuggingInformationOverlay init]</code> ，发现在 iOS 10 下，该方法的实现大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIDebuggingInformationOverlay</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    [<span class="keyword">self</span> _setWindowControlsStatusBarOrientation:<span class="literal">NO</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>使用同样的方法去逆向 iOS 11 下的 <code>-[UIDebuggingInformationOverlay init]</code> ，该方法的实现大致是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIDebuggingInformationOverlay</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">  <span class="keyword">static</span> <span class="built_in">BOOL</span> overlayEnabled = <span class="literal">NO</span>;</div><div class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    overlayEnabled = <span class="built_in">UIDebuggingOverlayIsEnabled</span>();</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">if</span> (!overlayEnabled) &#123; </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">    [<span class="keyword">self</span> _setWindowControlsStatusBarOrientation:<span class="literal">NO</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从如上代码中我们可以看出，Apple 使用 <code>UIDebuggingOverlayIsEnabled()</code> 去验证当前设备是否是内部设备，所以，当我们去调用 <code>[UIDebuggingInformationOverlay new]</code> 时，会返回 <code>nil</code> 。</p>
<h3 id="如何绕过验证机制"><a href="#如何绕过验证机制" class="headerlink" title="如何绕过验证机制"></a>如何绕过验证机制</h3><p>Serek Selander 在 <a href="https://www.raywenderlich.com/177890/swizzling-in-ios-11-with-uidebugginginformationoverlay" target="_blank" rel="external">Swizzling in iOS 11 with UIDebuggingInformationOverlay</a> 文章中给出了他的方案。他的原理是通过 LLDB 找出 <code>dispatch_once</code> 部分代码在内存地址中的范围。<code>dispatch_once</code> 内部实现上是这样一个流程<strong>用 <code>onceToken</code> 的地址与 -1 进行比较，如果包含 -1 ，就表示已经执行过 block 中的代码，不再执行，若不包含 -1 ， 则会去执行 block 中的代码，并将 <code>onceToken</code> 的地址置为 -1（默认初始化为 0）</strong>。他的做法就是找到 <code>mainHandler.onceToken</code> 的内存地址，然后将 -1 写入到该内存地址中。完整的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@import</span> <span class="built_in">UIKit</span>;</div><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="keyword">@import</span> ObjectiveC.runtime; <span class="comment">// you mean ObjectiveC.funtime, ooooooooooooooHHHHHH</span></div><div class="line"></div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wincomplete-implementation"</span></span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"><span class="meta">#pragma mark - Section 0 - Private Declarations</span></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span>()</span></div><div class="line">- (<span class="keyword">void</span>)_setWindowControlsStatusBarOrientation:(<span class="built_in">BOOL</span>)orientation;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"><span class="meta">#pragma mark - Section 1 - FakeWindowClass</span></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FakeWindowClass</span> : <span class="title">UIWindow</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FakeWindowClass</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initSwizzled</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>= [<span class="keyword">super</span> init]) &#123;</div><div class="line">    [<span class="keyword">self</span> _setWindowControlsStatusBarOrientation:<span class="literal">NO</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"><span class="meta">#pragma mark - Section 2 - Initialization</span></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">UIDebuggingInformationOverlayInjector</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</div><div class="line">    <span class="built_in">NSAssert</span>(cls, <span class="string">@"DBG Class is nil?"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// Swizzle code here</span></div><div class="line">    [FakeWindowClass swizzleOriginalSelector:<span class="keyword">@selector</span>(init) withSizzledSelector:<span class="keyword">@selector</span>(initSwizzled) forClass:cls isClassMethod:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> swizzleOriginalSelector:<span class="keyword">@selector</span>(prepareDebuggingOverlay) withSizzledSelector:<span class="keyword">@selector</span>(prepareDebuggingOverlaySwizzled) forClass:cls isClassMethod:<span class="literal">YES</span>];</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)swizzleOriginalSelector:(SEL)originalSelector withSizzledSelector:(SEL)swizzledSelector forClass:(Class)<span class="keyword">class</span> isClassMethod:(<span class="built_in">BOOL</span>)isClassMethod</div><div class="line">&#123;</div><div class="line">  </div><div class="line">  Method originalMethod;</div><div class="line">  Method swizzledMethod;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (isClassMethod) &#123;</div><div class="line">    originalMethod = class_getClassMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">    swizzledMethod = class_getClassMethod([<span class="keyword">self</span> <span class="keyword">class</span>], swizzledSelector);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">    swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], swizzledSelector);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="built_in">NSAssert</span>(originalMethod, <span class="string">@"originalMethod should not be nil"</span>);</div><div class="line">  <span class="built_in">NSAssert</span>(swizzledMethod, <span class="string">@"swizzledMethod should not be nil"</span>);</div><div class="line">  </div><div class="line">  method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"><span class="meta">#pragma mark - Section 3 - prepareDebuggingOverlay</span></div><div class="line"><span class="comment">//*****************************************************************************/</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)prepareDebuggingOverlaySwizzled &#123;</div><div class="line"></div><div class="line">  Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</div><div class="line">  SEL sel = <span class="keyword">@selector</span>(prepareDebuggingOverlaySwizzled);</div><div class="line">  Method m = class_getClassMethod(cls, sel); </div><div class="line"></div><div class="line">  IMP imp =  method_getImplementation(m);</div><div class="line">  <span class="keyword">void</span> (*methodOffset) = (<span class="keyword">void</span> *)((imp + (<span class="keyword">long</span>)<span class="number">27</span>));</div><div class="line">  <span class="keyword">void</span> *returnAddr = &amp;&amp;RETURNADDRESS;</div><div class="line">  </div><div class="line">  __asm__ __volatile__(</div><div class="line">      <span class="string">"pushq  %0\n\t"</span></div><div class="line">      <span class="string">"pushq  %%rbp\n\t"</span></div><div class="line">      <span class="string">"movq   %%rsp, %%rbp\n\t"</span></div><div class="line">      <span class="string">"pushq  %%r15\n\t"</span></div><div class="line">      <span class="string">"pushq  %%r14\n\t"</span></div><div class="line">      <span class="string">"pushq  %%r13\n\t"</span></div><div class="line">      <span class="string">"pushq  %%r12\n\t"</span></div><div class="line">      <span class="string">"pushq  %%rbx\n\t"</span></div><div class="line">      <span class="string">"pushq  %%rax\n\t"</span></div><div class="line">      <span class="string">"jmp  *%1\n\t"</span></div><div class="line">      :</div><div class="line">      : <span class="string">"r"</span> (returnAddr), <span class="string">"r"</span> (methodOffset));</div><div class="line">  </div><div class="line">  RETURNADDRESS: ;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>由于模拟器和真机的架构不同， Serek Selander 给出的代码只能在模拟器下 work ，因而为了能在真机下 work ， 我做出了一些改进。完整代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DebuggingOverlay.m</span></div><div class="line"><span class="keyword">@import</span> <span class="built_in">UIKit</span>;</div><div class="line"><span class="keyword">@import</span> Foundation;</div><div class="line"><span class="keyword">@import</span> ObjectiveC.runtime;</div><div class="line"></div><div class="line"><span class="comment">// Used for swizzling on iOS 11+. UIDebuggingInformationOverlay is a subclass of UIWindow</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIWindow</span> (<span class="title">DocsUIDebuggingInformationOverlaySwizzler</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)swizzle_basicInit &#123;</div><div class="line">	<span class="keyword">return</span> [<span class="keyword">super</span> init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// [[UIDebuggingInformationOverlayInvokeGestureHandler mainHandler] _handleActivationGesture:(UIGestureRecognizer *)]</span></div><div class="line"><span class="comment">// requires a UIGestureRecognizer, as it checks the state of it. We just fake that here.</span></div><div class="line">- (<span class="built_in">UIGestureRecognizerState</span>)state &#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">UIGestureRecognizerStateEnded</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DebuggingOverlay</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DebuggingOverlay</span></span></div><div class="line">  </div><div class="line">+ (<span class="keyword">void</span>)toggleOverlay &#123;</div><div class="line">	<span class="comment">// In iOS 11, Apple added additional checks to disable this overlay unless the</span></div><div class="line">	<span class="comment">// device is an internal device. To get around this, we swizzle out the</span></div><div class="line">	<span class="comment">// -[UIDebuggingInformationOverlay init] method (which returns nil now if</span></div><div class="line">	<span class="comment">// the device is non-internal), and we call:</span></div><div class="line">	<span class="comment">// [[UIDebuggingInformationOverlayInvokeGestureHandler mainHandler] _handleActivationGesture:(UIGestureRecognizer *)]</span></div><div class="line">	<span class="comment">// to show the window, since that now adds the debugging view controllers, and calls</span></div><div class="line">	<span class="comment">// [overlay toggleVisibility] for us.</span></div><div class="line">	<span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</div><div class="line">    <span class="keyword">id</span> debugInfoClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlay"</span>);</div><div class="line">		<span class="keyword">id</span> handlerClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIDebuggingInformationOverlayInvokeGestureHandler"</span>);</div><div class="line">		</div><div class="line">		<span class="built_in">UIWindow</span> *window = [[<span class="built_in">UIWindow</span> alloc] init];</div><div class="line">		</div><div class="line">		<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">		<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">			<span class="comment">// Swizzle init of debugInfo class</span></div><div class="line">			Method originalInit = class_getInstanceMethod(debugInfoClass, <span class="keyword">@selector</span>(init));</div><div class="line">			IMP swizzledInit = [window methodForSelector:<span class="keyword">@selector</span>(swizzle_basicInit)];</div><div class="line">			method_setImplementation(originalInit, swizzledInit);</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		<span class="keyword">id</span> debugOverlayInstance = [debugInfoClass performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"overlay"</span>)];</div><div class="line">		[debugOverlayInstance setFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</div><div class="line">		</div><div class="line">		<span class="keyword">id</span> handler = [handlerClass performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"mainHandler"</span>)];</div><div class="line">		[handler performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"_handleActivationGesture:"</span>) withObject:window];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>主要思想是 <code>UIDebuggingInformationOverlay</code> 是 <code>UIWindow</code> 的子类，那么我们可以利用 runtime 机制动态去替换其 <code>init</code> 方法的 <code>IMP</code>，以此来绕过 Apple 的验证机制。在实例化一个 <code>UIDebuggingInformationOverlay</code> 对象后，调用 <code>[[UIDebuggingInformationOverlayInvokeGestureHandler mainHandler] _handleActivationGesture:(UIGestureRecognizer *)]</code> 触发 <code>UIDebuggingInformationOverlay</code> 显示到屏幕上。由于该方法要求必须要有 <code>UIGestureRecognizer</code> 手势，以便检查其 <code>state</code> 值，因而我们需要添加 <code>state</code> 变量用来伪装手势。最后，在实际调用的地方调用如下代码即可 work ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"DebuggingOverlay"</span>);</div><div class="line">[cls performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"toggleOverlay"</span>)]</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Weak 属性在 dealloc() 背后的逻辑]]></title>
      <url>https://iiiceblink.github.io/2017/10/04/Weak%20%E5%B1%9E%E6%80%A7%E5%9C%A8%20dealloc%20%E8%83%8C%E5%90%8E%E7%9A%84%E9%80%BB%E8%BE%91/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们都知道在 ARC 环境无论是强指针还是弱指针都无需在 <code>dealloc</code> 设置为 <code>nil</code> ， ARC 会自动帮我们处理。然而，最近在项目中遇到这样一个问题，代码示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// class Foo</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (_obj) &#123;</div><div class="line">        [_obj removeObserver:[KVOObserverStub stub] forKeyPath:_keyPath];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>_obj</code> 是类 <code>Foo</code> 的 weak 属性，这段代码所做的工作是在 <code>Foo</code> 的实例对象销毁的时候，移除 <code>_obj</code> 对象上的观察者，否则，会导致 <code>KVO still registering when deallocated</code> 的 crash 。原以为这样写会 work ，然而在实际测试中发现，在触发 <code>dealloc</code> 方法时，<code>_obj</code> 此时已被置为 <code>nil</code> ，即 <code>[_obj removeObserver:[KVOObserverStub stub] forKeyPath:_keyPath];</code> 并不会触发。解决方案则是将 <code>_obj</code> 属性的修饰符由 <code>weak</code> 改为 <code>unsafe_unretained</code> 或者 <code>assign</code> 。但是，这样改可能会为其他代码引入 bug ，因为现在 ARC 不会自动为将 <code>_obj</code> 对象置为 <code>nil</code> ，需要去检查涉及 <code>_obj</code> 部分的代码。虽然这样解决问题了，但是，我还是对 <code>weak</code> 属性在其持有对象的 <code>dealloc</code> 方法触发时背后的逻辑很感兴趣。</p>
<a id="more"></a>
<h3 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h3><p>llvm 官方的 ARC 文档中对 ARC 下的 <code>dealloc</code> 过程做了简单说明：</p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p>大概意思是： <code>dealloc</code> 方法在最后一次 <code>release</code> 后被调用，但<strong>此时实例变量（Ivars）并未释放</strong>，父类的 <code>dealloc</code> 的方法将在子类 <code>dealloc</code> 方法返回后自动调用</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>理解： ARC 下对象的实例变量在根类 <code>[NSObject dealloc]</code> 中释放。</p>
<p>为了探究背后的逻辑，我写了一个例子，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> refObject;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)foo &#123;</div><div class="line">   B* b = [B new];</div><div class="line">   <span class="keyword">self</span>.refObject = b;</div><div class="line">   <span class="comment">// Just use b after the weak assignment</span></div><div class="line">   <span class="comment">// in order to not dealloc 'b' before assignement </span></div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In dealloc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>上面的代码意思大致是类 A 有一个 <code>weak</code> 属性 <code>refObject</code> ，在 <code>foo()</code> 方法中将 <code>refObject</code> 设置为 b 。运行代码，并在 <code>dealloc</code> 方法调用时断点观察，我们会发现在 <code>dealloc</code> 方法执行的最后，<code>a-&gt;_refObject</code> 被置为 <code>nil</code> ，调用栈大致是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">frame #0: 0x00007fff8ab9f0f8 libobjc.A.dylib`arr_clear_deallocating + 83</div><div class="line">frame #1: 0x00007fff8ab889ee libobjc.A.dylib`objc_clear_deallocating + 151</div><div class="line">frame #2: 0x00007fff8ab88940 libobjc.A.dylib`objc_destructInstance + 121</div><div class="line">frame #3: 0x00007fff8ab88fa0 libobjc.A.dylib`object_dispose + 22</div><div class="line">frame #4: 0x0000000100000b27 weakdealloc`-[B dealloc](self=0x000000010010a640, _cmd=0x00007fff887f807b) + 151 at main.m:28</div><div class="line">frame #5: 0x0000000100000bbc weakdealloc`-[A foo](self=0x0000000100108290, _cmd=0x0000000100000e6f) + 140 at main.m:41</div><div class="line">frame #6: 0x0000000100000cf5 weakdealloc`main(argc=1, argv=0x00007fff5fbff968) + 117 at main.m:52</div><div class="line">frame #7: 0x00007fff8c0987e1 libdyld.dylib`start + 1</div></pre></td></tr></table></figure>
<p>调用栈中的 <code>object_dispose</code> 方法是在 <code>-[NSObject dealloc]</code> 方法中调用的，我们可以从 <a href="https://opensource.apple.com/source/objc4/objc4-532/runtime/NSObject.mm" target="_blank" rel="external">NSObject.mm</a> 看出。因而，在调用 <code>-[B dealloc]</code> 方法时，在 <code>-[NSObject dealloc]</code> 方法调用之前，<code>a-&gt;_refObject</code> 都不为 <code>nil</code> 。那么问题来了，为什么我们在 <code>-[B dealloc]</code> 方法中访问 <code>a.refObject</code> 是为 <code>nil</code> 呢？</p>
<p>查阅 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-loadweakretained" target="_blank" rel="external">LLVM文档</a> 时发现，原来是 <code>objc_loadWeakRetained</code> 方法在作祟：</p>
<blockquote>
<p><strong>id objc_loadWeakRetained(id *object)</strong><br><br><br>If object is registered as a __weak object, and the last value stored into object has not yet been deallocated or begun deallocation, retains that value and returns it. Otherwise, returns null.</p>
</blockquote>
<p>这段文档意思是 <code>weak</code> 对象在开始 <code>deallocate</code> 后，<code>objc_loadWeakRetained</code> 会返回 <code>nil</code> 。因而，我们无法通过 <code>a._refObject</code> 去访问对象。那么为什么可以通过 <code>a-&gt;refObject</code> 去访问到呢？其实，很简单，因为 debugger 通过 <code>a-&gt;refObject</code> 访问对象时，并没有调用 <code>objc_loadWeak()</code> 方法。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 <code>dealloc</code> 操作开始后，在 <code>-[B dealloc]</code> 中实例对象 <code>a-&gt;refObejct</code> 并不为 <code>nil</code> ，但是指向该对象的 <code>weak</code> 指针经过 <code>ARC runtime</code> 函数的处理已经返回 <code>nil</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CFNetwork学习笔记（四）]]></title>
      <url>https://iiiceblink.github.io/2016/10/10/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要讲述用CFHTTPAuthentication API如何与HTTP认证服务器交互，如何找到合适的认证对象和证书并填入到HTTP请求中。一般而言，如果HTTP服务器给你的HTTP请求返回401或407，就意味着服务器是认证服务器并且要求证书。在CFHTTPAuthentication API中，每个证书集合都被存储在CFHTTPAuthentication对象中。因此，每个不同的认证服务器和连接到服务器的不同用户都需要存储在独立的CFHTTPAuthentication对象中。为了能与服务器进行通信，你需要将CFHTTPAuthentication存储到HTTP请求当中。后面会对这些步骤进行详细解释。<br><a id="more"></a></p>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>添加对认证的支持能让你的app与HTTP认证服务器进行会话，即使即使HTTP认证不是复杂的概念，但要去实现它却是比较复杂的过程。整个的过程如下：</p>
<blockquote>
<p>1.客户端向服务器发送HTTP请求。<br>2.服务端要求客户端进行认证。<br>3.客户端将原始的请求和证书一起打包重新发给服务器。<br>4.客户端和服务器进行通信。<br>5.当服务器对客户端认证完成后，它会将请求的响应返回给客户端。</p>
</blockquote>
<p><img src="/images/CFNetwork/4.png" alt=""></p>
<p><img src="/images/CFNetwork/5.png" alt=""></p>
<p>当HTTP请求返回401或407时，客户端第一步要做的是找到可靠的CFHTTPAuthentication对象。认证对象中包含证书和其他向服务器认证需要的信息。如果你已经跟服务器认证过了，你就会有有效的认证对象。然而，在大多数情况下，你需要调用<code>CFHTTPAuthenticationCreateFromResponse</code>方法创建认证对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!authentication) &#123;</div><div class="line">    <span class="built_in">CFHTTPMessageRef</span> responseHeader =</div><div class="line">        (<span class="built_in">CFHTTPMessageRef</span>) <span class="built_in">CFReadStreamCopyProperty</span>(</div><div class="line">            readStream,</div><div class="line">            kCFStreamPropertyHTTPResponseHeader</div><div class="line">        );</div><div class="line"> </div><div class="line">    <span class="comment">// Get the authentication information from the response.</span></div><div class="line">    authentication = <span class="built_in">CFHTTPAuthenticationCreateFromResponse</span>(<span class="literal">NULL</span>, responseHeader);</div><div class="line">    <span class="built_in">CFRelease</span>(responseHeader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果创建的认证对象是有效的，那就可以继续下一步了。如果认证对象是无效的，就检查看证书是否已经损坏。更多关于证书的信息，可以阅读<a href="https://developer.apple.com/library/content/qa/qa1277/_index.html" target="_blank" rel="external">Security Credentials</a>中的内容。损坏的证书意味着服务器不接受登录信息并且继续监听新的证书。然而，如果证书是完好的而服务器拒绝了app发出的请求，那就是说服务器拒绝与app进行通信，这时候就必须放弃。在证书损坏的情况下，重新创建认证对象并重复认证的步骤直到得到有效的认证对象。以下为代码示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查找有效的认证对象 Code 4-1</span></div><div class="line"><span class="built_in">CFStreamError</span> err;</div><div class="line"><span class="keyword">if</span> (!authentication) &#123;</div><div class="line">    <span class="comment">// the newly created authentication object is bad, must return</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">CFHTTPAuthenticationIsValid</span>(authentication, &amp;err)) &#123;</div><div class="line"> </div><div class="line">    <span class="comment">// destroy authentication and credentials</span></div><div class="line">    <span class="keyword">if</span> (credentials) &#123;</div><div class="line">        <span class="built_in">CFRelease</span>(credentials);</div><div class="line">        credentials = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CFRelease</span>(authentication);</div><div class="line">    authentication = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// check for bad credentials (to be treated separately)</span></div><div class="line">    <span class="keyword">if</span> (err.domain == kCFStreamErrorDomainHTTP &amp;&amp;</div><div class="line">        (err.error == kCFStreamErrorHTTPAuthenticationBadUserName</div><div class="line">        || err.error == kCFStreamErrorHTTPAuthenticationBadPassword))&#123;</div><div class="line">        retryAuthorizationFailure(&amp;authentication);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        errorOccurredLoadingImage(err);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，你已经有了有效的认证对象，继续上面流程图下面的步骤。第一步，向服务器请求是否需要证书。如果不需要，直接将认证对象添加到HTTP请求当中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> resumeWithCredentials() &#123;</div><div class="line">    <span class="comment">// Apply whatever credentials we've built up to the old request</span></div><div class="line">    <span class="keyword">if</span> (!<span class="built_in">CFHTTPMessageApplyCredentialDictionary</span>(request, authentication,</div><div class="line">                                                credentials, <span class="literal">NULL</span>)) &#123;</div><div class="line">        errorOccurredLoadingImage();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Now that we've updated our request, retry the load</span></div><div class="line">        loadRequest();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果内存和磁盘中没有存储证书，获取有效证书的唯一方式是向用户请求。大部分情况下，证书都需要用户名和密码。将认证对象传入<code>CFHTTPAuthenticationRequiresUserNameAndPassword</code>方法中就可以知道用户名和密码是否是必须的。如果证书需要用户名和密码，想用户请求并将它们存储在证书的字典中。对于NTLM服务器而言，证书还需要提供域名。在你有了新的证书后，你可以调用<code>resumeWithCredentials</code>方法将认证对象添加到HTTP请求当中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...continued from Code 4-1</span></div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    cancelLoad();</div><div class="line">    <span class="keyword">if</span> (credentials) &#123;</div><div class="line">        resumeWithCredentials();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// are a user name &amp; password needed?</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CFHTTPAuthenticationRequiresUserNameAndPassword</span>(authentication))</div><div class="line">        &#123;</div><div class="line">        <span class="built_in">CFStringRef</span> realm = <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">CFURLRef</span> url = <span class="built_in">CFHTTPMessageCopyRequestURL</span>(request);</div><div class="line"> </div><div class="line">         <span class="comment">// check if you need an account domain so you can display it if necessary</span></div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">CFHTTPAuthenticationRequiresAccountDomain</span>(authentication)) &#123;</div><div class="line">            realm = <span class="built_in">CFHTTPAuthenticationCopyRealm</span>(authentication);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...prompt user for user name (user), password (pass)</span></div><div class="line">        <span class="comment">// and if necessary domain (domain) to give to the server...</span></div><div class="line"> </div><div class="line">        <span class="comment">// Guarantee values</span></div><div class="line">        <span class="keyword">if</span> (!user) user = <span class="built_in">CFSTR</span>(<span class="string">""</span>);</div><div class="line">        <span class="keyword">if</span> (!pass) pass = <span class="built_in">CFSTR</span>(<span class="string">""</span>);</div><div class="line"> </div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(credentials, kCFHTTPAuthenticationUsername, user);</div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(credentials, kCFHTTPAuthenticationPassword, pass);</div><div class="line"> </div><div class="line">        <span class="comment">// Is an account domain needed? (used currently for NTLM only)</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CFHTTPAuthenticationRequiresAccountDomain</span>(authentication)) &#123;</div><div class="line">            <span class="keyword">if</span> (!domain) domain = <span class="built_in">CFSTR</span>(<span class="string">""</span>);</div><div class="line">            <span class="built_in">CFDictionarySetValue</span>(credentials,</div><div class="line">                                 kCFHTTPAuthenticationAccountDomain, domain);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (realm) <span class="built_in">CFRelease</span>(realm);</div><div class="line">        <span class="built_in">CFRelease</span>(url);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        resumeWithCredentials();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将证书保存在内存中"><a href="#将证书保存在内存中" class="headerlink" title="将证书保存在内存中"></a>将证书保存在内存中</h3><p>如果你需要频繁和认证服务器进行通信，那么重复利用证书可以避免多次向用户请求用户名和密码。为了重复利用证书，有三种数据结构需要在代码中做出修改。</p>
<blockquote>
<p>1.创建可变数组CFMutableArrayRef取代CFHTTPAuthenticationRef对象来存储所有的认证对象<br>CFHTTPAuthenticationRef authentication; -&gt; CFMutableArrayRef authArray;<br>2.使用字典创建认证对象到证书的映射<br>CFMutableDictionaryRef credentials; -&gt; CFMutableDictionaryRef credentialsDict;<br>3.在所有更新当前认证对象和当前证书的地方保存这些结构<br>CFRelease(credentials); -&gt; CFDictionaryRemoveValue(credentialsDict, authentication);</p>
</blockquote>
<p>在创建HTTP请求后，需要查找匹配的认证对象。以下代码是很简易的且未优化的查找合适对象的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFHTTPAuthenticationRef</span> findAuthenticationForRequest &#123;</div><div class="line">    <span class="keyword">int</span> i, c = <span class="built_in">CFArrayGetCount</span>(authArray);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; c; i ++) &#123;</div><div class="line">        <span class="built_in">CFHTTPAuthenticationRef</span> auth = (<span class="built_in">CFHTTPAuthenticationRef</span>)</div><div class="line">                <span class="built_in">CFArrayGetValueAtIndex</span>(authArray, i);</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CFHTTPAuthenticationAppliesToRequest</span>(auth, request)) &#123;</div><div class="line">            <span class="keyword">return</span> auth;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果认证数组中查找到匹配的认证对象，然后检查证书存储中是否可以获取。这样做防止你再次向用户请求用户名和密码。查找证书可以调用<code>CFDictionaryGetValue</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">credentials = <span class="built_in">CFDictionaryGetValue</span>(credentialsDict, authentication);</div></pre></td></tr></table></figure>
<p>然后将匹配的认证对象和证书添加到原始的HTTP请求中并重新发送。注意，在每一偶收到服务器认证消息之前不要将证书添加到HTTP请求中。服务器可能自从上一次认证过后改变了认证策略，你这样做可能会发生安全危险。</p>
<p>通过以上三种结构的改变，你的app能够将认证对象和证书存储在内存当中。</p>
<h3 id="将证书保存在持久化仓库中"><a href="#将证书保存在持久化仓库中" class="headerlink" title="将证书保存在持久化仓库中"></a>将证书保存在持久化仓库中</h3><p>将证书存储在内存中可以防止在指定app启动时用户重复输入用户名和密码。然而，当app退出时，这些证书会被释放。为了避免丢失证书，我们将每个服务器的证书存储在持久化仓库中并且只需要生成一次。钥匙串是存储证书非常推荐的位置。即使你有多个钥匙串，默认会将用户的默认钥匙串作为存储证书的位置。使用钥匙串意味着你存储的认证信息同样可以在其他的app中使用。</p>
<p>在钥匙串中存储和获取证书依赖于两个方法：一个是用来查找认证的证书字典，另一个是用来存储请求中的证书。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFMutableDictionaryRef</span> findCredentialsForAuthentication(</div><div class="line">        <span class="built_in">CFHTTPAuthenticationRef</span> auth);</div><div class="line"> </div><div class="line"><span class="keyword">void</span> saveCredentialsForRequest(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p><code>findCredentialsForAuthentication</code>方法首先会检查存储在内存中的证书字典是否在本地有缓存。如果证书在内存中没有缓存，之后就搜索钥匙串。调用<code>SecKeychainFindInternetPassword</code>方法搜索钥匙串。该方法要求很多参数：</p>
<blockquote>
<p>keychainOrArray：NULL指定用户默认的钥匙串列表。<br>serverNameLength：服务器名字长度，通常是strlen(serverName)。<br>serverName：解析HTTP请求的服务器名字。<br>securityDomainLength：安全域名的长度，如果没有域名传入0。<br>securityDomain：认证对象的范围，可从<code>CFHTTPAuthenticationCopyRealm</code>方法中获取。<br>accountNameLength：用户名的长度。如果用户名为空，则传入0。<br>accountName：用户名。<br>pathLength：路径的长度，如果没有路径则传入0。<br>path：认证对象的路径，可从<code>CFURLCopyPath</code>方法中获取。<br>port：端口号，可从<code>CFURLGetPortNumber</code>方法中获取。<br>protocol：协议，可从<code>CFURLCopyScheme</code>方法中获取。<br>authenticationType：认证类型，可从<code>CFHTTPAuthenticationCopyMethod</code>方法中获取。<br>passwordLength：密码长度。0，因为在获取钥匙串许可时没有密码是必须的。<br>passwordData：密码数据。NULL，因为在获取钥匙串许可时没有密码是必须的。<br>itemRef：钥匙串条目。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">didFind =</div><div class="line">    SecKeychainFindInternetPassword(<span class="literal">NULL</span>,</div><div class="line">                                    strlen(host), host,</div><div class="line">                                    realm ? strlen(realm) : <span class="number">0</span>, realm,</div><div class="line">                                    <span class="number">0</span>, <span class="literal">NULL</span>,</div><div class="line">                                    path ? strlen(path) : <span class="number">0</span>, path,</div><div class="line">                                    port,</div><div class="line">                                    protocolType,</div><div class="line">                                    authenticationType,</div><div class="line">                                    <span class="number">0</span>, <span class="literal">NULL</span>,</div><div class="line">                                    &amp;itemRef);</div></pre></td></tr></table></figure>
<p>当<code>SecKeychainFindInternetPassword</code>方返回成功时，创建钥匙串属性列表（SecKeychainAttributeList）存储钥匙串属性（SecKeychainAttribute）。钥匙串属性列表会存储用户名和密码。要加载钥匙串属性列表，调用<code>SecKeychainItemCopyContent</code>方法并将<code>SecKeychainFindInternetPassword</code>方法返回的钥匙串条目对象传入。该方法会用用户的用户名和密码填充钥匙串属性。以下代码示例表示从要是传中加载服务器证书：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (didFind == noErr) &#123;</div><div class="line"> </div><div class="line">    SecKeychainAttribute     attr;</div><div class="line">    SecKeychainAttributeList attrList;</div><div class="line">    <span class="built_in">UInt32</span>                   length;</div><div class="line">    <span class="keyword">void</span>                     *outData;</div><div class="line"> </div><div class="line">    <span class="comment">// To set the account name attribute</span></div><div class="line">    attr.tag = kSecAccountItemAttr;</div><div class="line">    attr.length = <span class="number">0</span>;</div><div class="line">    attr.data = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">    attrList.count = <span class="number">1</span>;</div><div class="line">    attrList.attr = &amp;attr;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (SecKeychainItemCopyContent(itemRef, <span class="literal">NULL</span>, &amp;attrList, &amp;length, &amp;outData)</div><div class="line">        == noErr) &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// attr.data is the account (username) and outdata is the password</span></div><div class="line">        <span class="built_in">CFStringRef</span> username =</div><div class="line">            <span class="built_in">CFStringCreateWithBytes</span>(kCFAllocatorDefault, attr.data,</div><div class="line">                                    attr.length, kCFStringEncodingUTF8, <span class="literal">false</span>);</div><div class="line">        <span class="built_in">CFStringRef</span> password =</div><div class="line">            <span class="built_in">CFStringCreateWithBytes</span>(kCFAllocatorDefault, outData, length,</div><div class="line">                                    kCFStringEncodingUTF8, <span class="literal">false</span>);</div><div class="line">        SecKeychainItemFreeContent(&amp;attrList, outData);</div><div class="line"> </div><div class="line">        <span class="comment">// create credentials dictionary and fill it with the user name &amp; password</span></div><div class="line">        credentials =</div><div class="line">            <span class="built_in">CFDictionaryCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>,</div><div class="line">                                      &amp;kCFTypeDictionaryKeyCallBacks,</div><div class="line">                                      &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(credentials, kCFHTTPAuthenticationUsername,</div><div class="line">                             username);</div><div class="line">        <span class="built_in">CFDictionarySetValue</span>(credentials, kCFHTTPAuthenticationPassword,</div><div class="line">                             password);</div><div class="line"> </div><div class="line">        <span class="built_in">CFRelease</span>(username);</div><div class="line">        <span class="built_in">CFRelease</span>(password);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CFRelease</span>(itemRef);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你可以在钥匙串中存储证书，那么从钥匙串中获取证书会起作用。这些步骤与加载证书非常类似。首先，查看证书是否存储在要是传中。调用<code>SecKeychainFindInternetPassword</code>方法并传入用户名和用户名长度。如果证书存在，修改它的密码。设置data存入用户名，这样就可以修改正确的属性。然后调用<code>SecKeychainItemModifyContent</code>方法传入item、钥匙串属性列表和新密码。修改钥匙串许可而不是复写它，钥匙串许可会正确地更新并且任何与之关联的元数据都会得到保存。代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set the attribute to the account name</span></div><div class="line">attr.tag = kSecAccountItemAttr;</div><div class="line">attr.length = strlen(username);</div><div class="line">attr.data = (<span class="keyword">void</span>*)username;</div><div class="line"> </div><div class="line"><span class="comment">// Modify the keychain entry</span></div><div class="line">SecKeychainItemModifyContent(itemRef, &amp;attrList, strlen(password), (<span class="keyword">void</span> *)password);</div></pre></td></tr></table></figure>
<p>如果许可不存在，你就需要创建它。<code>SecKeychainAddInternetPassword</code>方法可以完成这个工作，该方法的参数与<code>SecKeychainFindInternetPassword</code>方法一致，不一样的地方在于在<code>SecKeychainAddInternetPassword</code>方法中需要用户名和密码。成功调用后，若不需要再使用item则将其释放。</p>
<h3 id="防火墙认证"><a href="#防火墙认证" class="headerlink" title="防火墙认证"></a>防火墙认证</h3><p>防火墙认证与服务器认证很相似，但防火墙认证在HTTP请求失败后需要同时进行代理认证和服务器认证。这意味着你需要对代理服务器和原始服务器分开进行存储。因而，返回失败的响应后所做的操作应该是：</p>
<blockquote>
<ul>
<li>检查响应码是不是407.如果是，在内存代理存储和磁盘代理存储中找到匹配的认证对象和证书。如果都没有合适的对象和证书，则向用户请求证书，然后将认证对象添加到HTTP请求中并重试。</li>
<li>检查响应码是不是401。如果是，重复407下的做法，只是查找的是原始服务器存储。</li>
</ul>
</blockquote>
<p>除此之外，当使用代理服务器时还有些小差别。第一就是钥匙串调用方法的参数来自于代理主机和端口而不是原始服务器的URL。第二就是当向用户请求用户名和密码的时候，确保提示清楚地说明密码是什么。</p>
<p>只要遵循这些操作，app就能成功与认证防火墙工作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CFNetwork学习笔记（三）]]></title>
      <url>https://iiiceblink.github.io/2016/10/07/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要介绍如何创建、发送和接收HTTP请求和响应。</p>
<a id="more"></a>
<h3 id="创建CFHTTP请求"><a href="#创建CFHTTP请求" class="headerlink" title="创建CFHTTP请求"></a>创建CFHTTP请求</h3><p>HTTP请求实际上是包含了请求方法、URL、消息头和消息体的消息。请求方法通常是GET, HEAD, PUT, POST, DELETE, TRACE, CONNECT 或 OPTIONS。用CFHTTP创建HTTP请求需要四个步骤：</p>
<blockquote>
<p>1.调用<code>CFHTTPMessageCreateRequest</code>方法生成CFHTTP消息对象。<br>2.调用<code>CFHTTPMessageSetBody</code>方法设置消息体。<br>3.调用<code>CFHTTPMessageSetHeaderFieldValue</code>方法设置消息头。<br>4.调用<code>CFHTTPMessageCopySerializedMessage</code>方法对消息进行序列化。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建HTTP请求</span></div><div class="line"><span class="built_in">CFStringRef</span> bodyString = <span class="built_in">CFSTR</span>(<span class="string">""</span>); <span class="comment">// Usually used for POST data</span></div><div class="line"><span class="built_in">CFDataRef</span> bodyData = <span class="built_in">CFStringCreateExternalRepresentation</span>(kCFAllocatorDefault, bodyString, kCFStringEncodingUTF8, <span class="number">0</span>);</div><div class="line"> </div><div class="line"><span class="built_in">CFStringRef</span> headerFieldName = <span class="built_in">CFSTR</span>(<span class="string">"X-My-Favorite-Field"</span>);</div><div class="line"><span class="built_in">CFStringRef</span> headerFieldValue = <span class="built_in">CFSTR</span>(<span class="string">"Dreams"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">CFStringRef</span> url = <span class="built_in">CFSTR</span>(<span class="string">"http://www.apple.com"</span>);</div><div class="line"><span class="built_in">CFURLRef</span> myURL = <span class="built_in">CFURLCreateWithString</span>(kCFAllocatorDefault, url, <span class="literal">NULL</span>);</div><div class="line"> </div><div class="line"><span class="built_in">CFStringRef</span> requestMethod = <span class="built_in">CFSTR</span>(<span class="string">"GET"</span>);</div><div class="line"><span class="built_in">CFHTTPMessageRef</span> myRequest = <span class="built_in">CFHTTPMessageCreateRequest</span>(kCFAllocatorDefault, requestMethod, myURL, kCFHTTPVersion1_1);</div><div class="line"> </div><div class="line"><span class="built_in">CFDataRef</span> bodyDataExt = <span class="built_in">CFStringCreateExternalRepresentation</span>(kCFAllocatorDefault, bodyData, kCFStringEncodingUTF8, <span class="number">0</span>);</div><div class="line"><span class="built_in">CFHTTPMessageSetBody</span>(myRequest, bodyDataExt);</div><div class="line"><span class="built_in">CFHTTPMessageSetHeaderFieldValue</span>(myRequest, headerFieldName, headerFieldValue);</div><div class="line"><span class="built_in">CFDataRef</span> mySerializedRequest = <span class="built_in">CFHTTPMessageCopySerializedMessage</span>(myRequest);</div></pre></td></tr></table></figure>
<p>在上面这段代码中，url会被<code>CFURLCreateWithString</code>方法转换成CFURL对象。然后，调用<code>CFHTTPMessageCreateRequest</code>创建HTTP请求对象。之后，将创建的对象连同消息体（bodyData）传入<code>CFHTTPMessageSetBody</code>方法中，将请求对象连同消息头的名字（headerField）和值（value）传入<code>CFHTTPMessageSetHeaderFieldValue</code>方法中，headerField参数接受CFString类型的对象如Content-Length，value参数接受CFString类型的对象如1260。最后，调用<code>CFHTTPMessageCopySerializedMessage</code>方法对消息进行序列化并且通过写入流发送到接受者那里。</p>
<p>当请求不再需要时，我们需要释放消息对象和序列化的消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRelease</span>(myRequest);</div><div class="line"><span class="built_in">CFRelease</span>(myURL);</div><div class="line"><span class="built_in">CFRelease</span>(url);</div><div class="line"><span class="built_in">CFRelease</span>(mySerializedRequest);</div><div class="line">myRequest = <span class="literal">NULL</span>;</div><div class="line">mySerializedRequest = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h3 id="创建CFHTTP响应"><a href="#创建CFHTTP响应" class="headerlink" title="创建CFHTTP响应"></a>创建CFHTTP响应</h3><p>创建HTTP响应的步骤与创建HTTP请求的步骤是一致的。唯一的区别在于是调用<code>CFHTTPMessageCreateResponse</code>方法而不是<code>CFHTTPMessageCreateRequest</code>方法。</p>
<h3 id="反序列化HTTP请求"><a href="#反序列化HTTP请求" class="headerlink" title="反序列化HTTP请求"></a>反序列化HTTP请求</h3><p>要对收到的HTTP请求进行反序列化操作，首先要调用<code>CFHTTPMessageCreateEmpty</code>方法创建空的消息对象，并在isRequest参数中传入true表示创建的是请求消息对象。然后，调用<code>CFHTTPMessageAppendBytes</code>方法将接收到的HTTP请求添加到消息对象中去。<code>CFHTTPMessageAppendBytes</code>方法会反序列化消息并且移除它保存的任何控制信息。一直不停地循环去调用该方法直到<code>CFHTTPMessageIsHeaderComplete</code>返回true。若<code>CFHTTPMessageIsHeaderComplete</code>没有返回true，说明消息是不完整的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFHTTPMessageRef</span> myMessage = <span class="built_in">CFHTTPMessageCreateEmpty</span>(kCFAllocatorDefault, <span class="literal">TRUE</span>);</div><div class="line"><span class="keyword">if</span> (!<span class="built_in">CFHTTPMessageAppendBytes</span>(myMessage, &amp;data, numBytes)) &#123;</div><div class="line">    <span class="comment">//Handle parsing error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>CFHTTPMessageAppendBytes</code>方法中，data参数表示要被添加进消息对象中的数据，numBytes参数表示data的大小。你可以调用<code>CFHTTPMessageIsHeaderComplete</code>方法去验证添加消息是否完成。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">CFHTTPMessageIsHeaderComplete</span>(myMessage)) &#123;</div><div class="line">    <span class="comment">// Perform processing.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当消息反序列化完成后，你可以调用下面的方法从消息对象中截取信息：</p>
<blockquote>
<ul>
<li><code>CFHTTPMessageCopyBody</code>：获取消息体的拷贝</li>
<li><code>CFHTTPMessageCopyHeaderFieldValue</code>：获取指定头部区域的拷贝</li>
<li><code>CFHTTPMessageCopyAllHeaderFields</code>：获取所有消息头的拷贝</li>
<li><code>CFHTTPMessageCopyRequestURL</code>：获取消息的URL的拷贝</li>
<li><code>CFHTTPMessageCopyRequestMethod</code>：获取消息请求方法的拷贝</li>
</ul>
</blockquote>
<p>当你不在需要消息对象时，需要正确地对其进行释放和销毁操作。</p>
<h3 id="反序列化HTTP响应"><a href="#反序列化HTTP响应" class="headerlink" title="反序列化HTTP响应"></a>反序列化HTTP响应</h3><p>正如创建HTTP请求和创建HTTP响应很相似，反序列化HTTP请求和反序列化HTTP响应也非常相似。唯一重要的区别在于当调用<code>CFHTTPMessageCreateEmpty</code>方法时，你必须给isRequest参数传入false表示创建的消息是响应消息。</p>
<h3 id="使用读流序列化和发送HTTP请求"><a href="#使用读流序列化和发送HTTP请求" class="headerlink" title="使用读流序列化和发送HTTP请求"></a>使用读流序列化和发送HTTP请求</h3><p>你可以使用CFReadStream对象序列化和发送CFHTTP请求。当你使用CFReadStream对象发送CFHTTP请求时，打开流会让消息的序列化和发送在一步中完成。使用CFReadStream对象发送CFHTTP请求让获取响应变得容易因为响应会作为流的属性而被访问。</p>
<h5 id="序列化和发送HTTP请求"><a href="#序列化和发送HTTP请求" class="headerlink" title="序列化和发送HTTP请求"></a>序列化和发送HTTP请求</h5><p>要使用CFReadStream对象序列化和发送HTTP请求，首先要创建CFHTTP请求并设置消息头和消息体。然后，调用<code>CFReadStreamCreateForHTTPRequest</code>方法创建CFReadStream对象并传入先前创建的请求。最后，调用<code>CFReadStreamOpen</code>打开读流。</p>
<p>当<code>CFReadStreamCreateForHTTPRequest</code>方法被调用时，它会将传入的CFHTTP请求对象进行拷贝。因而，如果必要，你应该在调用完<code>CFReadStreamCreateForHTTPRequest</code>方法后立即释放CFHTTP请求对象。因为读流要与指定的服务器建立套接字连接，所以在流可以打开之前需要耗费一部分时间。打开读流同样会引起请求的序列化和发送操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> url = <span class="built_in">CFSTR</span>(<span class="string">"http://www.apple.com"</span>);</div><div class="line"><span class="built_in">CFURLRef</span> myURL = <span class="built_in">CFURLCreateWithString</span>(kCFAllocatorDefault, url, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">CFStringRef</span> requestMethod = <span class="built_in">CFSTR</span>(<span class="string">"GET"</span>);</div><div class="line"> </div><div class="line"><span class="built_in">CFHTTPMessageRef</span> myRequest = <span class="built_in">CFHTTPMessageCreateRequest</span>(kCFAllocatorDefault, requestMethod, myUrl, kCFHTTPVersion1_1);</div><div class="line"><span class="built_in">CFHTTPMessageSetBody</span>(myRequest, bodyData);</div><div class="line"><span class="built_in">CFHTTPMessageSetHeaderFieldValue</span>(myRequest, headerField, value);</div><div class="line"> </div><div class="line"><span class="built_in">CFReadStreamRef</span> myReadStream = <span class="built_in">CFReadStreamCreateForHTTPRequest</span>(kCFAllocatorDefault, myRequest);</div><div class="line"> </div><div class="line"><span class="built_in">CFReadStreamOpen</span>(myReadStream);</div></pre></td></tr></table></figure>
<h5 id="检查响应"><a href="#检查响应" class="headerlink" title="检查响应"></a>检查响应</h5><p>在你将请求添加到runloop中后，你最终会得到完整的头部回调。这时候，你可以调用<code>CFReadStreamCopyProperty</code>方法从读流中获取消息的响应。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFHTTPMessageRef</span> myResponse = (<span class="built_in">CFHTTPMessageRef</span>)<span class="built_in">CFReadStreamCopyProperty</span>(myReadStream, kCFStreamPropertyHTTPResponseHeader);</div></pre></td></tr></table></figure>
<p>你可以调用<code>CFHTTPMessageCopyResponseStatusLine</code>方法从响应消息中得到状态行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStringRef</span> myStatusLine = <span class="built_in">CFHTTPMessageCopyResponseStatusLine</span>(myResponse);</div></pre></td></tr></table></figure>
<p>或者，调用<code>CFHTTPMessageGetResponseStatusCode</code>方法得到响应消息的状态码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UInt32</span> myErrCode = <span class="built_in">CFHTTPMessageGetResponseStatusCode</span>(myResponse);</div></pre></td></tr></table></figure>
<h5 id="处理认证错误"><a href="#处理认证错误" class="headerlink" title="处理认证错误"></a>处理认证错误</h5><p>如果<code>CFHTTPMessageGetResponseStatusCode</code>方法返回的状态码是401（远程服务器要求认证信息）或407（代理服务器要求认证），你需要将认证信息添加到请求中并重新发送。</p>
<h5 id="处理重定向错误"><a href="#处理重定向错误" class="headerlink" title="处理重定向错误"></a>处理重定向错误</h5><p>当调用<code>CFReadStreamCreateForHTTPRequest</code>方法创建读流，默认情况下流的自动重定向是被禁用的。如果请求指向的URL被重定向给另一个URL，你需要关闭流并重新创建流，打开流的重定向选项，最后打开流。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFReadStreamClose</span>(myReadStream);</div><div class="line"><span class="built_in">CFReadStreamRef</span> myReadStream =</div><div class="line">    <span class="built_in">CFReadStreamCreateForHTTPRequest</span>(kCFAllocatorDefault, myRequest);</div><div class="line"><span class="keyword">if</span> (<span class="built_in">CFReadStreamSetProperty</span>(myReadStream, kCFStreamPropertyHTTPShouldAutoredirect, kCFBooleanTrue) == <span class="literal">false</span>) &#123;</div><div class="line">    <span class="comment">// something went wrong, exit</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">CFReadStreamOpen</span>(myReadStream);</div></pre></td></tr></table></figure>
<h3 id="取消正在发送的请求"><a href="#取消正在发送的请求" class="headerlink" title="取消正在发送的请求"></a>取消正在发送的请求</h3><p>一旦请求发送出去后，就不可能阻止远程服务器对其进行操作。然而，如果你不再关心响应数据，你可以关闭流。注意，当另一个线程在同一个流中等待数据时不要从任何线程中关闭流。如果你需要终结请求，你需要使用不阻塞的方式（参见<a href="http://zakariyyasv.pub/2016/10/06/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">CFNetwork学习笔记（二）</a>）。在关闭流之前要确保将流从runloop中移除。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CFNetwork学习笔记（二）]]></title>
      <url>https://iiiceblink.github.io/2016/10/06/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章主要讨论如何创建、开启读写流并检查读写流上的错误。此外，还会介绍如何从读流中读出数据，如何向写流中写入数据，如何在读写的过程中防止发生阻塞，如何通过代理服务器来引导流。</p>
<p>CFStream可以用来读写文件或者与socket一起工作。除了创建流的过程之外，它们其他的行为都很相似。<br><a id="more"></a></p>
<h3 id="ReadStream"><a href="#ReadStream" class="headerlink" title="ReadStream"></a>ReadStream</h3><p>要使用读流，首先需要创建读流对象，代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFReadStreamRef</span> myReadStream = <span class="built_in">CFReadStreamCreateWithFile</span>(kCFAllocatorDefault, fileURL);</div></pre></td></tr></table></figure></p>
<p>在这段代码中，<code>kCFAllocatorDefault</code>参数指定了当前为流分配内存的默认系统分配器，<code>fileURL</code>参数指明了读入文件的文件名，例如file:///Users/joeuser/Downloads/MyApp.sit。</p>
<p>创建成功后就可以打开它。打开流会导致流持有任何它需要的系统资源，如文件描述子用来打开文件。打开流的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">CFReadStreamOpen</span>(myReadStream)) &#123;</div><div class="line">    <span class="built_in">CFStreamError</span> myErr = <span class="built_in">CFReadStreamGetError</span>(myReadStream);</div><div class="line">    <span class="comment">// An error has occurred.</span></div><div class="line">        <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;</div><div class="line">        <span class="comment">// Interpret myErr.error as a UNIX errno.</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;</div><div class="line">        <span class="comment">// Interpret myErr.error as a MacOS error code.</span></div><div class="line">            OSStatus macError = (OSStatus)myErr.error;</div><div class="line">        <span class="comment">// Check other error domains.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>CFReadStreamOpen</code>方法如果返回true则代表成功，返回false则表示由于某些原因而打开失败。如果<code>CFReadStreamOpen</code>返回false，上面代码中会调用<code>CFReadStreamGetError</code>方法，该方法会返回CFStreamError类型的结构，其包含两个值：域代码和错误代码。域代码指定如何翻译错误代码。例如，如果域代码是<code>kCFStreamErrorDomainPOSIX</code>，那错误代码就是UNIX errno值。另外的错误域则是<code>kCFStreamErrorDomainMacOSStatus</code>，它指定的错误代码是定义在MacErrors.h中的<code>OSStatus</code>类型的值；还有错误域<code>kCFStreamErrorDomainHTTP</code>，它指定的错误代码是<code>CFStreamErrorHTTP</code>类型的枚举值。</p>
<p>打开流可能是很长的过程，因此为了避免阻塞，<code>CFReadStreamOpen</code>和<code>CFWriteStreamOpen</code>方法通过返回true说明打开流的进程已经开始。我们可以通过调用<code>CFReadStreamGetStatus</code>和<code>CFWriteStreamGetStatus</code>方法检查开启的状态，如果开启还在进行中，则返回<code>kCFStreamStatusOpening</code>，如果开启完成，则返回<code>kCFStreamStatusOpen</code>，如果开启完成但发生了错误，则返回<code>kCFStreamStatusErrorOccurred</code>。在大多数情况下，无论打开动作是否完成都无关紧要，因为CFStream的读写方法在流未打开时是一直处于阻塞状态的。</p>
<p>打开操作完成后，就需要从读流中读取数据，这就需要调用<code>CFReadStreamRead</code>方法，这与UNIX的系统调用read()相似。这两个方法都有缓冲区和缓冲区长度的参数，都返回读取字节的状态码，如果读取到流或文件的最后则返回0，如果发生错误则返回-1，都会在字节流可以读取之前处于阻塞状态，都会在不阻塞的情况下继续读取直到最后。以下为读取代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFIndex</span> numBytesRead;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="built_in">UInt8</span> buf[myReadBufferSize]; <span class="comment">// define myReadBufferSize as desired</span></div><div class="line">    numBytesRead = <span class="built_in">CFReadStreamRead</span>(myReadStream, buf, <span class="keyword">sizeof</span>(buf));</div><div class="line">    <span class="keyword">if</span>( numBytesRead &gt; <span class="number">0</span> ) &#123;</div><div class="line">        handleBytes(buf, numBytesRead);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( numBytesRead &lt; <span class="number">0</span> ) &#123;</div><div class="line">        <span class="built_in">CFStreamError</span> error = <span class="built_in">CFReadStreamGetError</span>(myReadStream);</div><div class="line">        reportError(error);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">while</span>( numBytesRead &gt; <span class="number">0</span> );</div></pre></td></tr></table></figure>
<p>当所有的数据读取完毕后，你应该调用<code>CFReadStreamClose</code>方法来关闭流，并且释放预置相关联的系统资源。然后，通过调用<code>CFRelease</code>方法释放stream对象的引用。你还可以通过将其设置为NULL来使其引用失效。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFReadStreamClose</span>(myReadStream);</div><div class="line"><span class="built_in">CFRelease</span>(myReadStream);</div><div class="line">myReadStream = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h3 id="WriteStream"><a href="#WriteStream" class="headerlink" title="WriteStream"></a>WriteStream</h3><p>写入流与读出流原理很相似。主要的区别在于<code>CFWriteStreamWrite</code>不保证会接收你传入的所有字节，而是会返回它接收的字节数目。注意看下面的代码，如果写入的字节数与需要写入的总字节数不一致，缓冲区会自动调节去容纳它。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFWriteStreamRef</span> myWriteStream =</div><div class="line">        <span class="built_in">CFWriteStreamCreateWithFile</span>(kCFAllocatorDefault, fileURL);</div><div class="line"><span class="keyword">if</span> (!<span class="built_in">CFWriteStreamOpen</span>(myWriteStream)) &#123;</div><div class="line">    <span class="built_in">CFStreamError</span> myErr = <span class="built_in">CFWriteStreamGetError</span>(myWriteStream);</div><div class="line">    <span class="comment">// An error has occurred.</span></div><div class="line">    <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;</div><div class="line">    <span class="comment">// Interpret myErr.error as a UNIX errno.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;</div><div class="line">        <span class="comment">// Interpret myErr.error as a MacOS error code.</span></div><div class="line">        OSStatus macError = (OSStatus)myErr.error;</div><div class="line">        <span class="comment">// Check other error domains.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">UInt8</span> buf[] = “Hello, world”;</div><div class="line"><span class="built_in">CFIndex</span> bufLen = (<span class="built_in">CFIndex</span>)strlen(buf);</div><div class="line"> </div><div class="line"><span class="keyword">while</span> (!done) &#123;</div><div class="line">    <span class="built_in">CFIndex</span> bytesWritten = <span class="built_in">CFWriteStreamWrite</span>(myWriteStream, buf, (<span class="built_in">CFIndex</span>)bufLen);</div><div class="line">    <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">CFStreamError</span> error = <span class="built_in">CFWriteStreamGetError</span>(myWriteStream);</div><div class="line">        reportError(error);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">CFWriteStreamGetStatus</span>(myWriteStream) == kCFStreamStatusAtEnd) &#123;</div><div class="line">            done = <span class="literal">TRUE</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesWritten != bufLen) &#123;</div><div class="line">        <span class="comment">// Determine how much has been written and adjust the buffer</span></div><div class="line">        bufLen = bufLen - bytesWritten;</div><div class="line">        memmove(buf, buf + bytesWritten, bufLen);</div><div class="line"> </div><div class="line">        <span class="comment">// Figure out what went wrong with the write stream</span></div><div class="line">        <span class="built_in">CFStreamError</span> error = <span class="built_in">CFWriteStreamGetError</span>(myWriteStream);</div><div class="line">        reportError(error);</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">CFWriteStreamClose</span>(myWriteStream);</div><div class="line"><span class="built_in">CFRelease</span>(myWriteStream);</div><div class="line">myWriteStream = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h3 id="防止阻塞"><a href="#防止阻塞" class="headerlink" title="防止阻塞"></a>防止阻塞</h3><p>当使用流进行通信，特别是基于socket的流时，数据传输可能会耗费很长时间。如果你同步实现了流服务那整个app将会在数据传输上强制等待。因此，异常推荐使用替代方法来阻止阻塞。</p>
<p>当对CFStream对象进行读写操作时有两种方式来防止阻塞：</p>
<blockquote>
<ul>
<li>runloop——注册接收流相关事件并将stream加入到runloop中。当流相关事件发生时，回调函数会被调用。</li>
<li>调查——对于读流，在从流中读取之前检查是否有字节可读，对于写流，在写入流之前检查流是否可被写入。</li>
</ul>
</blockquote>
<h5 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h5><p>使用runloop是比较推荐的方式。runloop在主线程中运行，它会一直等待事件的发生，然后会调用与事件关联的方法。在网络传输过程中，当注册的事件发生时，回调函数会被runloop调用执行。这意味着我们不需要去检查套接字流，也就不会拖慢线程的运行效率。</p>
<p>我们以代码来进一步说明，首先创建套接字读流：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStreamCreatePairWithSocketToCFHost</span>(kCFAllocatorDefault, host, port, &amp;myReadStream, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p>其中host参数代表读流指向的主机，port参数代表主机使用的端口号，<code>CFStreamCreatePairWithSocketToCFHost</code>方法返回新的读流对象的引用并将其存储在myReadStream地址中。最后一个参数NULL代表调用者不想创建写流。如果你想创建写流，就传入对象的地址如&amp;myWriteStream。</p>
<p>在打开套接字读流之前，需要创建上下文，这在注册接收流相关事件的时候会用到：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFStreamClientContext</span> myContext = &#123;<span class="number">0</span>, myPtr, myRetain, myRelease, myCopyDesc&#125;;</div></pre></td></tr></table></figure></p>
<p>第一个参数0代表版本号，info参数即myPtr是指向你想要传给回调函数的数据的指针，通常，myPrt指向的结构体中包含的都是与流相关的信息。retain参数是指向持有info参数的方法的指针，如果你像上面代码中一样设置了它，CFStream会调用<code>myRetain(myPtr)</code>方法持有info指针。类似地，release参数是指向释放info参数方法的指针，当流与上下文断开连接，CFStream会调用<code>myRelease(myPtr)</code>方法。最后一个参数copyDescription是关于流描述信息的方法。例如，如果你用流上下文调用<code>CFCopyDesc(myReadStream)</code>方法，CFStream回你调用<code>myCopyDesc(myPtr)</code>。此外，上下文也允许将retain、release和copyDescription参数置为NULL。如果你将retain、release参数置为NULL，系统会在流对象被销毁前一直让info参数指向的内存存活。如果你将copyDescription参数置为NULL，系统会在必要的时候给出info指针指向的内存中的内容的基本描述。</p>
<p>创建完上下文后，调用<code>CFReadStreamSetClient</code>方法来注册接收流相关事件。<code>CFReadStreamSetClient</code>方法要求你指定回调方法和你想要接收的事件。下面的代码中，回调方法想要接收kCFStreamEventHasBytesAvailable, kCFStreamEventErrorOccurred和 kCFStreamEventEndEncountered事件。最后调用<code>CFReadStreamScheduleWithRunLoop</code>方法将stream添加到runloop中去。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFOptionFlags</span> registeredEvents = kCFStreamEventHasBytesAvailable | kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">CFReadStreamSetClient</span>(myReadStream, registeredEvents, myCallBack, &amp;myContext))&#123;</div><div class="line">    <span class="built_in">CFReadStreamScheduleWithRunLoop</span>(myReadStream, <span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>成功将stream添加到runloop中后，就可以打开stream了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="built_in">CFReadStreamOpen</span>(myReadStream)) &#123;</div><div class="line">    <span class="built_in">CFStreamError</span> myErr = <span class="built_in">CFReadStreamGetError</span>(myReadStream);</div><div class="line">    <span class="keyword">if</span> (myErr.error != <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// An error has occurred.</span></div><div class="line">        <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainPOSIX) &#123;</div><div class="line">        <span class="comment">// Interpret myErr.error as a UNIX errno.</span></div><div class="line">            strerror(myErr.error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (myErr.domain == kCFStreamErrorDomainMacOSStatus) &#123;</div><div class="line">            OSStatus macError = (OSStatus)myErr.error;</div><div class="line">            &#125;</div><div class="line">        <span class="comment">// Check other domains.</span></div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        <span class="comment">// start the run loop</span></div><div class="line">        <span class="built_in">CFRunLoopRun</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，等待你的回调方法被执行。在回调方法中，检查事件码并做相应的处理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> myCallBack (<span class="built_in">CFReadStreamRef</span> stream, <span class="built_in">CFStreamEventType</span> event, <span class="keyword">void</span> *myPtr) &#123;</div><div class="line">    <span class="keyword">switch</span>(event) &#123;</div><div class="line">        <span class="keyword">case</span> kCFStreamEventHasBytesAvailable:</div><div class="line">            <span class="comment">// It is safe to call CFReadStreamRead; it won’t block because bytes</span></div><div class="line">            <span class="comment">// are available.</span></div><div class="line">            <span class="built_in">UInt8</span> buf[BUFSIZE];</div><div class="line">            <span class="built_in">CFIndex</span> bytesRead = <span class="built_in">CFReadStreamRead</span>(stream, buf, BUFSIZE);</div><div class="line">            <span class="keyword">if</span> (bytesRead &gt; <span class="number">0</span>) &#123;</div><div class="line">                handleBytes(buf, bytesRead);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// It is safe to ignore a value of bytesRead that is less than or</span></div><div class="line">            <span class="comment">// equal to zero because these cases will generate other events.</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFStreamEventErrorOccurred:</div><div class="line">            <span class="built_in">CFStreamError</span> error = <span class="built_in">CFReadStreamGetError</span>(stream);</div><div class="line">            reportError(error);</div><div class="line">            <span class="built_in">CFReadStreamUnscheduleFromRunLoop</span>(stream, <span class="built_in">CFRunLoopGetCurrent</span>(),</div><div class="line">                                              kCFRunLoopCommonModes);</div><div class="line">            <span class="built_in">CFReadStreamClose</span>(stream);</div><div class="line">            <span class="built_in">CFRelease</span>(stream);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> kCFStreamEventEndEncountered:</div><div class="line">            reportCompletion();</div><div class="line">            <span class="built_in">CFReadStreamUnscheduleFromRunLoop</span>(stream, <span class="built_in">CFRunLoopGetCurrent</span>(),</div><div class="line">                                              kCFRunLoopCommonModes);</div><div class="line">            <span class="built_in">CFReadStreamClose</span>(stream);</div><div class="line">            <span class="built_in">CFRelease</span>(stream);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当回调方法接收到<code>kCFStreamEventHasBytesAvailable</code>时，会调用<code>CFReadStreamRead</code>方法读取数据。当回调方法接收到<code>kCFStreamEventErrorOccurred</code>时，会调用<code>CFReadStreamGetError</code>方法获取错误对象并调用<code>reportError</code>方法处理错误。当回调方法接收到<code>kCFStreamEventEndEncountered</code>时，会调用<code>reportCompletion</code>方法处理最后的数据，然后调用<code>CFReadStreamUnscheduleFromRunLoop</code>方法将stream对象从指定的runloop中移除。最后，调用<code>CFReadStreamClose</code>方法关闭流，调用<code>CFRelease</code>释放流对象的引用。</p>
<h5 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h5><p>总的来说，调查网络流是不推荐的。然而，在某些特殊的环境下，这种方式会比较有效。首先你要检查流是否准备好进行读写操作，然后在流上执行读写操作。当向写流中写入时，你可以<br>调用<code>CFWriteStreamCanAcceptBytes</code>方法来决定流是否开始接收数据。如果返回true，就可以确保在之后的<code>CFWriteStreamWrite</code>方法调用在不阻塞的情况下可以立即发送数据。类似地，对于读流，在调用<code>CFReadStreamRead</code>方法之前，先调用<code>CFReadStreamHasBytesAvailable</code>方法。具体的代码示例如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Polling in a read stream</span></div><div class="line"><span class="keyword">while</span> (!done) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CFReadStreamHasBytesAvailable</span>(myReadStream)) &#123;</div><div class="line">        <span class="built_in">UInt8</span> buf[BUFSIZE];</div><div class="line">        <span class="built_in">CFIndex</span> bytesRead = <span class="built_in">CFReadStreamRead</span>(myReadStream, buf, BUFSIZE);</div><div class="line">        <span class="keyword">if</span> (bytesRead &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFStreamError</span> error = <span class="built_in">CFReadStreamGetError</span>(myReadStream);</div><div class="line">            reportError(error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">CFReadStreamGetStatus</span>(myReadStream) == kCFStreamStatusAtEnd) &#123;</div><div class="line">                done = <span class="literal">TRUE</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            handleBytes(buf, bytesRead);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// ...do something else while you wait...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Polling in a write stream</span></div><div class="line"><span class="built_in">UInt8</span> buf[] = “Hello, world”;</div><div class="line"><span class="built_in">UInt32</span> bufLen = strlen(buf);</div><div class="line"> </div><div class="line"><span class="keyword">while</span> (!done) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CFWriteStreamCanAcceptBytes</span>(myWriteStream)) &#123;</div><div class="line">        <span class="keyword">int</span> bytesWritten = <span class="built_in">CFWriteStreamWrite</span>(myWriteStream, buf, strlen(buf));</div><div class="line">        <span class="keyword">if</span> (bytesWritten &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFStreamError</span> error = <span class="built_in">CFWriteStreamGetError</span>(myWriteStream);</div><div class="line">            reportError(error);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesWritten == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">CFWriteStreamGetStatus</span>(myWriteStream) == kCFStreamStatusAtEnd)</div><div class="line">            &#123;</div><div class="line">                done = <span class="literal">TRUE</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesWritten != strlen(buf)) &#123;</div><div class="line">            <span class="comment">// Determine how much has been written and adjust the buffer</span></div><div class="line">            bufLen = bufLen - bytesWritten;</div><div class="line">            memmove(buf, buf + bytesWritten, bufLen);</div><div class="line"> </div><div class="line">            <span class="comment">// Figure out what went wrong with the write stream</span></div><div class="line">            <span class="built_in">CFStreamError</span> error = <span class="built_in">CFWriteStreamGetError</span>(myWriteStream);</div><div class="line">            reportError(error);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// ...do something else while you wait...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>在stream中应用防火墙的方式有两种。对于大多数流而言，你可以调用<code>SCDynamicStoreCopyProxies</code>方法获取代理设置，然后通过设置<code>kCFStreamHTTPProxy</code>（或<code>kCFStreamFTPProxy</code>）属性将设置应用到stream中。<code>SCDynamicStoreCopyProxies</code>方法是SystemConfiguration.framework中的一部分，因此在使用该方法的时候你需要在项目中导入<code>&lt;SystemConfiguration/SystemConfiguration.h&gt;</code>。然后在你使用完之后去释放代理字典的引用，整个过程的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFDictionaryRef</span> proxyDict = SCDynamicStoreCopyProxies(<span class="literal">NULL</span>);</div><div class="line"><span class="built_in">CFReadStreamSetProperty</span>(readStream, kCFStreamPropertyHTTPProxy, proxyDict);</div></pre></td></tr></table></figure>
<p>然而，如果你需要在多个流中使用代理设置，这就会变得复杂起来。在这种情况下获得用户机器的防火墙设置需要五个步骤：</p>
<blockquote>
<p>1.创建单一持久化的指向动态存储会话<code>SCDynamicStoreRef</code>的句柄。<br>2.将句柄添加到runloop中来接收代理变化的通知。<br>3.用<code>SCDynamicStoreCopyProxies</code>方法获取最新的代理设置。<br>4.当代理设置发生改变时更新代理拷贝中的内容。<br>5.使用结束后清空<code>SCDynamicStoreRef</code>。</p>
</blockquote>
<p>我们接着以代码来详细说明。首先，调用<code>SCDynamicStoreCreate</code>方法并传入分配子、描述行为的名字、回调方法和动态存储上下文等参数来创建创建动态存储会话的句柄。这会在初始化应用程序时执行。</p>
<p>接着，我们需要将其添加到runloop中。我们要调用<code>SCDynamicStoreKeyCreateProxies</code>和<code>SCDynamicStoreSetNotificationKeys</code>方法将设置句柄来管理代理的变化，然后，再调用<code>SCDynamicStoreCreateRunLoopSource</code>和<code>CFRunLoopAddSource</code>方法将句柄添加到runloop中去。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.Create a handle to a dynamic store session</span></div><div class="line">SCDynamicStoreContext context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">systemDynamicStore = SCDynamicStoreCreate(<span class="literal">NULL</span>, <span class="built_in">CFSTR</span>(<span class="string">"SampleApp"</span>), proxyHasChanged, &amp;context);</div><div class="line"></div><div class="line"><span class="comment">// 2.Set up the store to monitor any changes to the proxies</span></div><div class="line"><span class="built_in">CFStringRef</span> proxiesKey = SCDynamicStoreKeyCreateProxies(<span class="literal">NULL</span>);</div><div class="line"><span class="built_in">CFArrayRef</span> keyArray = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)(&amp;proxiesKey), <span class="number">1</span>, &amp;kCFTypeArrayCallBacks);</div><div class="line">SCDynamicStoreSetNotificationKeys(systemDynamicStore, keyArray, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">CFRelease</span>(keyArray);</div><div class="line"><span class="built_in">CFRelease</span>(proxiesKey);</div><div class="line"> </div><div class="line"><span class="comment">// 3.Add the dynamic store to the run loop</span></div><div class="line"><span class="built_in">CFRunLoopSourceRef</span> storeRLSource =</div><div class="line">    SCDynamicStoreCreateRunLoopSource(<span class="literal">NULL</span>, systemDynamicStore, <span class="number">0</span>);</div><div class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), storeRLSource, kCFRunLoopCommonModes);</div><div class="line"><span class="built_in">CFRelease</span>(storeRLSource);</div></pre></td></tr></table></figure>
<p>一旦句柄被添加到runloop中，就可以通过调用<code>SCDynamicStoreCopyProxies</code>方法来预加载当前代理设置和代理字典。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);</div></pre></td></tr></table></figure>
<p>由于将句柄添加到runloop中，因而每次代理改变时回调方法会被调用。释放当前的代理字典并用新的代理设置来重新加载它。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> proxyHasChanged() &#123;</div><div class="line">    <span class="built_in">CFRelease</span>(gProxyDict);</div><div class="line">    gProxyDict = SCDynamicStoreCopyProxies(systemDynamicStore);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当所有的代理信息都是最新的时，应用这些代理信息。当创建了读写流后，通过调用<code>CFReadStreamSetProperty</code>和<code>CFWriteStreamSetProperty</code>方法可以设置<code>kCFStreamPropertyHTTPProxy</code>代理。以下以读流为例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFReadStreamSetProperty</span>(readStream, kCFStreamPropertyHTTPProxy, gProxyDict);</div></pre></td></tr></table></figure>
<p>当我们使用完代理设置后，确保释放字典和句柄，并将句柄从runloop中移除。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (gProxyDict) &#123;</div><div class="line">    <span class="built_in">CFRelease</span>(gProxyDict);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Invalidate the dynamic store's run loop source</span></div><div class="line"><span class="comment">// to get the store out of the run loop</span></div><div class="line"><span class="built_in">CFRunLoopSourceRef</span> rls = SCDynamicStoreCreateRunLoopSource(<span class="literal">NULL</span>, systemDynamicStore, <span class="number">0</span>);</div><div class="line"><span class="built_in">CFRunLoopSourceInvalidate</span>(rls);</div><div class="line"><span class="built_in">CFRelease</span>(rls);</div><div class="line"><span class="built_in">CFRelease</span>(systemDynamicStore);</div></pre></td></tr></table></figure></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上就是对读写流的操作的详细解释，如果发现文中有问题或错误，欢迎指出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CFNetwork学习笔记（一）]]></title>
      <url>https://iiiceblink.github.io/2016/10/05/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>提到CFNetwork框架，首先想到的是当年号称“网络终结者”的ASIHTTPRequest。ASI的底层就是基于CFNetwork开发的，现如今用的最广泛的AFNetworking框架则是基于NSURLSession开发的，相比而言，CFNetwork比NSURLSession更底层，在性能方面理论上来说CFNetwork会更好。之前没怎么研究过CFNetwork，所以决定深入研究一下。<br><a id="more"></a><br>CFNetwork是CoreServices框架中的框架，它提供了网络协议的抽象接口。这些抽象接口让直行各种网络任务变得简单起来，比如：支持与BSDScoket，HTTP，FTP服务工作，使用SSL或TLS建立加密连接，支持DNS主机解析等。</p>
<p>CFNetwork是底层且高性能的框架，它能够让我们在协议栈上进行精细地控制。它是对BSDSocket的扩展，BSDSocket是提供对象简化任务如与FTP或者HTTP服务器通信或者解析DNS主机的标准socket抽象API。</p>
<p>由于CFNetwork依赖于BSDsocket，如NSURL等的一些Cocoa类是依赖于CFNetwork实现的。此外，在视图中展示web内容的WebKit也同样依赖于CFNetwork。CFNetwork和其他一些框架的层级结构如下图所示。</p>
<p><img src="/images/CFNetwork/1.png" alt=""></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>CFNetwork继承了BSDSocket的一些优势。它集成了run-loop，如果你的应用是基于run-loop，你可以在不实现线程的情况下使用网络协议。CFNetwork也包含很多对象来帮助你不需要自己实现细节就可以使用网络协议。例如，你可以不用实现CFFTP的API而使用FTP协议。如果你理解网络协议，需要底层控制但又不想自己实现它们，这时候CFNetwork可能是很好的选择。</p>
<p>使用CFNetwork相比于Foundation级别的网络API有很多优势。CFNetwork更侧重于网络协议，而Foundation级别的网络API更侧重于数据的访问，如通过HTTP或FTP协议传输数据。Foundation级别的网络API确实提供了一些配置项，但CFNetwork提供的更多。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>在学习CFNetwork的API之前，我们必须首先理解其API的整体结构。CFNetwork依赖于两大框架：CoreFoundation，CFSocket和CFStream。理解这两个框架对于使用CFNetwork非常有必要。</p>
<h5 id="CFSocket-API"><a href="#CFSocket-API" class="headerlink" title="CFSocket API"></a>CFSocket API</h5><p>Socket是网络通信的最基础层。Socket的作用于电话插口有些类似，它允许你与另一个Socket进行连接（不管是本地的还是网络的）并且向另一个Socket发送数据。</p>
<p>最常见的socket是BSDsocket，CFSocket是对BSDsocket的抽象。CFSocket提供了几乎所有BSDsocket服务并且它将socket集成到run-loop中。CFSocket不仅仅局限于基于流服务的socket（如TCP），它可以处理任何类型的socket。</p>
<p>你可以用<code>CFSocketCreate</code>或<code>CFSocketCreateWithNative</code>函数创建CFSocket对象。然后，你可以用<code>CFSocketCreateRunLoopSource</code>函数创建run-loop源，并通过<code>CFRunLoopAddSource</code>函数添加到runloop中。之后，你可以用<code>CFSocketSendData</code>函数发送消息。当CFSocket对象接收到消息时，CFSocket函数回调会触发。</p>
<h5 id="CFStream-API"><a href="#CFStream-API" class="headerlink" title="CFStream API"></a>CFStream API</h5><p>读写流提供了在各种媒介之间交换数据的简单方式。你可以为内存，文件或网络上的数据创建流，并且可以在不一次性将所有数据加载进内存的情况下使用流。</p>
<p>流实际上是在通信路径上的连续的字节传输序列。流是单向通道，因此要进行双向通信就需要输入流和输出流。除了文件流以外，你不能在流中搜索查找，一旦流数据被接收或发送，那么就无法再从流中重新获取。</p>
<p>CFStream API提供两个新的CFType类型的对象：CFReadStream和CFWriteStream。CFStream构建在CFSocket的上层同时也是CFHTTP和CFFTP的底层。它们的层级关系见下图。</p>
<p><img src="/images/CFNetwork/2.png" alt=""></p>
<p>你可以像操作UNIX文件描述子的形式来使用读写流。首先，你需要指定流的类型（内存，文件或Socket）并设置可选项来实例化流对象。接着，你打开流进行读和写操作。当流对象已经存在，你可以通过访问它的属性来获取流对象的相关信息。当你不再需要它时，关闭并释放它。</p>
<p>CFStream的读写方法会一直处于挂起或者阻塞状态直到有数据可读或可写的时候才会结束挂起或阻塞状态。为了避免读写过程中流可能处于阻塞状态，使用异步方法并将其编排进runloop中。当读写操作不会被阻塞时回调方法会触发。</p>
<p>另外，CFStream本身还支持SSL（Secure Sockets Layer）协议。你可以将流的SSL信息存储进一个字典对象中，然后将字典对象传给stream对象的kCFStreamPropertySSLSettings属性。</p>
<h3 id="CFNetwork-API概览"><a href="#CFNetwork-API概览" class="headerlink" title="CFNetwork API概览"></a>CFNetwork API概览</h3><p>为了理解CFNetwork框架，你需要熟悉构成该框架的各个组成块。CFNetwork框架可以被拆解成几个独立的API，每个独立的API覆盖了不同的网络协议。这些API可以组合使用也可以单独使用，这取决于你自己的需求。</p>
<h5 id="CFFTP-API"><a href="#CFFTP-API" class="headerlink" title="CFFTP API"></a>CFFTP API</h5><p>CFFTP可以帮我们与FTP服务器进行通信。使用CFFTP API可以创建读流负责下载，创建写流负责上传。使用读写流可以实现如下功能：</p>
<blockquote>
<ul>
<li>从FTP服务器上下载文件</li>
<li>向FTP服务器上传文件</li>
<li>从FTP服务器下载目录列表</li>
<li>在FTP服务器上创建目录</li>
</ul>
</blockquote>
<p>FTP流对象工作原理与其他的CFNetwork流一样。例如，你可以通过调用<code>CFReadStreamCreateWithFTPURL</code>方法创建FTP读流，然后，调用<code>CFReadStreamGetError</code>在任何时候检查流的状态。</p>
<p>通过设定FTP流的属性，你可以自定义流来满足你的需求。例如，如果流连接的服务器要求用户名和密码，你需要设置正确的属性这样流对象才能正确地进行工作。</p>
<p>CFFTP流可以使用同步或异步。创建完读流对象后，为了打开指定的FTP服务器的连接需要调用<code>CFReadStreamOpen</code>方法。为了从流中读取数据，可以调用<code>CFReadStreamRead</code>方法。<code>CFReadStreamRead</code>方法将FTP服务器的输出填充到缓冲区中。</p>
<h6 id="CFHTTP-API"><a href="#CFHTTP-API" class="headerlink" title="CFHTTP API"></a>CFHTTP API</h6><p>为了能收发HTTP消息，我们使用CFHTTP API。正如CFFTP是对FTP协议的抽象，CFHTTP是对HTTP协议的抽象。</p>
<p>HTTP协议是在客户端和服务端之间的请求/响应协议。客户端创建请求消息，进程会将消息转换成的原始字节流，这是序列化的过程。这一步是非常必要的，否则消息无法被发送出去。然后，消息会被发送到服务器上。服务器响应会发送带有字符串的消息给客户端。如果有必要这一步操作会重复多次。</p>
<p>要创建HTTP请求消息，你需要指定下面的属性：</p>
<blockquote>
<ul>
<li>请求方法，如OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT</li>
<li>URL</li>
<li>HTTP版本，如1.0或1.1</li>
<li>消息头，通过指定头部名字和它的值，如User-Agent ： MyUserAgent</li>
<li>消息体</li>
</ul>
</blockquote>
<p>消息构建完后再对其进行序列化。序列化完成后，请求会像下面的形式：</p>
<blockquote>
<p>GET / HTTP/1.0\r\nUser-Agent: UserAgent\r\nContent-Length: 0\r\n\r\n</p>
</blockquote>
<p>反序列化是对序列化的逆操作。从服务端或客户端接收到的原始字节流通过反序列化会重新存储成它原始的表现形式。CFNetwork提供了所有关于获取接收到的序列化的消息的消息类型，HTTP版本，URL，消息头，消息体信息的方法。</p>
<h6 id="CFHTTPAuthentication-API"><a href="#CFHTTPAuthentication-API" class="headerlink" title="CFHTTPAuthentication API"></a>CFHTTPAuthentication API</h6><p>如果你给认证服务器发送HTTP请求却没有证书或者是错误的证书，服务器会返回认证错误，通常错误码是401或407。CFHTTPAuthentication API支持认证证书设置，其支持以下的认证模式：</p>
<blockquote>
<ul>
<li>Basic</li>
<li>Digest</li>
<li>NT LAN Manager</li>
<li>Simple and Protected GSS-API Negotiation Mechanism（SPNEGO）</li>
</ul>
</blockquote>
<p>现在，你可以将每个服务器对应的CFHTTPAuthentication对象保存到集合中。当你接收到401货407响应时，你需要找到服务器对应的正确的对象和证书并且应用它们。CFNetwork使用存储在认证对象中的信息来提高请求的效率。</p>
<h5 id="CFHost-API"><a href="#CFHost-API" class="headerlink" title="CFHost API"></a>CFHost API</h5><p>通过调用CFHost API请求主机信息，包括名字，地址和可访问的信息。请求主机信息的进程叫做resolution。</p>
<p>CFHost使用方法与CFStream相似：</p>
<blockquote>
<ul>
<li>创建CFHost对象</li>
<li>开始解析CFHost对象</li>
<li>重新获取地址，主机名或者是否可访问的信息</li>
<li>销毁CFHost对象</li>
</ul>
</blockquote>
<p>跟所有的CFNetwork类一样，CFHost兼容IPv4和IPv6。使用CFHost，你可以写代码去处理IPv4和IPv6的情况。CFHost被集成到其他的CFNetwork的类中。例如，有一个CFStream的方法叫<code>CFStreamCreatePairWithSocketToCFHost</code>，它会直接从一个CFHost对象中创建CFStream对象。</p>
<h5 id="CFNetServices-API"><a href="#CFNetServices-API" class="headerlink" title="CFNetServices API"></a>CFNetServices API</h5><p>如果你想要你的app使用Bonjour服务来注册服务或者发现服务，那就使用CFNetServices API。Bonjour是苹果的零配置网络的实现，它允许你创建，发现，解析网络服务。</p>
<p>想要实现Bonjour，CFNetServices API定义了三种类型： CFNetService, CFNetServiceBrowser, CFNetServiceMonitor。CFNetService对象代表单独的网络服务，如打印机或者文件服务器。它包含另外的电脑解析服务所需要的所有信息，如名字，类型，域名和端口号。CFNetServiceBrowser对象用来发现域名和域名指向的网络服务。CFNetServiceMonitor对象用来管理CFNetService对象内容的更改，如iChat中的状态消息。</p>
<h5 id="CFNetDiagnostics-API"><a href="#CFNetDiagnostics-API" class="headerlink" title="CFNetDiagnostics API"></a>CFNetDiagnostics API</h5><p>app连接网络服务依赖于稳定的连接。如果网络断开，便会引起问题。使用CFNetDiagnostics API，用户可以自己诊断网络问题，例如：</p>
<blockquote>
<ul>
<li>物理连接失败，如网口没插好</li>
<li>网络失败，如DNS或DHCP服务器无法响应</li>
<li>配置失败，如代理配置不正确</li>
</ul>
</blockquote>
<p>一旦网络失败被诊断，CFNetDiagnostics会指导用户去修复问题。在Safari连接网络失败后你可能已经看到过CFNetDiagnostics做出的反应。CFNetDiagnostics助手如下图所示：</p>
<p><img src="/images/CFNetwork/3.png" alt=""></p>
<p>向CFNetDiagnostics提供网络错误的上下文，你可以告诉<code>CFNetDiagnosticDiagnoseProblemInteractively</code>方法来引导用户尝试去找到解决方案。另外，你可以用CFNetDiagnostics去查询连接状态并且向用户传递错误消息。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上只是对CFNetwork框架的概览，至于更详细的使用会在后面的文章中罗列出来。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[dumpdecrypted砸壳记录]]></title>
      <url>https://iiiceblink.github.io/2016/10/03/dumpdecrypted%E7%A0%B8%E5%A3%B3%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前一直采用Clutch对ipa包进行砸壳，后来发现Clutch在某些iOS版本下砸壳会失效，故而放弃了Clutch而采用dumpdecrypted。本篇文章就是记录用dumpdecrypted砸壳的过程以及其中的注意点。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>砸壳需要的东西：</p>
<blockquote>
<ul>
<li><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="external">dumpdecrypted</a></li>
<li>越狱的iOS设备</li>
<li>OpenSSH（Cydia）</li>
<li>iFile（Cydia）</li>
<li>Cycript（Cydia）</li>
<li>XCode</li>
<li>Command Line Tools</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="编译dumpdecrypted"><a href="#编译dumpdecrypted" class="headerlink" title="编译dumpdecrypted"></a>编译dumpdecrypted</h3><p>从Github上下载最新的dumpdecrypted源码，在命令行中进入进入源码的目录下，输入make进行编译生成dumpdecrypted.dylib。这里有一点需要注意，编译时依赖的XCode的SDK版本需要兼容iOS越狱设备的系统版本。比如，我当前XCode的SDK版本是iOS10.0，而我的越狱设备的系统版本是iOS 9.3.1，按照当前配置编译出来的dumpdecrypted.dylib在设备上进行砸壳是会失败的。那如何知道Xcode当前的SDK版本呢？我们可以在命令行中输入命令：xcrun –sdk iphoneos –show-sdk-path。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.0.sdk</div></pre></td></tr></table></figure></p>
<p>若SDK版本不兼容怎么办？可以在<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">这里</a>下载过往版本的SDK。把下载的SDK替换当前SDK的位置，当然别忘了把当前SDK备份，或者用xcode-select命令指定一个活动的XCode。最后再make，成功，输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted.o dumpdecrypted.c</div><div class="line">`xcrun --sdk iphoneos --find gcc` -Os  -Wimplicit -isysroot `xcrun --sdk iphoneos --show-sdk-path` -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/Frameworks -F`xcrun --sdk iphoneos --show-sdk-path`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted.dylib dumpdecrypted.o</div><div class="line"></div><div class="line">$ ls</div><div class="line">Makefile          dumpdecrypted.c          dumpdecrypted.o</div><div class="line">README               dumpdecrypted.dylib</div></pre></td></tr></table></figure></p>
<p>再看目录下多出了两个文件：<code>dumpdecrypted.o</code>和<code>dumpdecrypted.dylib</code>，其中<code>dumpdecrypted.dylib</code>是我们用来砸壳的锤子。</p>
<h3 id="配置iOS越狱设备"><a href="#配置iOS越狱设备" class="headerlink" title="配置iOS越狱设备"></a>配置iOS越狱设备</h3><p>进入越狱设备的Cydia中下载安装<strong><em>OpenSSH</em></strong>、<strong><em>Cycript</em></strong>、<strong><em>iFile</em></strong>。在越狱设备上安装上需要砸壳的APP。</p>
<p>在Mac命令行中通过SSH连接iOS设备，这里必须确保iOS设备与mac电脑处于同一无线网络下，OpenSSH的默认密码是alpine。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 192.168.xx.xx为iOS设备在wifi下的IP地址</div><div class="line">ssh root@192.168.xx.xx</div></pre></td></tr></table></figure>
<p>连接成功后，需要找到砸壳APP的bundle id了，我们可以把除砸壳APP的所有其他APP关掉，在命令行中输入：ps -e命令。以微信为例，我们可以看到微信的bundle id为WeChat。</p>
<p><img src="/images/dumpdecrypted/1.png" alt=""></p>
<p>知道了bundle id，我们就可以通过Cycript找到微信Documents路径，在命令行中输入：cycript -p WeChat，再输入：NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES)[0]。</p>
<p><img src="/images/dumpdecrypted/2.png" alt=""></p>
<p>记下bundle id和Documents的路径，后面会用到。</p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>将dumpdecrypted.dylib拷贝到iOS越狱设备上，这里可以用像iTools、iFunBox工具，我用的是scp命令将其传到iOS设备。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ scp dumpdecrypted.dylib root@192.168.xxx.xxx:/usr/lib</div><div class="line">root@192.168.xxx.xxx<span class="string">'s password:</span></div><div class="line">dumpdecrypted.dylib                           100%   81KB  81.0KB/</div></pre></td></tr></table></figure></p>
<p>注意，若你的设备是iOS 9.3以上，可能会在后面的砸壳中出现错误，所以，推荐将<code>dumpdecrypted.dylib</code>传到/usr/lib目录下。</p>
<p>在命令行中切换到/usr/lib目录下，输入砸壳命令：DYLD_INSERT_LIBRARIES=”dumpdecrypted.dylib的路径” “app的Bundle id的路径”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">root<span class="comment"># DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Applications/EBBD26E9-DDBA-481E-9403-84D159436889/HBGC.app/HBGC</span></div><div class="line">mach-o decryption dumper</div><div class="line"></div><div class="line">DISCLAIMER: This tool is only meant <span class="keyword">for</span> security research purposes, not <span class="keyword">for</span> application crackers.</div><div class="line"></div><div class="line">[+] detected 32bit ARM binary <span class="keyword">in</span> memory.</div><div class="line">[+] offset to cryptid found: @0xd5a90(from 0xd5000) = a90</div><div class="line">[+] Found encrypted data at address 00004000 of length 3047424 bytes - <span class="built_in">type</span> 1.</div><div class="line">[+] Opening /private/var/mobile/Applications/EBBD26E9-DDBA-481E-9403-84D159436889/HBGC.app/HBGC <span class="keyword">for</span> reading.</div><div class="line">[+] Reading header</div><div class="line">[+] Detecting header <span class="built_in">type</span></div><div class="line">[+] Executable is a FAT image - searching <span class="keyword">for</span> right architecture</div><div class="line">[+] Correct arch is at offset 16384 <span class="keyword">in</span> the file</div><div class="line">[+] Opening HBGC.decrypted <span class="keyword">for</span> writing.</div><div class="line">[+] Copying the not encrypted start of the file</div><div class="line">[+] Dumping the decrypted data into the file</div><div class="line">[+] Copying the not encrypted remainder of the file</div><div class="line">[+] Setting the LC_ENCRYPTION_INFO-&gt;cryptid to 0 at offset 4a90</div><div class="line">[+] Closing original file</div><div class="line">[+] Closing dump file</div></pre></td></tr></table></figure>
<p>到此，砸壳工作就完成了。这里还有一点说明，StoreApp对沙盒以外的其他大多数目录没有写权限。除了/usr/lib外，你还可以把dumpdecrypted.dylib拷贝到Documents目录下操作。如果不放在Documents目录下，可能会出现下面的问题：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FunMaker-5: /var/mobile/Containers/Data/Application/D41C4343-63AA-4BFF-904B-2146128611EE/Documents root<span class="comment"># mv dumpdecrypted.dylib /var/tmp/</span></div><div class="line">FunMaker-5: /var/mobile/Containers/Data/Application/D41C4343-63AA-4BFF-904B-2146128611EE/Documents root<span class="comment"># cd /var/tmp</span></div><div class="line">FunMaker-5:/var/tmp root<span class="comment"># DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /private/var/mobile/Containers/Bundle/Application/03B61840-2349-4559-B28E-0E2C6541F879/TargetApp.app/TargetApp</span></div><div class="line">dyld: could not load inserted library <span class="string">'dumpdecrypted.dylib'</span> because no suitable image found.  Did find:</div><div class="line">        dumpdecrypted.dylib: <span class="built_in">stat</span>() failed with errno=1</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS OpenDev踩坑记录]]></title>
      <url>https://iiiceblink.github.io/2016/09/20/iOS%20OpenDev%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在研究iOS逆向工程，需要用到iOSDev工具，心想那就安装呗，多大点事儿。谁知道自己有点too young too simple，原以为下载完安装包再按步骤点点点就完了，谁知道到了最后一步，它给我来个安装失败。真是没有一点点防备啊，于是各种找办法解决安装问题，最终解决了，于是，决定把解决的过程写下来，方便以后回顾。<br><a id="more"></a><br><img src="/images/openDev/1.png" alt=""></p>
<h3 id="安装必要的软件包和工具"><a href="#安装必要的软件包和工具" class="headerlink" title="安装必要的软件包和工具"></a>安装必要的软件包和工具</h3><p>1.安装MacPort。在<a href="https://www.macports.org/install.php" target="_blank" rel="external">官网</a>根据当前电脑系统下载对应的pkg安装包，然后进行安装。安装过程会很慢，建议全程开启VPN会好一些。</p>
<p>2.更新MacPort。在命令行中输入命令进行更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port -v selfupdate</div></pre></td></tr></table></figure></p>
<p>3.安装dpkg工具。在命令行中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo port <span class="_">-f</span> install dpkg</div></pre></td></tr></table></figure></p>
<p>4.安装theos工具。首先，打开环境变量配置文件，并添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> THEOS=/opt/theos</div></pre></td></tr></table></figure>
<p>然后，下载兼容iOSOpenDev版本的theos，在命令行中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> -b stableversion https://github.com/haorenqq/theos/ <span class="variable">$THEOS</span></div></pre></td></tr></table></figure></p>
<h3 id="修改Xcode目录文件"><a href="#修改Xcode目录文件" class="headerlink" title="修改Xcode目录文件"></a>修改Xcode目录文件</h3><p>由于Xcode更新后的文件位置移动，自Xcode 7开始不支持dylib，我们需要把缺失的文件放到指定目录下。我们可以从<a href="https://github.com/heardrwt/RHObjectiveBeagle/tree/master/libBeagle/Xcode%20iOS%20dylib%20Support" target="_blank" rel="external">这里</a>下载所需要的四个文件。然后，在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/“路径下创建名为”Specifications”文件夹，并将名为”iPhoneOSPackageTypes.xcspec”和”iPhoneOSProductTypes.xcspec”的文件复制到该文件夹下。同样的操作发生在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode”路径下，只不过是将名为”iPhone Simulator PackageTypes.xcspec”和”iPhone Simulator ProductTypes.xcspec”的文件放到”Specifications”文件夹下。之后，在”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer”路径下创建名为”usr”的文件夹，并且在该文件夹内创建名为”bin”的文件夹。</p>
<h3 id="安装iOSOpenDev，运行脚本"><a href="#安装iOSOpenDev，运行脚本" class="headerlink" title="安装iOSOpenDev，运行脚本"></a>安装iOSOpenDev，运行脚本</h3><p>打开iOSOpenDev安装包进行安装，结果肯定又是安装失败。别急，继续按照步骤走。进入/opt目录下，我们会发现有名为iosopendevsetup的文件夹，并且在该文件夹下的bin目录下有一个叫iod-setup的脚本，在命令行中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ./iod-setup base</div><div class="line">sudo ./iod-setup sdk -sdk iphoneos</div></pre></td></tr></table></figure></p>
<p>之后，一切就OK了。重启Xcode，新建项目，就可以看到iOSOpenDev了。</p>
<p><img src="/images/openDev/2.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS APP砸壳小记]]></title>
      <url>https://iiiceblink.github.io/2016/09/18/iOS%20APP%E7%A0%B8%E5%A3%B3%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在逆向工程中，砸壳是很必要并且不可缺少的一个步骤。所谓“壳”，其实就是苹果给应用加密的一层保护，我们只要是从APP Store上下载的APP都是带壳的。带壳的APP是无法进行class-dump以及hook等操作，因此，需要对APP进行砸壳。接下来，我以微信为例来进行砸壳。<br><a id="more"></a></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>要能顺利完成砸壳需要四样东西：</p>
<blockquote>
<ul>
<li>电脑</li>
<li>越狱后的iOS设备</li>
<li>AppStore下载的待砸壳的app</li>
<li>Clutch砸壳工具</li>
</ul>
</blockquote>
<p>我用的是MacBookPro+iPad（iOS 9.3.1）组合，微信直接从AppStore上下载即可。Clutch则是到其<a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="external">github地址</a>下载最新的release版本。</p>
<h3 id="iOS设备上导入Clutch"><a href="#iOS设备上导入Clutch" class="headerlink" title="iOS设备上导入Clutch"></a>iOS设备上导入Clutch</h3><p>要能对微信进行砸壳，就要把砸壳工具Clutch导入到iPad的指定目录下。熟悉Linux的人肯定对ssh不陌生，我这里采用的也是通过ssh将clutch工具传输到iPad上。默认情况下，iOS设备是不支持ssh，所以，我们要在Cydia商店中下载名叫“OpenSSH”的插件。</p>
<p><img src="/images/clutchApp/1.png" alt=""></p>
<p>安装好后，要能让电脑和iPad进行ssh连接，就要保证两者在同一个无线网络下。然后，查看iPad在wifi下的IP地址。</p>
<p><img src="/images/clutchApp/2.png" alt=""></p>
<p>在电脑的命令行中输入：scp “Clutch路径” root@”iOS设备IP地址”:/usr/bin。回车后会提示输入密码，iOS设备默认的密码是“alpine”。</p>
<p><img src="/images/clutchApp/3.png" alt=""></p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>成功将Clutch工具包导入到/usr/bin目录下后，在命令行中ssh连接iPad，密码与之前的一致。连接成功后切换到/usr/bin目录下。</p>
<p><img src="/images/clutchApp/4.png" alt=""></p>
<p>输入命令：Clutch -i。Clutch是工具包的名字，如果你的包名是Clutch-2.0.4，则输入Clutch-2.0.4 -i。该命令获取的是所有已安装的APP。</p>
<p><img src="/images/clutchApp/5.png" alt=""></p>
<p>根据获取的结果，输入命令：Clutch -d(或者b) 33。该命令是对指定的app进行砸壳，d代表输出ipa包，b代表输出二进制文件，33是微信在安装列表中的编号。砸壳成功后，它会将砸壳后的ipa包的路径显示出来，比如我这里砸壳后的ipa包路径是：/private/var/mobile/Documents/Dumped/com.tencent.xin-iOS7.0-(Clutch-2.0.4).ipa。</p>
<p><img src="/images/clutchApp/6.png" alt=""></p>
<p>最后通过ssh将砸壳后的ipa传到电脑上。</p>
<p><img src="/images/clutchApp/7.png" alt=""></p>
<h3 id="class-dump导出头文件"><a href="#class-dump导出头文件" class="headerlink" title="class-dump导出头文件"></a>class-dump导出头文件</h3><p>class-dump可以从Mach-O的section中还原出OC代码的头文件。我们可以从这个<a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="external">地址</a>获取下载地址。我下载的是<a href="http://stevenygard.com/download/class-dump-3.5.dmg" target="_blank" rel="external">class-dump-3.5.dmg</a>，双击安装，将可执行文件移动到/usr/bin目录下，这样就可以在命令行下直接调用”class-dump”命令了。在移动的过程中遇到一点小问题，操作被拒绝，研究了一下才知道自OS X 10.11 EI Capitan开始，系统启用了SIP(System Integrity Protection)，导致root用户也没有权限修改/usr/bin目录。解决方案是重启电脑按住command+R进入recovery模式，在命令行中输入”csrutil disable”并重启。</p>
<p>移动文件成功后，打开命令行，输入：class-dump，命令行会显示class-dump用法。</p>
<p><img src="/images/clutchApp/8.png" alt=""></p>
<p>将先前砸完壳的微信ipa包解压，在Pyload文件夹下操作WeChat.app显示包内容，得到如下目录：</p>
<p><img src="/images/clutchApp/9.png" alt=""></p>
<p>在命令行中输入：class-dump -H “Mach-O文件路径” -O “输出头文件的路径”。若不加-O，则会在当前目录下输出头文件。</p>
<p><img src="/images/clutchApp/10.png" alt=""></p>
<p>输完命令回车后，在输出目录下就可以看到一大堆头文件。</p>
<p><img src="/images/clutchApp/11.png" alt=""></p>
<p>砸壳过程到此就全部完成了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS APP中调用私有方法]]></title>
      <url>https://iiiceblink.github.io/2016/09/04/iOS%20APP%E4%B8%AD%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>得益于苹果封闭的生态系统，iOS平台才能如此优秀和健壮。然而，对于开发者而言，开源永远是最受欢迎的，闭源只会让开发者束手束脚。我们在开发的过程中可能会遇到有需求需要依赖于iOS私有API，但由于iOS的封闭，我们无法直接调用私有方法，这让人很是头疼。那有没有方法能让我们在不越狱的情况下去调用私有API呢？<br><a id="more"></a><br>答案是有的，并且就我目前了解而言有两种方案。为了更好地解释这两种方案，我写了个小Demo。在Demo中只有一个类<code>TestClass</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestClass.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)publicMethod;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TestClass.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestClass</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)publicMethod&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Call public method"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)privateMethod&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"call private method"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这个类中有两个方法：<code>publicMethod</code>和<code>privateMethod</code>。其中，<code>publicMethod</code>是公有方法，<code>privateMethod</code>是私有方法。如果我们直接在实例中调用<code>privateMethod</code>，会得到”No visible @interface for ‘TestClass’ declares the selector ‘privateMethod’”的错误。因此，直接调用私有方法肯定是行不通的，那就换个套路试试。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        TestClass *obj = [[TestClass alloc] init];</div><div class="line">        [obj privateMethod];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="利用runtime特性"><a href="#利用runtime特性" class="headerlink" title="利用runtime特性"></a>利用runtime特性</h3><p>这里需要用到两个runtime相关的方法：<code>respondsToSelector:</code>和<code>performSelector:</code>。前者是用来判断类或者类实例是否实现了某个方法选择子，后者是调用指定的方法选择子。</p>
<p>这里提一下<code>performSelector:</code>与直接调用方法之间的区别。由于OC的运行时，使得程序可以在运行时动态添加方法，因此在编译时动态方法是不存在的。为了能调用动态方法，就有了<code>performSelector:</code>。因此两者的区别就在于直接调用方法在编译期是会自动校验公有方法，若不存在该方法则编译无法通过，而调用<code>performSelector:</code>则在编译期不会进行校验，它会在运行时去查找并调用指定方法，若运行时找不到指定方法则会发生崩溃。考虑到程序的健壮性，会先调用<code>respondsToSelector:</code>检查方法是否存在。</p>
<p>采用该方案去调用<code>privateMethod</code>的正确做法应该是这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        TestClass *obj = [[TestClass alloc] init];</div><div class="line">        <span class="keyword">if</span> ([obj respondsToSelector:<span class="keyword">@selector</span>(privateMethod)]) &#123;</div><div class="line">            [obj performSelector:<span class="keyword">@selector</span>(privateMethod)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="匿名category欺骗编译器"><a href="#匿名category欺骗编译器" class="headerlink" title="匿名category欺骗编译器"></a>匿名category欺骗编译器</h3><p>从刚才的方案中我们知道，直接调用方法会失败是因为编译器自动校验失败而报错，那如果我们欺骗编译器让它误以为校验的方法存在呢？这倒是个不错的思路，第二个方案也就由此产生。那就是写一个匿名的category声明想要调用的私有方法，这样编译器就会认为该方法存在而不会报错。</p>
<p>采用该方案调用<code>privateMethod</code>的正确姿势是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"TestClass.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestClass</span>()</span></div><div class="line">- (<span class="keyword">void</span>)privateMethod;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        TestClass *obj = [[TestClass alloc] init];</div><div class="line">        [obj privateMethod];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>理论上这两种方法均可以实现对私有API的调用，不过，我更推荐第一种方案。因为第一种方案在程序的健壮性上会更好，并且书写上也更简单。友情提醒，可以在程序中调用私有API并不意味着就可以通过苹果的审核。其实，我也不太懂苹果的审核机制，有些APP调用私有API可以通过审核，有些APP则会被拒绝，所以，要想通过审核往往是要碰运气的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拆解ARC下的self]]></title>
      <url>https://iiiceblink.github.io/2016/08/24/%E6%8B%86%E8%A7%A3ARC%E4%B8%8B%E7%9A%84self/</url>
      <content type="html"><![CDATA[<p>最近在研究AFNetworking源码的过程中碰到了很多处地方用到了<code>weakSelf</code>和<code>strongSelf</code>。依据自己之前的理解，正常情况下使用<code>weakSelf</code>是为了避免发生循环引用，而使用<code>strongSelf</code>是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。</p>
<h3 id="self的本质"><a href="#self的本质" class="headerlink" title="self的本质"></a>self的本质</h3><p>self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是<code>const Class self</code>，在实例方法中self是<code>Person const* self</code>（以Person类举例）。事实确实如此么？来验证一下。</p>
<a id="more"></a>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)eat&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)classEat&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)drink:(<span class="built_in">NSString</span> *)sth&#123;</div><div class="line">    [<span class="keyword">self</span> eat];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>将Person.m用clang命令进行重写，得到的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Person_eat(Person * <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="keyword">id</span> obj = ((Person *(*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"Person"</span>))&#125;, sel_registerName(<span class="string">"init"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _C_Person_classEat(Class <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Person_drink_(Person * <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *sth) &#123;</div><div class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"eat"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从重写后的代码中可以看出结论是正确的，但还是没有找到self在方法执行过程中可能被释放的原因。我又查阅了<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self" target="_blank" rel="external">Clang</a>的官方文档,找到了其中关于self的说明：</p>
<blockquote>
<p>The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object.</p>
<p>To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method.</p>
</blockquote>
<p>翻译过来就是在OC方法中作为参数的self不会被方法的实现持有，当给self指向的对象发送消息时确实可能会发生错误。为了确保安全，除非是在init及类init的方法中，否则在OC的实例方法和类方法中self始终是指针常量无法被retain。根据我的理解整理如下：</p>
<ol>
<li><p>在ARC中，self的修饰符是<strong>unsafe_unretained，而不是</strong>strong。<strong>unsafe_unretained与weak类似，均是对对象的弱引用，区别在于当</strong>unsafe_unretained的指针指向的对象被释放后，指针仍会指向被释放对象的内存地址，变成野指针导致crash，而当<strong>weak的指针指向的对象被释放后，指针指向的对象会被置为nil。正是由于</strong>unsafe_unretained修饰符的作用，因此会导致在方法执行的过程若self被释放则会引起crash。</p>
</li>
<li><p>OC方法不会对self自动retain（除了init方法族以外），self在方法运行过程中的生命周期需要由程序员自己手动实现来保证。通常的做法也就是在方法中添加一个局部变量strongSelf来对self指向的对象进行强引用来保证在方法执行完之前self都不会被释放。</p>
</li>
<li><p>对self采用__unsafe_unretained修饰符，主要是为了性能方面的考虑。通常调用一个方法被runtime改写成objc_msgSend()后，传入的第一个参数都是self，从上面clang重写的代码中也可以看出。若是在方法调用中对self进行retain和release，确实可以保证方法执行过程中self不会被释放，但是，会对性能产生很大影响。并且在大多数方法调用过程中，self是不会被释放的，因此，不对self进行reatain和release操作所带来的性能提升是值得的。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CallKit学习笔记]]></title>
      <url>https://iiiceblink.github.io/2016/07/30/CallKit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>近几年4G大规模的普及使得VoIP（Voice over Internet Protocol）变得可靠和稳定。iOS 10开始全面支持VOIP，于是推出了<code>CallKit</code>框架。</p>
<p><code>CallKit</code>框架能让你的第三方VoIP应用程序获得原声应用程序的体验效果。为了能更好得讲述<code>CallKit</code>新特性，我们以一个第三方VoIP应用程序——“Speakerbox”举例来说明。<br><a id="more"></a><br>在iOS 10之前，当用户收到“Speakerbox”的电话时的界面如同下图。在锁屏状态下，我们无法区分iMessage和VoIP电话的区别，它只是一则通知。如果想要接听“Speakerbox”中的来电，我们需要先右滑通知，输入密码，进入app才能接听电话。这是非常糟糕的体验。而在解锁状态下，来电会显示为一条横幅，我们有时候可能会错过这些通知，这样的体验也是很糟糕的。</p>
<p><img src="/images/callkit/1.png" alt=""></p>
<p><img src="/images/callkit/2.png" alt=""></p>
<p>在iOS 10中，“Speakerbox”可以像原生电话UI那样接听和显示VoIP通话。</p>
<p><img src="/images/callkit/3.png" alt=""></p>
<p><img src="/images/callkit/4.png" alt=""></p>
<p><img src="/images/callkit/5.png" alt=""></p>
<h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>在iOS 10以前，像系统服务如蓝牙、Siri、CarPlay与VoIP的应用程序如“Speakerbox”是相互独立的两部分。在iOS 10中，通过<code>CallKit</code>框架可以将两者连接起来，现在在“Speakerbox”上发起的通信电话可以被系统获取然后系统会与目的设备之间建立起通信。</p>
<p><img src="/images/callkit/6.png" alt=""></p>
<p>现在我们进一步来聊聊“Speakerbox”。在下图中，我们有“Speakerbox”以及它所有的代码，它与网络进行通信并有自己的UI。接下来，我们要与<code>CallKit</code>连接。这里有两个类需要我们着重去注意，分别是<code>CXProvider</code>和<code>CXCallController</code>。</p>
<blockquote>
<h5 id="CXProvider"><a href="#CXProvider" class="headerlink" title="CXProvider"></a>CXProvider</h5><p>Out-of-band nontifications<br>Not user actions<br>External events</p>
<ul>
<li>incoming calls</li>
</ul>
<h5 id="CXCallController"><a href="#CXCallController" class="headerlink" title="CXCallController"></a>CXCallController</h5><p>Requests from app<br>Local user actions<br>Internal events</p>
<ul>
<li>Start call</li>
</ul>
</blockquote>
<p><code>CXProvider</code>的作用是告知系统所有的带外（out-of-band）通知信息。带外通知的意思是指非用户操作而是外在真实发生的事件，比如来电（incoming call）。</p>
<p><code>CXCallController</code>的作用是让系统感知来自于app自身的请求。这里的请求是真实的用户操作就像内部事件，如开始通话操作。<code>CXCallController</code>会与系统上其他的通话产生相互影响。例如，用户已经处于通话状态了，而他还想通过“Speakerbox”再开启一个通话。这时候<code>CXCallController</code>会告诉系统用户的开启通话的操作，系统会告知通话提供者保持当前的通话，这样可以让“Speakerbox”开始它的通话。</p>
<p>所以，当<code>CXProvider</code>想与系统进行通信时它会使用<code>CSXCallUpdate</code>类，当系统想让“Speakerbox”接收用户操作，它会使用<code>CXAction</code>类来让“Speakerbox”知道。<code>CXCallController</code>会将这些用户操作装进<code>CSTransaction</code>对象中来告知系统用户产生的操作。</p>
<p><img src="/images/callkit/7.png" alt=""></p>
<p>现在我们来看看来电的整体工作流程。现在比如说一个叫做Jane的人收到了来自他妈妈的来电通话请求。“Speakerbox”收到了来电，然后会创建<code>CXCallUpdate</code>对象并通过<code>CXProvider</code>发送给系统。接着，系统将来电告知包括UI的所有服务。如果Jane想应答，Jane可以通过通话界面的应答按钮接通通话。这时候系统会告诉“Speakerbox”只要它需要随时可以接通来电通话。如果Jane想通过操作app的UI来结束通话，<code>CXCallController</code>会将结束action打包进一个<code>CXTransaction</code>对象中并将其发送给系统。如果一切ok，系统会通过<code>CXProvider</code>将其发送给“Speakerbox”，这样“Speakerbox”就可以随时结束通话。</p>
<p><img src="/images/callkit/8.png" alt=""></p>
<p><img src="/images/callkit/9.png" alt=""></p>
<h5 id="Incoming-Call"><a href="#Incoming-Call" class="headerlink" title="Incoming Call"></a>Incoming Call</h5><p>下面以代码的形式简要概述来电发生的过程：</p>
<p>1.将来电信息通知到系统<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provider.reportNewIncomingCall(with: <span class="type">UUID</span>, update: <span class="type">CXCallUpdate</span>) &#123; error <span class="keyword">in</span> <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>2.用户点击通话按钮进行通话，<code>ProviderDelegate</code>会调用<code>PerformAnswerCallAction</code>方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">provider</span><span class="params">(<span class="number">_</span> provider: CXProvider, perform action: CXAnswerCallAction)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>3.当用户真正地在通话时，<code>CXAnswerCallAction</code>会执行<code>fulfill</code>方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">answerCallAction.fulfill()</div></pre></td></tr></table></figure></p>
<h5 id="Call-Actions"><a href="#Call-Actions" class="headerlink" title="Call Actions"></a>Call Actions</h5><p>以下列出了所有的callAction类型：</p>
<blockquote>
<ul>
<li>CXAnswerCallAction</li>
<li>CXStartCallAction</li>
<li>CXEndCallAction</li>
<li>CXSetHeldCallAction</li>
<li>CXSetGroupCallAction</li>
<li>CXPlayDTMFCallAction</li>
<li>CXSetMutedCallAction</li>
</ul>
</blockquote>
<h5 id="Multiple-Call"><a href="#Multiple-Call" class="headerlink" title="Multiple Call"></a>Multiple Call</h5><p>接下来花点时间讲讲多来电通话时的管理。例如，现在“Speakerbox”已经处于通话状态了，这时候又有一个通话请求进来。</p>
<p><img src="/images/callkit/11.png" alt=""></p>
<p>如果用户想要结束现在进行的通话并且回应刚进来的通话时，系统会给“Speakerbox”发送<code>CXTransaction</code>。<code>CXTransaction</code>只是一个或多个action组合起来的集合，在现在这种情况下它就是<code>end</code>和<code>answer</code>操作的集合。一旦“Speakerbox”处理并执行集合中的action，系统就会了解到并且换UI。</p>
<p><img src="/images/callkit/12.png" alt=""></p>
<h5 id="Outgoing-Call"><a href="#Outgoing-Call" class="headerlink" title="Outgoing Call"></a>Outgoing Call</h5><p>再来看看去电的流程。要拨出电话首先要找到你需要联系的联系人再进行操作发起通话请求（start call intent）。intent是代表用户意愿操作的对象，被打包成<code>NSUser activity</code>后传回你的app中。app接收到开始通话的intent然后在intent信息的基础上构建开始通话action。我们通过<code>CallController</code>来执行和请求action，之后，<code>CallController</code>会将action传递给系统。如果通话请求被接受了，action会通过<code>ProviderDelegate</code>返回你的app中。最后，app通过网络执行必要的命令建立起通话连接。</p>
<p><img src="/images/callkit/13.png" alt=""></p>
<p>我们来看下整个去电的生命周期。我们以执行开始通话操作为起始点。这时候通话处于starting状态，之后，我们会执行完action操作并将通话状态变成started。当通话的另一端响应通话时，我们会通知provider通话已经开始连接（connecting）。最后，我们告诉provider通话已经连接上了（connected）来通知系统两端可以开始互相说话。</p>
<p><img src="/images/callkit/14.png" alt=""></p>
<p>最后我们以代码的形式来简要回顾一下去电的流程：</p>
<p>1.通过<code>CallController</code>请求开始通话action<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">callController.request(startCallTransaction) &#123; error <span class="keyword">in</span> <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>2.action通过<code>ProviderDelegate</code>被接受，然后执行。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startCallAction.fulfill()</div></pre></td></tr></table></figure></p>
<p>3.app通知call将其状态从connecting转变成connected。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provider.reportOutgoingCall(with: call.uuid, startedConnectingAt: call.connectingDate)</div><div class="line">provider.reportOutgoingCall(with: call.uuid, connectedAt: call.connectDate)</div></pre></td></tr></table></figure></p>
<h3 id="API-Details"><a href="#API-Details" class="headerlink" title="API Details"></a>API Details</h3><h5 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h5><p>跟其他如contacts、core location的API类似，<code>CallKit</code>也需要向用户请求准许的权限。正因为如此，每次app启动之后，你的app要做的第一件事就是检查当前的授权状态。因为可能在上次启动app之后用户进入到设置中修改了权限。如果你发现你的app的授权状态是不允许的，你应该为你的app请求授权。系统会弹框向用户请求允许权限。最后，当你的app启动时，你应该去观察并监听任何授权状态的改变，这样你才能一直将最新的UI展示给你的用户。</p>
<p><img src="/images/callkit/10.png" alt=""></p>
<h5 id="Provider-Configuration"><a href="#Provider-Configuration" class="headerlink" title="Provider Configuration"></a>Provider Configuration</h5><p><code>Provider Configuration</code>可以帮助你的app自定义通话界面。比如说，你的app在通话界面显示的名称，还有是否支持视频通话，指定显示在通话UI最后的button图片，点击这个button可以直接跳转到你的app中。</p>
<h5 id="Actions-Error"><a href="#Actions-Error" class="headerlink" title="Actions Error"></a>Actions Error</h5><p>我们已经知道了在不发生错误的情况下action发生的过程。那么要是在执行过程中发生错误了呢？比如，网络连接发生异常，我们无法建立起通话连接。在这种情况下，action会执行失败。</p>
<p><img src="/images/callkit/15.png" alt=""></p>
<p>其中的过程是这样的：action通知系统发生错误，系统转而通过像通话失败UI来告诉用户通话请求失败。与这些action错误连同一起的是<code>action timeouts</code>。系统的每个action都有其特定的过期时间，这些时间很重要，它们确保了被用户启动的action执行的顺畅。如果action执行超时，provider的代理方法会通知app来正确响应此时的操作。</p>
<h5 id="System-Restrictions"><a href="#System-Restrictions" class="headerlink" title="System Restrictions"></a>System Restrictions</h5><p>现实中你可能会遇到来电被拒。来电被拒绝的原因可能是用户禁用了你的app并且不再给予授权，可能是你的来电被用户列入黑名单中，可能是用户开启勿扰模式。在这些情况下，API中的competition handler会通知你的app。例如<code>reportNewIncomingCall</code>API会在它的completion handler传入一个error。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">provider.reportNewIncomingCall(with: <span class="type">UUID</span>(), update: <span class="type">CXCallUpdate</span>()) &#123; error <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> incomingCallError = error,</div><div class="line">    incomingCallErrorCode = <span class="type">CXErrorCodeIncomingCallError</span>(rawValue: incomingCallError.code) <span class="keyword">where</span> incomingCallErrorCode == .filteredByDoNotDisturb &#123;</div><div class="line"> <span class="comment">// handle do not disturb</span></div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h5><p>由于有<code>CallKit</code>，你的app的通话音频得到了很多好处。其中最大的好处就是你的音频会话的优先级比系统通话和Facetime更高，这意味着系统其它的app不能够打断你的app的音频通话。</p>
<p>现在以来电流程举例。我们知道当有来电时，app会收到应答action然后执行action。在接收action后是配置音频会话最佳的时间点，这是因为我们知道这时候通话即将变成connected状态。当我们执行应答action后，系统会优先自动为app开启音频会话，然后通过音频会话提供者的代理方法的回调来告诉app发生了什么。</p>
<p><img src="/images/callkit/16.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 10推送通知小记（下）]]></title>
      <url>https://iiiceblink.github.io/2016/07/26/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>在上一篇<a href="http://zakariyyasv.pub/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" target="_blank" rel="external">iOS 10推送通知小记（上）</a>中，已经将iOS 10推送机制的改进以及原理讲完了。本篇文章的着重点放在心的推送框架<code>UserNotification.framework</code>上面。</p>
<p>先说说iOS 10之前的推送API中存在的问题。比如，本地推送和远程推送使用的是不同的回调方法但有可能回调方法中的代码是重复的。当你的app将通知发送给用户之后就没办法再去控制它了。为了解决这些问题，iOS 10推出了新的推送框架——<code>UserNotification.framework</code>。<br><a id="more"></a><br>新框架的主要特性有：</p>
<blockquote>
<ul>
<li>与之前的API相似，改写原来的代码很简单。</li>
<li>扩展通知的内容。</li>
<li>本地推送和远程推送执行相同的回调方法。</li>
<li>简化代理方法。</li>
<li>更好的推送管理。app可以访问将被发送或者已经发送给用户的通知并且允许在更新通知的时候移除它。</li>
<li>通知内容可以展示app内的界面内容。</li>
</ul>
</blockquote>
<h3 id="Registration"><a href="#Registration" class="headerlink" title="Registration"></a>Registration</h3><p>如今，通知消息对用户来说是种干扰或者打断。因此，在你给用户发送通知消息之前得到用户的授权和允许是非常重要的。你可以向用户请求横幅、声音或者app角标的权限，这样用户可以第一时间看到你的推送通知。本地推送与远程推送都需要做注册操作。</p>
<p>注册代码编写很简单，只需要调用UN的userNotification对象的request方法，并传入正确的参数即可。注意，现在用户对于每个应用允许的权限可以在应用的设置菜单中单独设置，用户可以依据个人的偏好去开启或关闭通知。在iOS 10中，开发者可以获取用户设置的权限，因而可以依据用户的偏好设置而发送对应的通知消息。</p>
<p>本地推送的注册到此就结束了，但是远程推送还没有结束。注册远程推送需要连接网络跟APNS进行通信获取设备的device token，你需要将这个token发送给应用的服务端。这个token非常重要，远程推送通知的负载需要包含这个token。device token相当于验证你的设备和应用程序之间的钥匙。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// RequestAuthorization</span></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().requestAuthorization([.alert, .sound, .badge])</div><div class="line"> &#123; (granted, error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div><div class="line"> </div><div class="line"> <span class="comment">// Access to user-defined settings</span></div><div class="line"> <span class="type">UNUserNotificationCenter</span>.current().getNotificationSettings &#123; (settings) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div><div class="line"> </div><div class="line"> <span class="comment">// Register remote notifications</span></div><div class="line"> <span class="type">UIApplication</span>.shared().registerForRemoteNotifications()</div></pre></td></tr></table></figure>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><p>在iOS 10中，推送通知加入了subtitle，可以给用户展示更多的信息。</p>
<p><img src="/images/notificationAPI/1.png" alt=""></p>
<p>创建通知内容很简单，只需要创建<code>UNMutableNotificationContent</code>对象并且设置里面不同的属性就可以了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// local notification</span></div><div class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">content.title = <span class="string">"Introduction to Notifications"</span></div><div class="line">content.subtitle = <span class="string">"Session 707"</span></div><div class="line">content.body = <span class="string">"Woah! These new notifications look amazing! Don’t you agree?"</span></div><div class="line">content.badge = <span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// remote notification payload</span></div><div class="line">&#123;</div><div class="line"> <span class="string">"aps"</span> : &#123;</div><div class="line"> <span class="string">"alert"</span> : &#123;</div><div class="line"> <span class="string">"title"</span> : <span class="string">"Introduction to Notifications"</span>,</div><div class="line"> <span class="string">"subtitle"</span> : <span class="string">"Session 707"</span></div><div class="line">,</div><div class="line"> <span class="string">"body"</span> : <span class="string">"Woah! These new notifications look amazing! Don’t you agree?"</span></div><div class="line"> &#125;,</div><div class="line"> <span class="string">"badge"</span> : <span class="number">1</span></div><div class="line"> &#125;,</div><div class="line"> my-attachment : https:<span class="comment">//example.com/phtos.jpg"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h3><p>iOS 10发送通知的过程可以总结如下：</p>
<blockquote>
<ul>
<li>注册通知申请权限。</li>
<li>设置通知的内容</li>
<li>设置触发器</li>
<li>设置通知标识符</li>
<li>发送通知</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Notification Delivery Summary</span></div><div class="line"><span class="keyword">import</span> UserNotifications</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().requestAuthorization([.alert, .sound, .badge])</div><div class="line"> &#123; (granted, error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div><div class="line"><span class="keyword">let</span> content = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">content.title = <span class="string">"Introduction to Notifications"</span></div><div class="line">content.body = <span class="string">"Let's talk about notifications!"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> trigger = <span class="type">UNTimeIntervalNotificationTrigger</span>(timeInterval: <span class="number">5</span>, repeats: <span class="literal">false</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> requestIdentifier = <span class="string">"sampleRequest"</span></div><div class="line"><span class="keyword">let</span> request = <span class="type">UNNotificationRequest</span>(identifier: requestIdentifier,</div><div class="line"> content: content,</div><div class="line"> trigger: trigger)</div><div class="line"></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(request) &#123; (error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div></pre></td></tr></table></figure>
<p>以上说的是应用程序在后台的时候推送通知的产生过程。那要是应用程序在前台运行呢？这时候我们需要实现<code>UNUserNotificationCenter</code>的代理方法才能支持在前台中处理推送通知。代理方法中有个叫做<code>willPresent notification:</code>，该方法能让你获取推送通知中的内容。如果你想设置弹窗、声音或者in-app显示，可以通过调用<code>handlerBlock</code>方法设置不同的参数达到效果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UNUserNotificationCenterDelegate</span> : <span class="title">NSObjectProtocol</span></span></div><div class="line"><span class="title">func</span> <span class="title">userNotificationCenter</span>(<span class="title">_</span> <span class="title">center</span>: <span class="title">UNUserNotificationCenter</span>, <span class="title">willPresent</span> <span class="title">notification</span>: <span class="title">UNNotification</span>, <span class="title">withCompletionHandler</span> <span class="title">completionHandler</span>: (<span class="title">UNNotificationPresentationOptions</span>) -&gt; <span class="title">Void</span>)&#123;</div><div class="line">    <span class="comment">// Roll banner and sound alert</span></div><div class="line">     handlerBlock([.alert, .sound]) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Management"><a href="#Management" class="headerlink" title="Management"></a>Management</h3><p>在iOS 10新的推送框架中，推送通知的管理可以做的事情很多：</p>
<blockquote>
<p>访问推送消息</p>
<ul>
<li>将要发送的通知</li>
<li>已经发送的通知<br>移除推送消息<br>更新修改推送消息 </li>
</ul>
</blockquote>
<p>在推送通知管理中非常重要的一部分是<code>request identifier</code>。在本地推送中，请求标识符被设置在消息请求当中，在远程推送中，请求标识符被设置在新的HTTP/2请求头中——<code>apns-collapse-id</code>。系统通过这个标识符知道哪个通知是需要移除或者更新的。</p>
<p>在下面例子中，你的app想发送关于游戏的通知，它想通知游戏开始的时间。因此你创建推送请求并且将其放入系统的schedule中。但是，现在需要告知游戏被取消了。这时候就需要调用<code>removePendingNotificationRequests</code>方法并传入创建推送请求时传入的标识符。那如何更新游戏的开始时间呢？你需要创建新的请求，并传入与之前相同的标识符，设置新的时间并放入系统的schedule中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Pending Notification Removal</span></div><div class="line"><span class="keyword">let</span> gameStartIdentifier = <span class="string">"game1.start.identifier"</span></div><div class="line"><span class="keyword">let</span> gameStartRequest = <span class="type">UNNotificationRequest</span>(identifier: gameStartIdentifier, content: content, trigger: startTrigger)</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(gameStartRequest) &#123; (error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div><div class="line"><span class="comment">// Game was cancelled</span></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().removePendingNotificationRequests(withIdentifiers: [gameStartIdentifier])</div><div class="line"><span class="comment">// Game start time was updated</span></div><div class="line"><span class="keyword">let</span> updatedGameStartRequest = <span class="type">UNNotificationRequest</span>(identifier: gameStartIdentifier,</div><div class="line"> content: content,</div><div class="line"> trigger: newStartTrigger)</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(updatedGameStartRequest) &#123; (error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div></pre></td></tr></table></figure>
<p>下面再来说说通知已经发送出去的情况。我们举足球比分的例子来说明。你创建了通知请求并将其发送到系统。但是通知更新的是错误的比分，这时候你可以很简单地通过调用<code>removeDeliveredNotifications</code>来移除之前的通知。当然，你也可以创建新的推送请求更新原来通知的比分。当然，这两种做法都要传入相同的请求标识符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Delivered Notification Removal</span></div><div class="line"><span class="keyword">let</span> gameScoreIdentifier = <span class="string">"game1.score.identifier"</span></div><div class="line"><span class="keyword">let</span> gameScoreRequest = <span class="type">UNNotificationRequest</span>(identifier: gameScoreIdentifier,</div><div class="line"> content: scoreContent,</div><div class="line"> trigger: trigger)</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(gameScoreRequest) &#123; (error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div><div class="line"><span class="comment">// Wrong game score was published</span></div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().removeDeliveredNotifications(withIdentifiers: [gameScoreIdentifier])</div><div class="line"><span class="comment">// Score game was updated</span></div><div class="line"><span class="keyword">let</span> updateGameScoreRequest = <span class="type">UNNotificationRequest</span>(identifier: gameScoreIdentifier,</div><div class="line"> content: newScoreContent,</div><div class="line"> trigger: newTrigger)</div><div class="line"><span class="type">UNUserNotificationCenter</span>.current().add(updateGameScoreRequest) &#123; (error) <span class="keyword">in</span> <span class="comment">// ... &#125;</span></div></pre></td></tr></table></figure>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>下面介绍用户接收到推送通知后的处理操作。app可以识别用户对于通知消息处理的三种类型操作。</p>
<p>第一种类型操作是最常规的，那就是用户点击推送消息打开app。这个操作可以在设备解锁并且接收到推送消息，用户点击横幅时发生。也可以在锁屏状态下用户向右滑动消息，在下拉通知中心点击消息发生这个操作。</p>
<p><img src="/images/notificationAPI/2.png" alt=""></p>
<p>第二种类型操作是自定义快捷操作行为。这时候的推送消息就是可以执行操作的消息。这些自定义操作行为以按钮的形式出现在推送消息的下面。在iOS 9中引入了textinput action，这样用户可以快速回复消息。这些自定义的快捷操作行为可以在前台可以在后台中。</p>
<p>在后台中执行action会移除消息并且会给后台很短的一段时间去处理用户点击的action触发的事件。另一方面，在前台中执行action会移除消息并且启动app这样app就可以处理action触发的事件。</p>
<p><img src="/images/notificationAPI/3.png" alt=""></p>
<p>所有的自定义快捷操作都需要与category关联起来。category需要唯一的标识符，这个标识符会设置到所有你想要的action中。除此之外，你还可以设置intent标识符，关于intent的更多信息可以参考SiriKit Session。当你创建完所有的action和category时，你需要做的唯一的事情就是将它们注册到<code>UNUserNotificationCenter</code>对象中与你的应用程序相关联。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let action = UNNotificationAction(identifier:”reply",title:"Reply",options:[])</div><div class="line">let category = UNNotificationCategory(identifier: "message", actions: [action], minimalActions: [action], intentIdentifiers: [], options: [])</div><div class="line">UNUserNotificationCenter.current().setNotificationCategories([category])</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Remote Notifications</span></div><div class="line">&#123;</div><div class="line">    aps : &#123;</div><div class="line">        alert : “<span class="type">Welcome</span> to <span class="type">WWDC</span> !”,</div><div class="line">        category: <span class="string">"message"</span></div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Local Notifications</span></div><div class="line">content.categoryIdentifier = <span class="string">"message"</span></div></pre></td></tr></table></figure>
<p>接下来说说如何将自定义的aciton展示给你的用户。在远程推送中，你需要在远程推送通知的APS字典中设置category标识符。现在这个标识符需要与之前注册的category标识符能匹配上。在本地推送中，你需要在创建的推送内容中设置category标识符。同样的，这个category标识符必须与注册的category标识符能匹配上。</p>
<p>第三种类型操作是dismiss行为。该行为在用户移除指定的通知消息时触发。比如说，你有个日历app，你给用户发送了一条关于即将到来的会议的远程推送通知。用户看到了这则通知并移除它时，你想要停止向该用户其他的设备再发送这条用户已经看到的远程推送通知。那用户如何才算是真正地移除通知消息呢？用户可以在锁屏界面或者下拉通知中心中从右向左滑动消息并点击“清除”按钮。</p>
<p>在之前讨论的注册不同的category时，我们提到一些选项，<code>customDismissAction</code>选项是其中的一个。我们需要做的是将<code>customDismissAction</code>添加到category中，那么当用户移除跟category关联的通知消息时，app将会接收到dismiss行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">customDismissAction: <span class="type">UNNotificationCategoryOptions</span></div><div class="line"><span class="keyword">let</span> category = <span class="type">UNNotificationCategory</span>(identifier: <span class="string">"message"</span>, actions: [action],</div><div class="line">minimalActions: [action], intentIdentifiers: [], options: [.customDismissAction])</div></pre></td></tr></table></figure>
<p>以上就是关于自定义通知行为的三种类型的介绍。那么自定义行为的操作的处理在哪里进行呢？在<code>UNUserNotificationCenter</code>代理方法中有这样一个方法——<code>didReceive response:</code>,实现这个方法来处理自定义行为的操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UNUserNotificationCenterDelegate</span> : <span class="title">NSObjectProtocol</span></span></div><div class="line">    <span class="title">func</span> <span class="title">userNotificationCenter</span>(<span class="title">_</span> <span class="title">center</span>: <span class="title">UNUserNotificationCenter</span>, <span class="title">didReceive</span> <span class="title">response</span>: <span class="title">UNNotificationResponse</span>, <span class="title">withCompletionHandler</span> <span class="title">completionHandler</span>: () -&gt; <span class="title">Void</span>)</div></pre></td></tr></table></figure>
<p>我们把目光聚焦到该方法中的<code>UNNotificationResponse</code>上。这个对象中包含你创建的action的<code>action identifier</code>，如果这个action是<code>text input action</code>，那还会有<code>user text</code>属性。它还包含一个通知消息对象，消息对象中自然还包含请求对象以及标识符。</p>
<p><img src="/images/notificationAPI/4.png" alt=""></p>
<h3 id="Service-extension"><a href="#Service-extension" class="headerlink" title="Service extension"></a>Service extension</h3><p>再来谈谈远程推送。iOS 10引入了<code>service extension</code>，它的作用是在远程推送中在推送通知展示到用户之前添加或者修改通知消息中的内容，同时，还会对消息中的内容进行端对端的加密。注意，它是在后台运行工作的。关于<code>service extension</code>工作原理的介绍已经在前一篇文章中解释过了。现在重点讲述如何代码实现<code>service extension</code>。</p>
<p>首先，你需要做的是在Xcode项目中添加新的target，如下图所示。</p>
<p><img src="/images/notificationAPI/5.png" alt=""></p>
<p>之后在这个模板中会有一个类。它是<code>UNNotificationServiceExtension</code>类的子类。它有两个主要的方法。第一个方法可以获取当前的推送请求对象，可以在其中修改推送消息的内容。当<code>service extension</code>运行超时时，第二个方法会被触发。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Service Extension</span></div><div class="line"><span class="keyword">import</span> UserNotifications</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span>: <span class="title">UNNotificationServiceExtension</span> </span>&#123;</div><div class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(request: UNNotificationRequest, withContentHandler contentHandler:<span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">     <span class="comment">// Modify the notification content</span></div><div class="line"> &#125;</div><div class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">serviceExtensionTimeWillExpire</span><span class="params">()</span></span> &#123;</div><div class="line">     <span class="comment">// Called before the extension will be terminated by the system</span></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们来看看如何在远程推送中真正地触发上面这段代码。下面是远程推送消息的简易版本，其中有一个新的<code>mutable-content</code>字段。你需要用这个字段来让系统知道你想要系统启动<code>service extension</code>去更新远程推送消息中的内容。当然你不必每次都去启动<code>service extension</code>服务，只需要在需要更新推送通知内容的时候再去启动它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Example payload</span></div><div class="line">&#123;</div><div class="line">    aps : &#123;</div><div class="line">        alert : “<span class="type">New</span> <span class="type">Message</span> <span class="type">Available</span>”,</div><div class="line">        mutable-content : <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    encrypted-content : “#myencryptedcontent”</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再来看看如何去解密远程推送通知中加密的内容。在下面代码中，我们看到了<code>didReceive</code>方法。该方法是推送请求的方法，在这个方法中要做的事情就是解密远程推送通知中加密的内容。然后，我们创建一个<code>UNMutableNotificationContent</code>对象并将解密出来的内容赋给它。最后，我们调用<code>contentHandler</code>方法将解密的内容展示在用户面前。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Decrypt Remote Notification Payload in Service Extension and Update Notification Content</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(request: UNNotificationRequest, withContentHandler contentHandler:<span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">     <span class="comment">// Decrypt the payload</span></div><div class="line">     <span class="keyword">let</span> decryptedBody = decrypt(request.content.userInfo[“encrypted-content”])</div><div class="line">     <span class="keyword">let</span> newContent = <span class="type">UNMutableNotificationContent</span>()</div><div class="line">     <span class="comment">// Modify the notification content</span></div><div class="line">     newContent.body = decryptedBody</div><div class="line">     <span class="comment">// Call content handler with updated content</span></div><div class="line">     contentHandler(newContent)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 10推送通知小记（上）]]></title>
      <url>https://iiiceblink.github.io/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>最近在体验iOS 10Beta版的过程中，我发现iOS 10在锁屏界面的变动比较大，与之前的交互逻辑完全不同。与此同时，推送通知消息也有了改进，比如支持3D Touch，可以展示更多的信息，通知内容可以包含图片等等。按照逻辑推断iOS 10推送通知的API会有变化，于是，我赶紧查阅了Xcode 8Beta中的文档以及WWDC2016的视频，果然发现了玄机。</p>
<h3 id="推送机制"><a href="#推送机制" class="headerlink" title="推送机制"></a>推送机制</h3><a id="more"></a>
<p>推送机制在iOS 10上发生了一点变化。</p>
<h4 id="iOS-lt-10-0"><a href="#iOS-lt-10-0" class="headerlink" title="iOS &lt; 10.0"></a>iOS &lt; 10.0</h4><p>推送按照通知发送源分为本地推送和远程推送。</p>
<p>先说本地推送。本地推送是由设备上的app发起的，本地推送通知被加入到schedule中后，被诸如时间、位置、任务等触发通知而使其显示到设备上。当用户对通知消息做出反应，发起通知的app会得到回调。</p>
<p><img src="/images/userNotifications/4.png" alt=""></p>
<p>再说远程推送。远程推送是由app的服务器通过网络连接发送的。app先注册远程通知得到APNS(Apple Push Notification Service)返回的device token，app的服务端将推送通知的负载连同device token发送给APNS。APNS根据device token将推送通知发送到用户的设备上。设备接收到通知后会展示在屏幕上供用户浏览和处理，之后app会得到用户处理的回调。</p>
<p><img src="/images/userNotifications/5.png" alt=""></p>
<h4 id="iOS-gt-10-0"><a href="#iOS-gt-10-0" class="headerlink" title="iOS &gt;= 10.0"></a>iOS &gt;= 10.0</h4><p>iOS 10新增了<code>trigger</code>。依据字面意思理解就是推送通知的触发器，告诉设备什么时候触发通知显示在设备上。iOS 10支持四种类型的<code>trigger</code>：push、timer interval、calendar and location。其中push属于远程推送，其他三种属于本地推送。<br><img src="/images/userNotifications/6.png" alt=""></p>
<p>iOS 10推送通知的过程变成了这样：app注册通知，创建通知的内容，trigger，identifier，将这些放入<code>UNNotificationRequest</code>对象中，最后将其放入schedule。</p>
<p><img src="/images/userNotifications/7.png" alt=""></p>
<h3 id="Notification-Service-Extensions"><a href="#Notification-Service-Extensions" class="headerlink" title="Notification Service Extensions"></a>Notification Service Extensions</h3><p>在iOS 10之前，推送通知的负载大小最多也就4KB，因而类似于声音、图像、视频等无法存储到推送通知当中。为了解决这个问题，iOS 10引入了新的扩展服务——<code>Notification Service Extensions</code>。<code>Notification Service Extensions</code>可以帮助我们在不打开app的情况下去下载或者是改变远程推送通知消息中的内容。由于推送通知的负载不足以存储多媒体文件本身，因而以URL的形式存储。一旦设备接收到来自于你的app的远程推送通知的负载，<code>Notification Service Extensions</code>便去下载URL当中的资源文件，然后会在用户查看通知消息时展现给用户。</p>
<p><img src="/images/userNotifications/1.png" alt=""></p>
<p><img src="/images/userNotifications/2.png" alt=""></p>
<p>那么它是如何工作的呢？在通知的服务端，发送的通知会被service extension加工成两个部分：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  aps: &#123;</div><div class="line">    alert: &#123;...&#125;</div><div class="line">    mutable-content: <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  my-attachment: <span class="string">"https://foo.bar/baz.jpg"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>mutable-content</code>字段告诉iOS在通知被发送之前通知中有内容要被service extension修改，<code>my-attachment</code>字段包含了被下载内容的URL。</p>
<p>为了能让app的扩展服务能够处理通知消息，我们需要在app的Xcode project中添加<code>notification service extension</code>。Xcode会生成一个包含<code>UNNotificationServiceExtension</code>子类的文件。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest, withContentHandler contentHandler:<span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">serviceExtensionTimeWillExpire</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// Called just before the extension will be terminated by the system.</span></div><div class="line">    <span class="comment">// Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个文件包含两个需要被重写的方法。第一个方法用来下载URL中的内容并将其添加到通知当中。由于网络是不可靠的，因此我们还需要在此方法中处理网络发生错误的情况。第二个方法是用来处理第一个方法运行超时的情况，当attachment下载消耗太长的时间时，操作系统会执行<code>serviceExtensionTimeWillExpire()</code>方法终止下载并发送类似于”best attempt”内容的通知。</p>
<h3 id="Media-Attachments"><a href="#Media-Attachments" class="headerlink" title="Media Attachments"></a>Media Attachments</h3><p><code>Media Attachments</code>是用来附着在推送通知上负责存储多媒体文件的URL。目前支持的多媒体文件类型包括常用的音频、视频和图片（包括GIF）格式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Adding an attachment to a user notification</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationService</span>: <span class="title">UNNotificationServiceExtension</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> request: UNNotificationRequest,withContentHandler contentHandler: <span class="params">(UNNotificationContent)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">        <span class="keyword">let</span> fileURL = <span class="comment">// ...</span></div><div class="line">        <span class="keyword">let</span> attachment = <span class="type">UNNotificationAttachment</span>(identifier: <span class="string">"image"</span>,url: fileURL,</div><div class="line"> options: <span class="literal">nil</span>)</div><div class="line">        <span class="keyword">let</span> content = request.content.mutableCopy <span class="keyword">as</span>! <span class="type">UNMutableNotificationContent</span></div><div class="line">        content.attachments = [ attachment ]</div><div class="line">        contentHandler(content)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Media Attachments</code>在本地推送与远程推送的工作机制有轻微差别。在本地推送中，它的<code>media attachment</code>在app创建通知时就必须包含某个本地磁盘文件的URL。当通知生效时，那份文件会被拷贝一份随着通知一起发送出去。除此之外，不需要做别的工作。在远程推送中，远程通知服务会将<code>media attachment</code>作为APNS通知负载的一部分发送出去。<code>media attachment</code>中包含的URL的内容不限定必须是已经存在设备中的文件。然而，iOS 10无法自动发送attachment内容不存储在本地的通知，这就要借助到前面提到的<code>Notification Service Extensions</code>。</p>
<h3 id="Notification-Content-Extensions"><a href="#Notification-Content-Extensions" class="headerlink" title="Notification Content Extensions"></a>Notification Content Extensions</h3><p>如果我们想在通知中展现app中一样的界面内容时，该怎么办？<code>Notification Content Extensions</code>派上用场了。<code>Notification Content Extensions</code>与<code>Notification Service Extensions</code>在通知中提供新的内容方面有相似之处，但两者有两个重要的区别。第一，<code>Notification Content Extensions</code>在本地推送和远程推送当中都起作用，而<code>Notification Service Extensions</code>只在远程推送中工作。第二，<code>Notification Content Extensions</code>只能处理media attachment中的内容，而<code>Notification Service Extensions</code>不仅能处理media attachment中的内容，更能在通知详情中展示整个的<code>UIViewController</code>。</p>
<p><img src="/images/userNotifications/3.png" alt=""></p>
<p>在上图中我们看到了日历通知的日历事件就是用到了<code>Notification Content Extensions</code>。在Xcode项目中添加<code>Notification Content Extensions</code>与<code>Notification Service Extensions</code>的操作类似。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Minimal Content Extension</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotificationViewController</span>: <span class="title">UIViewController</span>, <span class="title">UNNotificationContentExtension</span> </span>&#123;</div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>?</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="comment">// Do any required interface initialization here.</span></div><div class="line"> &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> notification: UNNotification)</span></span> &#123;</div><div class="line">        label?.text = notification.request.content.body</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建成功后，Xcode会生成一个storyboard文件、代码文件以及可以自定义contentn extension内容的info.plist文件。代码文件中包含了一个实现<code>UNNotificationContentExtension</code>协议的UIViewController的子类。要想让它生效，我们需要实现协议中必须实现的方法，在storyboard中自定义view设置info.plist文件中的category ID。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>原理部分的内容就这么多了，关于推送的UserNotifications.framework代码方面的内容会放到下一篇中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 10 UICollectionView新特性小记]]></title>
      <url>https://iiiceblink.github.io/2016/07/18/iOS%2010%20UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>iOS 10对于UICollectionview的改进优化主要表现在以下三个方面：</p>
<blockquote>
<ul>
<li>平滑的滑动体验</li>
<li>self-sizing改进</li>
<li>interactive reordering</li>
</ul>
</blockquote>
<h3 id="平滑的滑动体验"><a href="#平滑的滑动体验" class="headerlink" title="平滑的滑动体验"></a>平滑的滑动体验</h3><h5 id="1-卡顿的原因"><a href="#1-卡顿的原因" class="headerlink" title="1.卡顿的原因"></a>1.卡顿的原因</h5><a id="more"></a>
<p>在iOS 10之前我们在使用UICollectionview大幅度滑动加载复杂的视图时，很可能会出现卡顿掉帧的情况，这是很影响用户体验的。那为什么会出现这种情况呢？从下面的图可以看出，当cell准备显示到屏幕上时，cell的加载工作就已经完成了。但注意，在屏幕外加载的数据是一整行的cell。这样大量的加载工作在快速滑动的过程中便会稍显吃力，也就造成了卡顿和掉帧。</p>
<p><img src="/images/wwdcCollectionView/1.gif" alt=""></p>
<p>下图中绘制出了上图的实验数据。其中，x轴表示显示刷新事件，y轴表示主线程中CPU处理的时间。我们知道手机屏幕的刷新率在60FPS，也就意味着每16ms就要刷新一次，若CPU处理的时间超过16ms，便会将加载挤压到下一帧从而引起卡顿。从图中可以看到当屏幕快速滑动时，CPU处理时间超过16ms，会有卡顿，而在缓慢滑动过程中，CPU的处理时间很短，不会有卡顿。</p>
<p><img src="/images/wwdcCollectionView/2.jpg" alt=""></p>
<p>那如何解决这个问题呢？我们需要将Cell的加载工作分摊，达到下图的效果，就可以解决这个问题了。那如何分摊cell的加载工作呢？这就要涉及到Cell的生命周期了。</p>
<p><img src="/images/wwdcCollectionView/3.jpg" alt=""></p>
<h5 id="2-Cell-Life-Cycle"><a href="#2-Cell-Life-Cycle" class="headerlink" title="2.Cell Life Cycle"></a>2.Cell Life Cycle</h5><p>在iOS 10之前，当我们滑动<code>UICollectionView</code>时，就需要添加新的cell。我们将它从reuse队列中拿出来，然后调用<code>prepareForReuse</code>。这个方法让cell将其本身重置为默认状态，接收并加载app中的新数据。</p>
<p><img src="/images/wwdcCollectionView/4.jpg" alt=""></p>
<p>接下来，我们会继续调用<code>cellForItemAtIndexPath</code>方法。这里主要是你做填充cell工作的地方，你可以加载数据模型，并将其设置到cell中，然后返回给系统。</p>
<p><img src="/images/wwdcCollectionView/5.jpg" alt=""></p>
<p>之后，在cell显示到屏幕之前，我们会调用<code>willDisplayCell</code>方法。这个方法是让你做cell显示到屏幕上最后工作的地方。</p>
<p><img src="/images/wwdcCollectionView/6.jpg" alt=""></p>
<p>当Cell从屏幕上滑出时，我们会调用<code>didEndDisplayingCell</code>方法。这就是iOS 10之前整个cell的生命周期。</p>
<p><img src="/images/wwdcCollectionView/7.jpg" alt=""></p>
<p>在iOS 10中，当我们滑动<code>UICollectionView</code>需要添加新的cell时，我们会从reuse队列中拿出来，然后，调用<code>prepareForReuse</code>方法。</p>
<p><img src="/images/wwdcCollectionView/8.jpg" alt=""></p>
<p>接下来，在<code>cellForItemAtIndexPath</code>方法中填充cell的内容。</p>
<p><img src="/images/wwdcCollectionView/9.jpg" alt=""></p>
<p>用户继续滑动，接下来发生的事情有所不同。我们不再在创建cell的时候就调用<code>willDisplayCell</code>方法，该方法的调用时机放到cell显示到屏幕上的时候。</p>
<p><img src="/images/wwdcCollectionView/10.jpg" alt=""></p>
<p>接着，用户继续滑动。当cell离开UICollectionview的可视区域时，我们会调用<code>didEndDisplayingCell</code>方法。在iOS 10之前，在此时cell就进入了reuse队列中。当这个cell需要重新显示数据的时候，我们就必须要重新进行一遍cell的生命周期。但是在iOS 10中，我们会将cell保持一段时间。在这段时间内，用户想查看已经滑出屏幕的cell往回滑动时，cell不需要再重新走一遍生命周期，只需要调用<code>willDisplayCell</code>即可。</p>
<p><img src="/images/wwdcCollectionView/11.jpg" alt=""></p>
<p>在一行多列的情况中同样适用。我们一次加载一个cell而不是一行cell来获得更好的滑动体验。我们先加载第一个cell，加载完再加载第二个cell，当两个cell加载完成后并且cell即将显示到屏幕上时，我们调用两者的<code>willDisplayCell</code>方法。</p>
<p><img src="/images/wwdcCollectionView/12.jpg" alt=""></p>
<p>下图是模拟iOS 10下系统加载cell的情况。可以看到iOS 10下的滑动相比iOS 9流畅很多，没有卡顿。</p>
<p><img src="/images/wwdcCollectionView/13.gif" alt=""></p>
<h5 id="3-Cell-Pre-Fetching"><a href="#3-Cell-Pre-Fetching" class="headerlink" title="3.Cell Pre-Fetching"></a>3.Cell Pre-Fetching</h5><p>iOS 10引入了Pre-Fetching，默认情况下是开启的。若你必须用到iOS 10之前老的生命周期，只需要在UICollectionview中添加<code>isPrefetchingEnabled</code>属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collectionView.isPrefetchingEnabled = <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>为了能最好地发挥这个特性，我们要做到在<code>cellForItemAtIndexPath</code>方法中做耗费资源和时间的工作，包括cell的所有内容的创建。另外，我们要确保在<code>willDisplayCell</code>和<code>didEndDisplayCell</code>方法中做轻量甚至不做工作。</p>
<p>更进一步，我们该如何处理繁重的data models？在cell内容创建的过程中需要处理繁重的任务，比如图片解码、连接数据库、从CoreData中加载数据。为了解决这个问题，iOS 10引入了新的API帮助告诉你的数据模型如何加载内容。</p>
<p>UICollectionView有两个组成部分：dataSource和delegate。iOS 10引入新的组成元素：prefetchDataSource。它是可选的，并且只必须实现一个方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UICollectionViewDataSourcePrefetching</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, prefetchItemsAt indexPaths: [NSIndexPath])</span></span></div><div class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(<span class="number">_</span> collectionView: UICollectionView, cancelPrefetchingForItemsAt indexPaths: [NSIndexPath])</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UICollectionView</span> : <span class="title">UIScrollView</span> </span>&#123;</div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> prefetchDataSource: <span class="type">UICollectionViewDataSourcePrefetching</span>?</div><div class="line">    <span class="keyword">var</span> isPrefetchingEnabled: <span class="type">Bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个方法叫<code>prefetchItemsAt indexPaths</code>。该方法会在你异步预加载模型中的内容时在prefetch data source中调用。方法中的indexpath参数是有序数组可以帮助更好的读取模型中的数据。第二个方法叫<code>cancelPrefetchingForItemsAt indexPaths</code>（可选）。当我们决定不再滑动到某个indexPath集合时会被prefetch data source调用。你可以调用它来取消或者降低任何预加载的优先级。</p>
<p>需要注意的是，这不是对数据模型的代替。它只是对已经存在的异步加载数据方法的起到辅助作用。</p>
<p>下面总结一下使用预加载的注意点：</p>
<blockquote>
<p>1.在调用方法时，确保所处理的工作都是在后台线程中进行。配合GCD和NSOperationQueue去处理多线程任务。<br>2.记住pre-fetch是自适应技术。当滑动缓慢时，pre-fetch会做额外的工作去优化。当滑动快速时，需要频繁刷新屏幕，这时候就不再做pre-fetch。<br>3.调用<code>cancelPrefetchingForItemsAt indexPaths</code>方法去处理用户滑动操作的切换。</p>
</blockquote>
<p>在iOS 10中，与UICollectionview一脉相承的UItableview也加入了相同的API。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UITableViewDataSourcePrefetching</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, prefetchRowsAt indexPaths:[NSIndexPath])</span></span></div><div class="line">     <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cancelPrefetchingForRowsAt indexPaths:[NSIndexPath])</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UITableView</span> : <span class="title">UIScrollView</span> </span>&#123;</div><div class="line">     <span class="keyword">weak</span> <span class="keyword">var</span> prefetchDataSource: <span class="type">UITableViewDataSourcePrefetching</span>?</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="self-sizing-cell"><a href="#self-sizing-cell" class="headerlink" title="self-sizing cell"></a>self-sizing cell</h3><p>在<code>UICollectionView</code>中有一个实体布局类<code>UICollectionViewFlowLayout</code>，它已经全面支持self-sizing cells。要开启这一特性，需要设置<code>estimated item size</code>为不为0的CGSize。它会告诉<code>UICollectionView</code>你想要在内容显示的时候动态计算布局。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layout.estimatedItemSize = <span class="type">CGSize</span>(width:<span class="number">50</span>,height:<span class="number">50</span>)</div></pre></td></tr></table></figure>
<p>为了能够准确的得到cell的真实尺寸，有三种方法可以达到需求。</p>
<blockquote>
<p>1.AutoLayout。当给cell的contentView的所有层级的视图添加约束后，自动布局系统自动计算出cell的大小。<br>2.重写<code>sizeThatFits()</code>方法。如果你不想使用自动布局，并想手动控制就用这个方法。<br>3.重写<code>preferredLayoutAttributesFittingAttributes()</code>方法。该方法不仅提供尺寸信息还能提供像变换、alpha等属性信息。</p>
</blockquote>
<p>但是在实际操作中，我们很难去设置合适的<code>estimated item size</code>。如果flowlayout可以依据数学计算出的尺寸而不是根据布局内容的真实尺寸去适应那会非常棒。为此，iOS 10引入了新的API。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layout.estimatedItemSize = <span class="type">UICollectionViewFlowLayoutAutomaticSize</span></div></pre></td></tr></table></figure>
<p>我们需要做的就是将<code>estimated item size</code>设置为<code>UICollectionViewFlowLayoutAutomaticSize</code>，flowlayout会自动计算布局，它不仅能计算所有cell当前的size，还能依此动态预测接下来的cell的size大小。</p>
<p>接下来看两个例子更能明显看出差别。</p>
<p>在下图中可以看到在iOS 10之前，当单个cell的尺寸改变时，其他的cell没有变化，布局需要重新计算。</p>
<p><img src="/images/wwdcCollectionView/14.gif" alt=""></p>
<p>在iOS 10中，当第一个cell的size发生改变时，系统会自动计算出所有cell的size大小，然后刷新界面。</p>
<p><img src="/images/wwdcCollectionView/15.gif" alt=""></p>
<h3 id="Interactive-Reordering"><a href="#Interactive-Reordering" class="headerlink" title="Interactive Reordering"></a>Interactive Reordering</h3><p>先看看iOS 9里面的API：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UICollectionView</span> : <span class="title">UIScrollView</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">beginInteractiveMovementForItem</span><span class="params">(at indexPath: NSIndexPath)</span></span> -&gt; <span class="type">Bool</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateInteractiveMovementTargetPosition</span><span class="params">(<span class="number">_</span> targetPosition: CGPoint)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">endInteractiveMovement</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cancelInteractiveMovement</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想开启<code>interactive movement</code>，我们就需要调用<code>beginInteractiveMovementForItem()</code>方法，其中indexPath代表了我们将要移动走的cell。接着每次手势的刷新，我们都需要刷新cell的位置，去响应我们手指的移动操作。这时我们就需要调用<code>updateInteractiveMovementTargetPosition()</code>方法。我们通过手势来传递坐标的变化。当我们移动结束之后，就会调用<code>endInteractiveMovement()</code>方法。 <code>UICollectionView</code>就会放下cell，处理完整个layout，此时你也可以重新刷新model或者处理数据model。如果中间突然手势取消了，那么这个时候就应该调用<code>cancelInteractiveMovement()</code>方法。如果我们重新把cell移动一圈之后又放回原位，其实就是取消了移动，那这个时候就应该在<code>cancelInteractiveMovement()</code>方法里面不用去刷新data source。</p>
<p>在iOS 10中，如果你使用UICollectionViewController，那么这个重排对于你来说会更加的简单。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UICollectionViewController</span> : <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> installsStandardGestureForInteractiveMovement: <span class="type">Bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你只需要把<code>installsStandardGestureForInteractiveMovement</code>这个属性设置为True即可。CollectionViewController会自动为你加入手势，并且自动为你调用上面的方法。</p>
<p>iOS 10在iOS 9的基础上增加了翻页功能。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collectionView.isPagingEnabled = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>开启分页前：</p>
<p><img src="/images/wwdcCollectionView/16.gif" alt=""></p>
<p>开启分页后：</p>
<p><img src="/images/wwdcCollectionView/17.gif" alt=""></p>
<h3 id="UIRefreshControl"><a href="#UIRefreshControl" class="headerlink" title="UIRefreshControl"></a>UIRefreshControl</h3><p>UIRefreshControl现在可以直接在CollectionView里面使用，同样的，也可以直接在UITableView里面使用，并且可以脱离UITableViewController。因为现在RefreshControl成为了ScrollView的一个属性了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> refreshControl = <span class="type">UIRefreshControl</span>()</div><div class="line">refreshControl.addTarget(<span class="keyword">self</span>, action: #selector(refreshControlDidFire(<span class="number">_</span>:)),</div><div class="line">                         <span class="keyword">for</span>: .valueChanged)</div><div class="line">collectionView.refreshControl = refreshControl</div></pre></td></tr></table></figure>
<p>UIRefreshControl的使用方法很简单，先创建一个refreshControl，再关联一个action事件，最后把这个新的refreshControl赋给想要的控件的对应的属性即可。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[H5游戏接入技术小结（下）]]></title>
      <url>https://iiiceblink.github.io/2016/05/20/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>在上一篇<a href="http://zakariyyasv.pub/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/" target="_blank" rel="external">H5游戏接入技术小结（上）</a>中，主要介绍了H5游戏资源的下载和运行。本篇文章主要是介绍app与H5游戏的交互以及在线与其他玩家对战的技术总结。<br><a id="more"></a></p>
<h3 id="app与H5游戏交互"><a href="#app与H5游戏交互" class="headerlink" title="app与H5游戏交互"></a>app与H5游戏交互</h3><p>app与游戏交互本质上就是app与浏览器进行交互，交互的媒介自然是要靠JS。交互的内容倒并不复杂，复杂的在于iOS版本的适配。iOS中<code>webview</code>有两个类<code>UIWebView</code>和<code>WKWebView</code>，性能方面来说<code>WKWebView</code>会更好一些（如果你对<code>UIWebView</code>和<code>WKWebView</code>的区别不太了解，可以看这篇<a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">博文</a>），但<code>WKWebView</code>是iOS 8之后才引入的，故iOS 8之前的版本只能采用<code>UIWebView</code>。JS与OC交互的类库用的较多的是<code>JavaScriptCore</code>和<code>WebViewJavaScriptBridge</code>，其中<code>JavaScriptCore</code>是iOS 7之后苹果开放的类库，而<code>WebViewJavaScriptBridge</code>则是第三方类库，并且作者也说明了对于<code>WKWebView</code>的支持上还存在bug。综合来看最佳的解决方案应该是<code>WKWebView</code>与<code>JavaScriptCore</code>的组合，然而在<code>WKWebView</code>中我们无法获取context，也就是说<code>WKWebView</code>不支持<code>JavaScriptCore</code>。综合考虑后，还是决定采用UIWebView与JavaScriptCore组合(iOS 7)与WKWebView与原生JS组合(iOS 8及以上)的方案。</p>
<h3 id="UIWebView与JavaScriptCore交互"><a href="#UIWebView与JavaScriptCore交互" class="headerlink" title="UIWebView与JavaScriptCore交互"></a>UIWebView与JavaScriptCore交互</h3><p>相比于<code>WebViewJavaScriptBridge</code>，<code>JavaScriptCore</code>的学习成本要更低一些。<code>JavaScriptCore</code>中包含了以下几个类：</p>
<blockquote>
<ul>
<li>JSContext</li>
<li>JSManagedValue</li>
<li>JSValue</li>
<li>JSVirtualMachine</li>
</ul>
</blockquote>
<p><code>JSContext</code>对象代表了JS的运行环境，我们可以创建和使用JS上下文来执行OC或者swift代码中的JS脚本，访问JS中定义或者计算出的值，让JS可以访问原生的对象，方法或者函数。<code>JSValue</code>是对JS中的值的引用。你可以用<code>JSValue</code>类在JS和OC（或swift）进行值类型的转换来互相传递数据。你还可以用该类创建JS对象封装原生的自定义类的对象或方法。<code>JSManagedValue</code>对象是对JSValue对象的封装，增加了“条件持有”的行为来对值进行自动内存管理。该类最基本的使用场景是将JS值存储在OC（或swift）对象中并将其传递给JS代码。<code>JSVirtualMachine</code>对象代表的是独立的JS运行环境。使用这个类有两个目的：支持JS并发执行和管理在JS和OC（或swift）桥接对象的内存。</p>
<h5 id="OC调用JS"><a href="#OC调用JS" class="headerlink" title="OC调用JS"></a>OC调用JS</h5><p>OC中调用JS代码主要依赖<code>JSContext</code>和<code>JSValue</code>类，一个 JSContext 是一个全局环境的实例。调用JS代码主要调用<code>JSContext</code>的<code>evaluteScript</code>方法，创建一个 JSContext 后，可以很容易地运行 JavaScript 代码来创建变量，做计算，甚至定义方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">JSContext *context = [[JSContext alloc] init];</div><div class="line">[context evaluateScript:<span class="string">@"var num = 5 + 5"</span>];</div><div class="line">[context evaluateScript:<span class="string">@"var names = ['Grace', 'Ada', 'Margaret']"</span>];</div><div class="line">[context evaluateScript:<span class="string">@"var triple = function(value) &#123; return value * 3 &#125;"</span>];</div><div class="line">JSValue *tripleNum = [context evaluateScript:<span class="string">@"triple(num)"</span>];</div></pre></td></tr></table></figure>
<p>代码的最后一行，任何出自<code>JSContext</code>的值都被包裹在一个<code>JSValue</code>对象中。像JavaScript 这样的动态语言需要一个动态类型，所以<code>JSValue</code>包装了每一个可能的JavaScript值：字符串和数字；数组、对象和方法；甚至错误和特殊的JavaScript值诸如null和undefined。如果想将<code>JSValue</code>类型转为OC（或swift）下的数据类型，可以调用<code>JSValue</code>相关的方法实现：</p>
<p><img src="/images/h5game/3.png" alt=""></p>
<p>若想调用JS代码中的方法，可以使用下标方式或者调用<code>objectForKeyedSubscript:</code>方法来实现。例如，我在JS文件中定义了求阶乘的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在OC中我们可以这样去调用计算阶乘的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">JSContext context = [[JSContext alloc] init];</div><div class="line"><span class="comment">// 执行指定路径下JS文件中的代码</span></div><div class="line">[context evaluateScript:[<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>]];</div><div class="line"><span class="comment">// 1.下标访问</span></div><div class="line">JSValue *function = <span class="keyword">self</span>.context[<span class="string">@"factorial"</span>];</div><div class="line"><span class="comment">// 2.方法访问</span></div><div class="line">JSValue *function = [<span class="keyword">self</span>.context objectForKeyedSubscript:<span class="string">@"factorial"</span>];</div><div class="line"><span class="comment">// 调用阶乘方法并传递参数</span></div><div class="line">JSValue *result = [function callWithArguments:@[@<span class="number">5</span>]];</div></pre></td></tr></table></figure>
<p>同时，<code>JSContext</code>也提供对于引用和异常本身的回调处理——通过设置context的<code>exceptionHandler</code>属性。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">context.exceptionHandler = ^(JSContext *context, JSValue *exception)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JS Error: %@"</span>, exception);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h5><p>JS访问客户端代码的方式主要有两种：block和<code>JSExport</code>协议。</p>
<p>先说第一种：block。当一个block被赋给<code>JSContext</code>里的一个标识符，<code>JavaScriptCore</code>会自动的把block封装在JS函数里。这使得在JS中可以简单的使用Foundation和Cocoa类，所有的桥接都为你做好了。例如下面代码中，弹出alertView的block被赋给context的”alert”，如果想要在JS中调用这个block，只需要调用<code>alert()</code>方法并传入参数即可。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context[<span class="string">@"alert"</span>] = ^(<span class="built_in">NSString</span> *str)&#123;</div><div class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc]initWithTitle:<span class="string">@"msg from js"</span> message:str delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"ok"</span> otherButtonTitles:<span class="literal">nil</span>];</div><div class="line">    [alert show];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [context evaluateScript:<span class="string">@"alert('hello')"</span>]);</div></pre></td></tr></table></figure>
<p>block方式使用起来很简单，但也有需要注意的地方。由于block对变量是强引用，而<code>JSContext</code>也强引用所有的变量，因此很容易会产生循环引用问题。这里有些注意点总结如下：</p>
<p>1.在block中不要直接使用context，而是用[JSContext currentContext]得到当前上下文。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 错误示范</span></div><div class="line"><span class="keyword">self</span>.context[<span class="string">@"name"</span>] = ^()&#123;</div><div class="line">     JSValue *value = [JSValue valueWithObject:<span class="string">@"aaa"</span> inContext:<span class="keyword">self</span>.context];</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 正确做法</span></div><div class="line"><span class="keyword">self</span>.context[<span class="string">@"name"</span>] = ^()&#123;</div><div class="line">     JSValue *value = [JSValue valueWithObject:<span class="string">@"aaa"</span> inContext:[JSContext currentContext]];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>2.不要在block中引用外部变量，而是将其作为参数进行传递。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">JSValue *value = [JSValue valueWithObject:<span class="string">@"ssss"</span> inContext:<span class="keyword">self</span>.context];</div><div class="line"><span class="comment">// 错误</span></div><div class="line"><span class="keyword">self</span>.context[<span class="string">@"name"</span>] = ^()&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,value);</div><div class="line">    &#125;;</div><div class="line"><span class="comment">// 正确</span></div><div class="line"><span class="keyword">self</span>.context[<span class="string">@"name"</span>] = ^(<span class="built_in">NSString</span> *str)&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str);</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>再说第二种：<code>JSExport</code>协议。这个协议可以让JS代码访问OC的类实例，实例方法，类方法和属性。以下以Person类为例来说明。首先，需要定义<code>PersonJSExpoert</code>协议继承<code>JSContext</code>，这个协议指定哪些属性和方法在JS中是可用的。然后，Person类需要去遵守并实现<code>PersonJSExpoert</code>协议。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  Person.h </span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Person</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonJSExports</span> &lt;<span class="title">JSExport</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> ageToday;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)getFullName;</div><div class="line"><span class="comment">// create and return a new Person instance with `firstName` and `lastName`</span></div><div class="line">+ (<span class="keyword">instancetype</span>)createWithFirstName:(<span class="built_in">NSString</span> *)firstName lastName:(<span class="built_in">NSString</span> *)lastName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">PersonJSExports</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> ageToday;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Person.m </span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">- (<span class="built_in">NSString</span> *)getFullName &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>, <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">instancetype</span>) createWithFirstName:(<span class="built_in">NSString</span> *)firstName lastName:(<span class="built_in">NSString</span> *)lastName &#123;</div><div class="line">    Person *person = [[Person alloc] init];</div><div class="line">    person.firstName = firstName;</div><div class="line">    person.lastName = lastName;</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样在JS中就可以创建新的Person实例,在这个例子中，<code>Objective-C</code>的方法<code>createWithFirstName:lastName:</code>变成了在JavaScript中的<code>createWithFirstNameLastName()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> loadPeopleFromJSON = <span class="function"><span class="keyword">function</span>(<span class="params">jsonString</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonString);</div><div class="line">    <span class="keyword">var</span> people = [];</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> person = Person.createWithFirstNameLastName(data[i].first, data[i].last);</div><div class="line">        person.birthYear = data[i].year;</div><div class="line">        people.push(person);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> people;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>JavaScriptCore</code>介绍完了，那么在<code>UIWebView</code>中若想要拿到<code>JSContext</code>对象，就要调用下面这个方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[webView valueForKeyPath:<span class="string">@"documentView.webView.mainFrame.javaScriptContext"</span>]</div></pre></td></tr></table></figure></p>
<p>这里涉及到<code>UIWebView</code>创建JSContext上下文环境的时机问题，那么什么时候<code>UIWebView</code>会创建JSContext的上下文环境呢？<br>默认情况下，在渲染网页时遇到<code>&lt;script&gt;</code>标签时，就会创建JSContext上下文环境去运行JS代码。还有就是调用<code>[webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]</code>去获取JSContext环境时，这时无论是否遇到<code>&lt;script&gt;</code>标签，都会去创造出来一个JSContext环境，而且和遇到<code>&lt;script&gt;</code>标签创造的环境是同一个。</p>
<p>这时候又牵扯到何时注入JSContext的问题。我通常都会在<code>- (void)webViewDidFinishLoad:(UIWebView *)webView</code>中去注入交互对象，但是这时候网页还没加载完，JavaScript那边已经调用交互方法，这样就会调不到原生应用的方法而出现问题。如果改成在<code>- (void)viewDidLoad</code>中去注入交互对象，这样倒是解决了上面的问题，但是同时又引起了一个新的问题就是在一个网页内部点击链接跳转到另一个网页的时候，第二个页面需要交互，这时JSContext环境已经变化，但是<code>- (void)viewDidLoad</code>仅仅加载一次，跳转的时候，没有再次注入交互对象，这样就会导致第二个页面没法进行交互。当然你可以在<code>- (void)viewDidLoad和- (void)webViewDidFinishLoad:(UIWebView *)webView</code>都注入一次。</p>
<h3 id="WKWebView与原生JS交互"><a href="#WKWebView与原生JS交互" class="headerlink" title="WKWebView与原生JS交互"></a>WKWebView与原生JS交互</h3><p>采用<code>WKWebView</code>与原生JS交互的原因在于<code>WKWebView</code>相比于<code>UIWebView</code>，其与JS交互的能力明显增强，并且在加载速度及内存占用上都有显著提升。<code>WKWebView</code>与JS交互主要依赖于两个概念：user scripts和script messages。</p>
<p>先说user scripts。简单来说，它是在<code>WKWebView</code>加载时被注入到web页面中的JS代码块。当然，user scripts也可以在页面内容(DOM)加载完成之前或者加载完成之后注入和运行。user scripts可以做到JS在页面中能做到的所有事情，包括操作DOM和调用页面中存在的已加载的任何JS方法。user scripts是原生app调用JS的方式。</p>
<p>再说script messages。script messages是web页面调用原生app的方式。一个script message与页面中的JS方法绑定，你需要在原生app中定义处理方法来负责处理web页面传过来的消息。script message可以由user script或者任何其他加载进页面的脚本触发。</p>
<p>以下我会以一个小demo来说明<code>WKWebView</code>与JS如何交互的。在demo中我要做到的是如何通过再原生app中调用JS方法来改变DOM元素的颜色并且同时监听html页面中的JS发送给原生app的异步消息。</p>
<p>为了能让web页面和<code>WKWebView</code>交互，我们需要两个主要的元素：</p>
<blockquote>
<p>1.带有可以被<code>WKWebView</code>加载的JS代码的web页面<br>2.可以与web页面进行通信交互的<code>WKWebView</code>原生app</p>
</blockquote>
<h5 id="Web页面"><a href="#Web页面" class="headerlink" title="Web页面"></a>Web页面</h5><p>web页面的构成很简单，包含两个文件：index.html和main.js，index.html是页面文件，main.js被index.html调用。main.js文件的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callNativeApp</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        webkit.messageHandlers.callbackHandler.postMessage(<span class="string">"Hello from JavaScript"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'The native context does not exist yet'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callNativeApp();</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">redHeader</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).style.color = <span class="string">"red"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当这段脚本代码被加载时，它会延迟5秒后调用<code>callNativeApp</code>方法。我们要注意的是”callbackHandler”，这是我们后面在原生app中定义的script message handler的名字。另外，我将回调”webkit.messageHandlers…..”封装进try-catch中来避免当脚本不再原生app的context下运行时会产生错误。最后还有一个改变html页面中h1标签颜色为红色的方法，后面我们会用到它。我将从本地服务器去加载它来模拟更真实的环境。</p>
<h5 id="原生app"><a href="#原生app" class="headerlink" title="原生app"></a>原生app</h5><p>关于<code>WKWebView</code>的使用在此就不赘述了，不了解的可以查阅苹果相关文档。首先我们要做的是创建<code>WKWebView</code>对象并指定测试的URL地址。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.webView = <span class="type">WKWebView</span>()</div><div class="line"><span class="keyword">var</span> url = <span class="type">NSURL</span>(string:<span class="string">"http://localhost/WKJSDemo/"</span>)</div><div class="line"><span class="keyword">var</span> req = <span class="type">NSURLRequest</span>(<span class="type">URL</span>:url)</div><div class="line"><span class="keyword">self</span>.webView!.loadRequest(req)</div></pre></td></tr></table></figure>
<h5 id="原生app调用JS"><a href="#原生app调用JS" class="headerlink" title="原生app调用JS"></a>原生app调用JS</h5><p><code>WKWebView</code>的初始化方法有一个参数叫configuration，接收的是<code>WKWebViewConfiguration</code>实例，通过这个实例我们可以设置webView是否开启调用JS。这里我们需要设置的是<code>WKWebViewConfiguration</code>的<code>userContentController</code>属性。这个属性接收<code>WKUserContentController</code>实例。该实例有个方法叫做<code>addUserScript</code>，我们调用该方法添加user script。下面给出示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> contentController = <span class="type">WKUserContentController</span>();</div><div class="line"><span class="keyword">var</span> userScript = <span class="type">WKUserScript</span>(</div><div class="line">    source: <span class="string">"redHeader()"</span>,</div><div class="line">    injectionTime: <span class="type">WKUserScriptInjectionTime</span>.<span class="type">AtDocumentEnd</span>,</div><div class="line">    forMainFrameOnly: <span class="literal">true</span></div><div class="line">)</div><div class="line">contentController.addUserScript(userScript)</div><div class="line"></div><div class="line"><span class="keyword">var</span> config = <span class="type">WKWebViewConfiguration</span>()</div><div class="line">config.userContentController = contentController</div><div class="line"><span class="keyword">self</span>.webView = <span class="type">WKWebView</span>(</div><div class="line">    frame: <span class="keyword">self</span>.containerView.bounds,</div><div class="line">    configuration: config</div><div class="line">)</div></pre></td></tr></table></figure>
<p>在<code>WKUserScript</code>初始化方法中<code>redHeader()</code>对应的JS文件中的同名方法。”injectionTime”参数告诉user script当HTML页面的body加载完时运行脚本代码。”forMainFrameOnly”参数是说脚本只会被注入HTML页面的主帧中。</p>
<p>现在我们运行代码，就会发现HTML页面的头部文字是红色的。</p>
<h5 id="JS调用原生app"><a href="#JS调用原生app" class="headerlink" title="JS调用原生app"></a>JS调用原生app</h5><p>我们已经知道原生app中如何调用JS代码，那么JS如何调用原生app呢？正如我们之前说过的，这要用到”script messages”。</p>
<p>为了能接收到来自JS的事件，控制器需要遵守<code>WKScriptMessageHandler</code>协议。这意味着两点，我们要继承<code>WKScriptMessageHandler</code>并且实现<code>userContentController</code>的代理方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(userContentController: WKUserContentController!, didReceiveScriptMessage message: WKScriptMessage!)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span>(message.name == <span class="string">"callbackHandler"</span>) &#123;</div><div class="line">        <span class="built_in">println</span>(<span class="string">"JavaScript is sending a message \(message.body)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们注意到代理方法会检查消息的名字是否为”callbackHandler”，回想之前的JS代码中有一行是这样的：”webkit.messageHandlers.callbackHandler.postMessage…”。原生app的方法会检查接收到的script message是否是想要的，如果是想要的，则在控制台打印消息的所有信息。</p>
<p>接下来，我们需要告诉webview开始监听来自JS的事件。这需要我们给<code>contentController</code>添加”script handler”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">contentController.addScriptMessageHandler( <span class="keyword">self</span>, name: <span class="string">"callbackHandler"</span>)</div></pre></td></tr></table></figure>
<p>第一个参数self是指script message的代理是<code>ViewController</code>。如果你想在另一个类中处理接收到的消息，需要将该类的实例传入。第二个参数传入的是在JS中调用原生<code>userContentController</code>代理方法的名字。</p>
<p>写完后编译运行，5秒后控制台会打印出信息。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// index.html</div><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">            body &#123;</div><div class="line">                padding-top: 40px; </div><div class="line">            &#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>WKWebView Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WKWebView Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callNativeApp</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        webkit.messageHandlers.callbackHandler.postMessage(<span class="string">"Hello from JavaScript"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'The native context does not exist yet'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    callNativeApp();</div><div class="line">&#125;, <span class="number">5000</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">redHeader</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'h1'</span>).style.color = <span class="string">"red"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ViewController.swift</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"><span class="keyword">import</span> WebKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">WKScriptMessageHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">var</span> containerView : <span class="type">UIView</span>! = <span class="literal">nil</span></div><div class="line">    <span class="keyword">var</span> webView: <span class="type">WKWebView</span>?</div><div class="line">                            </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.loadView()</div><div class="line">        <span class="keyword">var</span> contentController = <span class="type">WKUserContentController</span>();</div><div class="line">        <span class="keyword">var</span> userScript = <span class="type">WKUserScript</span>(source: <span class="string">"redHeader()"</span>, injectionTime: <span class="type">WKUserScriptInjectionTime</span>.<span class="type">AtDocumentEnd</span>, forMainFrameOnly: <span class="literal">true</span></div><div class="line">        )</div><div class="line">        contentController.addUserScript(userScript)</div><div class="line">        contentController.addScriptMessageHandler( <span class="keyword">self</span>, name: <span class="string">"callbackHandler"</span>)</div><div class="line">        <span class="keyword">var</span> config = <span class="type">WKWebViewConfiguration</span>()</div><div class="line">        config.userContentController = contentController</div><div class="line">        <span class="keyword">self</span>.webView = <span class="type">WKWebView</span>(frame: <span class="keyword">self</span>.containerView.bounds,configuration: config)</div><div class="line">        <span class="keyword">self</span>.view = <span class="keyword">self</span>.webView!</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        <span class="keyword">var</span> url = <span class="type">NSURL</span>(string:<span class="string">"http://localhost/~jornki/tests/WKDemo/"</span>)</div><div class="line">        <span class="keyword">var</span> req = <span class="type">NSURLRequest</span>(<span class="type">URL</span>:url)</div><div class="line">        <span class="keyword">self</span>.webView!.loadRequest(req)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(userContentController: WKUserContentController!, didReceiveScriptMessage message: WKScriptMessage!)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span>(message.name == <span class="string">"callbackHandler"</span>) &#123;</div><div class="line">            <span class="built_in">println</span>(<span class="string">"JavaScript is sending a message \(message.body)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[H5游戏接入技术小结（上）]]></title>
      <url>https://iiiceblink.github.io/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>这段时间忙着做游戏平台H5游戏的接入，趁着刚做完还热乎劲儿，将其中的技术要点总结下来。H5游戏的接入主要分为两个部分：游戏的下载和游戏对战。本篇博客着重讲述游戏的下载部分，下篇博客将着重讲述H5游戏与app通过JS进行数据交互以及在线对战的技术要点。</p>
<p>H5游戏资源本质上是由一些目录以及目录下的文件资源组成，要能够在app中运行H5游戏，就是要在<code>WKWebView</code>的浏览器中用HTTPServer搭建本地服务，然后去加载游戏资源根目录下的index.html文件，换句话说index.html文件是游戏的入口文件。<a id="more"></a>HTTPServer我们采用的是开源的<a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="external">CocoaHTTPServer</a>，关于在app中搭建HTTPServer服务的内容就不多赘述，感兴趣的可以去Github上了解。当然，这也需要H5与iOS开发人员沟通和调试才能真正地在<code>WKWebView</code>中流畅运行。</p>
<h3 id="游戏资源下载思路"><a href="#游戏资源下载思路" class="headerlink" title="游戏资源下载思路"></a>游戏资源下载思路</h3><p>知道了怎样在app中运行H5游戏，接下来最重要的就是游戏资源的下载。当用户进入一个游戏后，游戏的状态分为三种：未下载，已下载，暂停下载和需要更新。如何判断游戏此时的状态呢？首先我们需要区分每一个游戏，因此，约定将游戏资源的URL进行MD5加密后的字符串作为游戏的唯一标识符。之后，我们创建<code>game.plist</code>文件，文件中存储一个字典，字典的key为游戏的标识符，value为游戏资源的大小。每当一个游戏开始下载，则在plist文件中添加一条记录。检查游戏的状态时，拿游戏的标识符与plist文件中所有的记录进行对比，若未找到相同的记录则状态为未下载。否则，在存储游戏资源的文件夹中查找以游戏标识符命名的.zip压缩包，若找到将其包的大小与plist文件中找到的记录的大小进行比较，若大小不同，则状态为暂停下载，若未找到压缩包且未找到解压后的资源文件夹显示为未下载。否则，状态为已下载。至于更新的状态则需要与服务器端进行沟通和约定，在此就不讲了。</p>
<p><img src="/images/h5game/1.png" alt=""></p>
<p>确定完当前进入游戏的状态后，当游戏处于未下载或者暂停的状态时，用户可以点击下载按钮进行下载。下载的过程分为两种情况：未下载开始下载和暂停继续下载。第一种情况的下载过程是这样：在资源下载目录下创建以游戏标识符命名的.zip压缩文件，用<code>NSURLSession</code>创建<code>NSURLSessionDataTask</code>任务负责资源数据的接收，用<code>NSOutputStream</code>负责数据流的写入工作。写入完毕后，关闭<code>NSOutputStream</code>服务，验证资源包数据的完整性。若资源包数据完整，则对其进行解压缩，得到游戏运行的全部资源文件后便可以开始游戏。第二种情况则是在资源下载目录下查找以游戏标识符命名的.zip压缩包，获取包文件的内容大小，将其放入<code>NSURLRequest</code>的HTTP请求头中，剩下的步骤与第一种情况相同。</p>
<p><img src="/images/h5game/2.png" alt=""></p>
<h3 id="游戏资源下载的代码实现"><a href="#游戏资源下载的代码实现" class="headerlink" title="游戏资源下载的代码实现"></a>游戏资源下载的代码实现</h3><p>思路厘清了，就需要用代码去实现它。因此，我创建了名为<code>XRDownloadManger</code>的类负责游戏资源的下载工作。为了更好的辅助<code>XRDownloadManager</code>工作，又创建了模型类<code>XRSessionModel</code>来存储游戏资源的相关数据。</p>
<p>下面列出的是<code>XRSessionModel</code>的类结构：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// XRSessionModel.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    DownloadStateStart = <span class="number">0</span>,     <span class="comment">/** 下载中 */</span></div><div class="line">    DownloadStateSuspended,     <span class="comment">/** 下载暂停 */</span></div><div class="line">    DownloadStateCompleted,     <span class="comment">/** 下载完成 */</span></div><div class="line">    DownloadStateFailed         <span class="comment">/** 下载失败 */</span></div><div class="line">&#125;DownloadState;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XRSessionModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">/** 流 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *stream;</div><div class="line"><span class="comment">/** 下载地址 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *url;</div><div class="line"><span class="comment">/** 游戏版本号*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *update;</div><div class="line"><span class="comment">/** 获得服务器这次请求 返回数据的总长度 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> totalLength;</div><div class="line"><span class="comment">/** 下载进度 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^progressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">CGFloat</span> progress);</div><div class="line"><span class="comment">/** 下载状态 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^stateBlock)(DownloadState state);</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>XRDownloadManger</code>采用了单例设计模式，该类主要的工作包括开启任务下载游戏资源并回调下载进度和下载状态，获取资源大小，删除已下载资源，判断游戏资源是否下载完成等。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XRDownloadManager</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  单例</div><div class="line"> *  @return 返回单例对象</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  开启任务下载资源</div><div class="line"> *  @param url           下载地址</div><div class="line"> *  @param progressBlock 回调下载进度</div><div class="line"> *  @param stateBlock    下载状态</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)download:(<span class="built_in">NSString</span> *)url update:(<span class="built_in">NSString</span> *)update progress:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">CGFloat</span> progress))progressBlock state:(<span class="keyword">void</span>(^)(DownloadState state))stateBlock;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  查询该资源的下载进度值</div><div class="line"> *  @param url 下载地址</div><div class="line"> *  @return 返回下载进度值</div><div class="line"> */</div><div class="line">- (<span class="built_in">CGFloat</span>)progress:(<span class="built_in">NSString</span> *)url;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  获取该资源总大小</div><div class="line"> *  @param url 下载地址</div><div class="line"> *  @return 资源总大小</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSInteger</span>)fileTotalLength:(<span class="built_in">NSString</span> *)url;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  判断该资源是否下载完成</div><div class="line"> *  @param url 下载地址</div><div class="line"> *  @return YES: 完成</div><div class="line"> */</div><div class="line">- (<span class="built_in">BOOL</span>)isCompletion:(<span class="built_in">NSString</span> *)url;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  删除该资源</div><div class="line"> *  @param url 下载地址</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)deleteFile:(<span class="built_in">NSString</span> *)url;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  清空所有下载资源</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)deleteAllFile;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  根据下载地址查找该资源路径</div><div class="line"> **/</div><div class="line">- (<span class="built_in">NSString</span> *)getPathWithUrl:(<span class="built_in">NSString</span> *)url;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>XRDownloadManger</code>实现文件中包含两个可变字典类型的成员变量<code>tasks</code>和<code>sessionModels</code>，<code>tasks</code>负责保存所有的下载任务，<code>sessionModels</code>负责保存所有的下载资源的相关信息。<code>tasks</code>和<code>sessionModels</code>均是以url为key，但value分别为<code>NSURLSessionDataTask</code>和<code>XRSessionModel</code>的键值对。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)tasks&#123;</div><div class="line">    <span class="keyword">if</span> (!_tasks) &#123;</div><div class="line">        _tasks = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _tasks;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)sessionModels&#123;</div><div class="line">    <span class="keyword">if</span> (!_sessionModels) &#123;</div><div class="line">        _sessionModels = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _sessionModels;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>download:::</code>方法是负责下载的主要方法。每一个<code>NSURLSessionDataTask</code>对象负责一个游戏资源的下载，并将该对象存入tasks中。当下载完成并验证压缩包内容的完整性后将<code>NSURLSessionDataTask</code>对象移除，当需要暂停的时候，以游戏URL的md5字符串为key拿到<code>NSURLSessionDataTask</code>对象并执行suspend方法将下载任务暂停。暂停后继续下载也与之类似，同样是从tasks中拿到<code>NSURLSessionDataTask</code>对象并执行resume方法继续下载任务。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  开启任务下载资源</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)download:(<span class="built_in">NSString</span> *)url update:(<span class="built_in">NSString</span> *)update progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSInteger</span>, <span class="built_in">NSInteger</span>, <span class="built_in">CGFloat</span>))progressBlock state:(<span class="keyword">void</span> (^)(DownloadState))stateBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!url) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 判断资源是否下载完成</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCompletion:url]) &#123;</div><div class="line">        stateBlock(DownloadStateCompleted);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 暂停下载</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.tasks valueForKey:XRFileName(url)]) &#123;</div><div class="line">        [<span class="keyword">self</span> handle:url];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建缓存目录文件</span></div><div class="line">    [<span class="keyword">self</span> createCacheDirectory];</div><div class="line">   <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration] delegate:<span class="keyword">self</span> delegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</div><div class="line">    <span class="comment">// 创建流</span></div><div class="line">    <span class="built_in">NSOutputStream</span> *stream = [<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:XRFileFullpath(url) append:<span class="literal">YES</span>];</div><div class="line">    <span class="comment">// 创建URL请求</span></div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url]];</div><div class="line">    <span class="comment">// 设置下载内容范围的请求头</span></div><div class="line">    <span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%zd-"</span>, XRDownloadLength(url)];</div><div class="line">    [request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</div><div class="line">    <span class="comment">// 创建一个Data任务</span></div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request];</div><div class="line">    <span class="built_in">NSUInteger</span> taskIdentifier = arc4random() % ((arc4random() % <span class="number">10000</span> + arc4random() % <span class="number">10000</span>));</div><div class="line">    [task setValue:@(taskIdentifier) forKeyPath:<span class="string">@"taskIdentifier"</span>];</div><div class="line">    <span class="comment">// 保存任务</span></div><div class="line">    [<span class="keyword">self</span>.tasks setValue:task forKey:XRFileName(url)];</div><div class="line">    XRSessionModel *sessionModel = [[XRSessionModel alloc] init];</div><div class="line">    sessionModel.url = url;</div><div class="line">    sessionModel.update = update;</div><div class="line">    sessionModel.progressBlock = progressBlock;</div><div class="line">    sessionModel.stateBlock = stateBlock;</div><div class="line">    sessionModel.stream = stream;</div><div class="line">    [<span class="keyword">self</span>.sessionModels setValue:sessionModel forKey:@(task.taskIdentifier).stringValue];</div><div class="line">    [<span class="keyword">self</span> start:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  判断该文件是否下载完成</div><div class="line"> */</div><div class="line">- (<span class="built_in">BOOL</span>)isCompletion:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> fileTotalLength:url] &amp;&amp; XRDownloadLength(url) == [<span class="keyword">self</span> fileTotalLength:url]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 若暂停则继续下载，若正在下载则暂停下载</span></div><div class="line">- (<span class="keyword">void</span>)handle:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span> getTask:url];</div><div class="line">    <span class="keyword">if</span> (task.state == <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> pause:url];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> start:url];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  根据url获得对应的下载任务</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)getTask:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSURLSessionDataTask</span> *)[<span class="keyword">self</span>.tasks valueForKey:XRFileName(url)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  开始下载</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)start:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span> getTask:url];</div><div class="line">    [task resume];</div><div class="line">    [<span class="keyword">self</span> getSessionModel:task.taskIdentifier].stateBlock(DownloadStateStart);</div><div class="line">    <span class="comment">// 删除暂停状态</span></div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:XRPausePath]) &#123;</div><div class="line">        <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionaryWithContentsOfFile:XRPausePath];</div><div class="line">        [dict removeObjectForKey:XRFileName(url)];</div><div class="line">        [dict writeToFile:XRPausePath atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  暂停下载</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)pause:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span> getTask:url];</div><div class="line">    [task suspend];</div><div class="line">    [<span class="keyword">self</span> getSessionModel:task.taskIdentifier].stateBlock(DownloadStateSuspended);</div><div class="line">    <span class="comment">// 存储暂停状态</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionaryWithContentsOfFile:XRPausePath];</div><div class="line">    <span class="keyword">if</span> (dict == <span class="literal">nil</span>) dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    dict[XRFileName(url)] = <span class="string">@"pause"</span>;</div><div class="line">    [dict writeToFile:XRPausePath atomically:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  根据url获取对应的下载信息模型</div><div class="line"> */</div><div class="line">- (XRSessionModel *)getSessionModel:(<span class="built_in">NSUInteger</span>)taskIdentifier&#123;</div><div class="line">    <span class="keyword">return</span> (XRSessionModel *)[<span class="keyword">self</span>.sessionModels valueForKey:@(taskIdentifier).stringValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  查询该资源的下载进度值</div><div class="line"> */</div><div class="line">- (<span class="built_in">CGFloat</span>)progress:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> fileTotalLength:url] == <span class="number">0</span> ? <span class="number">0.0</span> : <span class="number">1.0</span> * XRDownloadLength(url) /  [<span class="keyword">self</span> fileTotalLength:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  获取该资源总大小</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSInteger</span>)fileTotalLength:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:XRTotalLengthFullpath][XRFileName(url)] integerValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  根据下载地址查找该资源路径</div><div class="line"> **/</div><div class="line">-(<span class="built_in">NSString</span> *)getPathWithUrl:(<span class="built_in">NSString</span> *)url&#123;</div><div class="line">    <span class="built_in">NSString</span> *str = XRFileFullpath(url);</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个网络数据的请求和处理都依赖于<code>NSURLSessionDataDelegate</code>的代理方法。请求得到反馈时根据response拿到游戏资源的完整大小，并将其写入到<code>game.plist</code>文件中。当客户端开始接收服务器返回的数据时，打开<code>NSOutputStream</code>并开始将接收到的数据写入到指定路径下的文件中，并返回下载进度。接收数据完成后对数据包进行解压缩，解压成功则将写入流关闭并将下载任务从tasks中移除。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - NSURLSessionDataDelegate</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 接收到响应</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span>))completionHandler&#123;</div><div class="line">    XRSessionModel *sessionModel = [<span class="keyword">self</span> getSessionModel:dataTask.taskIdentifier];</div><div class="line">    <span class="comment">// 打开流</span></div><div class="line">    [sessionModel.stream open];</div><div class="line">    <span class="comment">// 获得服务器这次请求 返回数据的总长度</span></div><div class="line">    <span class="built_in">NSInteger</span> totalLength = [response.allHeaderFields[<span class="string">@"Content-Length"</span>] integerValue] + XRDownloadLength(sessionModel.url);</div><div class="line">    sessionModel.totalLength = totalLength;</div><div class="line">    <span class="comment">// 存储总长度</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionaryWithContentsOfFile:XRTotalLengthFullpath];</div><div class="line">    <span class="keyword">if</span> (dict == <span class="literal">nil</span>) dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    dict[XRFileName(sessionModel.url)] = @(totalLength);</div><div class="line">    [dict writeToFile:XRTotalLengthFullpath atomically:<span class="literal">YES</span>];</div><div class="line">    <span class="comment">// 接收这个请求，允许接收服务器的数据</span></div><div class="line">    completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 接收到服务器返回的数据</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data&#123;</div><div class="line">    XRSessionModel *sessionModel = [<span class="keyword">self</span> getSessionModel:dataTask.taskIdentifier];</div><div class="line">    <span class="comment">// 写入数据</span></div><div class="line">    [sessionModel.stream write:data.bytes maxLength:data.length];</div><div class="line">    <span class="comment">// 下载进度</span></div><div class="line">    <span class="built_in">NSUInteger</span> receivedSize = XRDownloadLength(sessionModel.url);</div><div class="line">    <span class="built_in">NSUInteger</span> expectedSize = sessionModel.totalLength;</div><div class="line">    <span class="built_in">CGFloat</span> progress = <span class="number">1.0</span> * receivedSize / expectedSize;</div><div class="line">    sessionModel.progressBlock(receivedSize, expectedSize, progress);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 请求完毕（成功|失败）</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error&#123;</div><div class="line">    XRSessionModel *sessionModel = [<span class="keyword">self</span> getSessionModel:task.taskIdentifier];</div><div class="line">    <span class="keyword">if</span> (!sessionModel) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCompletion:sessionModel.url]) &#123;</div><div class="line">        <span class="comment">//  下载完成，解压缩</span></div><div class="line">        [SSZipArchive unzipFileAtPath:XRFileFullpath(sessionModel.url) toDestination:XRWebDirectory];</div><div class="line">        sessionModel.stateBlock(DownloadStateCompleted);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error)&#123;</div><div class="line">        <span class="comment">// 下载失败</span></div><div class="line">        sessionModel.stateBlock(DownloadStateFailed);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 关闭流</span></div><div class="line">    [sessionModel.stream close];</div><div class="line">    sessionModel.stream = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 清除任务</span></div><div class="line">    [<span class="keyword">self</span>.tasks removeObjectForKey:XRFileName(sessionModel.url)];</div><div class="line">    [<span class="keyword">self</span>.sessionModels removeObjectForKey:@(task.taskIdentifier).stringValue];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上是对下载过程实现的大概描述，其中的实现细节还有很多值得推敲和优化的地方，接下来会发时间去优化并会将优化后的效果总结出来。如果其中有错误的地方欢迎指正。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[庖丁解牛KVO（二）——KVO实现原理]]></title>
      <url>https://iiiceblink.github.io/2016/04/23/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>在上一篇文章中，我们已经了解了KVO的使用场景以及使用方法。作为Objective-c中异常强大和重要的特性，我们有必要去了解和探索KVO底层的实现机制。</p>
<p>KVO的实现机制到底是怎么样的呢？依据苹果官方文档的介绍：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
<p>The is a pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<a id="more"></a>
<p>总结一下，这段话的关键字是<code>isa-swizzling</code>，当某个对象的属性被另一个对象观察时，被观察者的isa指针会被修改，指向一个中间类而不是原来的类。至于这个中间类到底是怎么样的，文档没有描述，可见苹果并不想暴露KVO的实现细节。所以，要想了解KVO底层的实现原理，还需要自己动手去研究。</p>
<h3 id="实现原理剖析"><a href="#实现原理剖析" class="headerlink" title="实现原理剖析"></a>实现原理剖析</h3><p>KVO机制在NSObject类中已经实现，故而所有继承NSObject类的子类均可以直接使用KVO。既然是追本溯源，那就要从剖析NSObject类开始。查阅runtime文件时，发现了以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#if !OBJC_TYPES_DEFINED</span></div><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"></div><div class="line"><span class="comment">/// Represents an instance of a class.</span></div><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/// A pointer to an instance of a class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>从这段代码中我们可以看出，NSObject只有一个Class类型的isa变量，Class则是<code>objc_class</code>类型的指针，<code>objc_class</code>则是包含isa变量的结构体（实际上NSObject的底层实现比这要复杂得多）。根据文档的注释，Class代表的是一个Objective-c类，而<code>objc_object</code>则代表的是一个类的实例。由此也可推导出isa变量实际上指向的是对象本身所代表的类。</p>
<p>根据前面文档所说，KVO实现依赖的技术叫做<code>isa-swizzling</code>。也就是说KVO在isa上作了文章，那要探究KVO的底层实现，就要去追踪isa，看看在KVO的过程中isa指向的类到底发生了什么。由于isa是类的私有变量，无法直接访问。在查阅了runtime中关于<code>NSOjbect.mm</code>实现文件中找到了方法去间接访问isa变量。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="keyword">class</span> &#123;</div><div class="line">  <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Class object_getClass(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> _object_getClass(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> Class _object_getClass(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;isa;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这段代码中可以看出，我们可以调用<code>object_getClass</code>方法访问对象的isa指针，同时，这段代码也说明了isa本质上就是代表一个对象的类型。</p>
<p>以下是为追踪KVO实现过程编写的测试代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *weight;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Cat</span></span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *classMethodNameList(Class c)&#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</div><div class="line">    Method *methodList = class_copyMethodList(c, &amp;methodCount);</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; methodCount; i++)</div><div class="line">        [array addObject: <span class="built_in">NSStringFromSelector</span>(method_getName(methodList[i]))];</div><div class="line">    free(methodList);</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> customDescription(<span class="built_in">NSString</span> *name,<span class="keyword">id</span> obj)&#123;</div><div class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:</div><div class="line">                     <span class="string">@"%@: %@\n\tNSObject class %s\n\tlibobjc class %s\n\timplements methods &lt;%@&gt;"</span>,</div><div class="line">                     name,</div><div class="line">                     obj,</div><div class="line">                     class_getName([obj <span class="keyword">class</span>]),</div><div class="line">                     class_getName(object_getClass(obj)),</div><div class="line">                     [classMethodNameList(object_getClass(obj)) componentsJoinedByString:<span class="string">@", "</span>]];</div><div class="line">    printf(<span class="string">"%s\n"</span>, [str UTF8String]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        Cat *A = [[Cat alloc] init];</div><div class="line">        Cat *B = [[Cat alloc] init];</div><div class="line">        Cat *C = [[Cat alloc] init];</div><div class="line">        Cat *D = [[Cat alloc] init];</div><div class="line">        [A addObserver:A forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">        [B addObserver:A forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">        [C addObserver:B forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">NULL</span>];</div><div class="line">        customDescription(<span class="string">@"A"</span>, A);</div><div class="line">        customDescription(<span class="string">@"B"</span>, B);</div><div class="line">        customDescription(<span class="string">@"C"</span>, C);</div><div class="line">        customDescription(<span class="string">@"D"</span>, D);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>简单解释下这段代码，<code>classMethodNameList</code>方法返回的是在运行时类的方法列表，不过，方法列表中并不包含父类的方法。<code>customDescription</code>方法打印的是对象名，对象对应的类，在运行时对象指向的类，以及运行时对象指向的类所实现的所有方法。实例化四个Cat对象A、B、C、D，A、B、C分别以不同的方式去观察，D则没有观察者。</p>
<p>以下是运行的输出结果：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">A: &lt;Cat: <span class="number">0x100500aa0</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span>: Cat</div><div class="line">	libobjc <span class="keyword">class</span>: <span class="built_in">NSKVONotifying_Cat</span></div><div class="line">	implements methods: &lt;setAge:, setName:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;</div><div class="line">B: &lt;Cat: <span class="number">0x1005035f0</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span>: Cat</div><div class="line">	libobjc <span class="keyword">class</span>: <span class="built_in">NSKVONotifying_Cat</span></div><div class="line">	implements methods: &lt;setAge:, setName:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;</div><div class="line">C: &lt;Cat: <span class="number">0x100503610</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span>: Cat</div><div class="line">	libobjc <span class="keyword">class</span>: <span class="built_in">NSKVONotifying_Cat</span></div><div class="line">	implements methods: &lt;setAge:, setName:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;</div><div class="line">D: &lt;Cat: <span class="number">0x1005037a0</span>&gt;</div><div class="line">	<span class="built_in">NSObject</span> <span class="keyword">class</span>: Cat</div><div class="line">	libobjc <span class="keyword">class</span>: Cat</div><div class="line">	implements methods: &lt;setWeight:, name, setName:, weight, .cxx_destruct, age, setAge:&gt;</div></pre></td></tr></table></figure></p>
<p>A、B被观察的属性都是”name”，而C被观察的属性是”age”。A、B、C在runtime下所指向的类均是<code>NSKVONotifying_Cat</code>，这个类应该就是<code>isa-swizzling</code>中的中间类。而并没有被观察的D在runtime下锁指向的仍然是Cat类。这说明只有在对象的属性被观察的时候才会动态创建中间类，对象的isa指针也就不再指向原来的类，而是指向这个中间类。被观察的属性中没有包括weight，而动态生成的中间类所实现的方法列表中也没有重写<code>setWeight:</code>方法，说明方法是按需动态重写的。此外，仔细观察，我们发现虽然A、B只有name属性被观察了，但是动态生成的中间类仍然实现了<code>setAge:</code>方法，说明A、B、C在运行时实际上指向的是同一个中间类。另外，方法列表中有一个叫做<code>_isKVOA</code>的方法引起我的注意，这应该是一个私有方法，无从得知关于这个方法更多的实现细节，暂时悬在这里，待日后有机会能解开这个疑惑。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[庖丁解牛KVO（一）——KVO概览和使用]]></title>
      <url>https://iiiceblink.github.io/2016/04/13/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94KVO%E6%A6%82%E8%A7%88%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（<code>-bind:toObject:withKeyPath:options:</code>）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。</p>
<p>KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。</p>
<p>在通知机制中，KVO与<code>NSNotification</code>提供的通知机制类似，但是也存在很鲜明的区别。<code>NSNotification</code>是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。<br><a id="more"></a><br>由于基类<code>NSObject</code>提供了对于KVO的基本实现，因而所有的cocoa对象本质上都能够使用KVO。为了能够接收到KVO的通知，你必须要做以下几件事：</p>
<blockquote>
<ul>
<li><p>你必须确保被观察类的属性符合KVO规则（KVO Compliance）。KVO规定被观察对象的类必须符合KVC规则（KVC Compliance）同时允许属性的自动观察者通知或者手动实现属性的KVO。</p>
</li>
<li><p>给值会发生改变的对象（即被观察者）添加观察者。你可以通过调用<code>addObserver:forKeyPath:options:context:</code>方法做到。</p>
</li>
<li><p>在观察者对象中，实现方法<code>observeValueForKeyPath:ofObject:change:context:</code>。该方法在被观察对象的属性值发生变化时会被调用。</p>
</li>
</ul>
</blockquote>
<p>第二点和第三点很好理解，第一点则需要多说一点。并不是说所有类的属性都满足KVO规则，他需要满足以下几个条件：</p>
<blockquote>
<ul>
<li><p>类的属性必须满足KVC规则。KVO与KVC支持的数据类型相同，包括OC对象、标量和结构体。</p>
</li>
<li><p>类要发送属性变化的KVO通知。</p>
</li>
<li><p>依赖的键需要被正确的注册。</p>
</li>
</ul>
</blockquote>
<p>关于第一点，何为满足KVC规则？对于一个满足KVC规则的指定属性，它必须实现<code>valueForKey:</code>和<code>setValue:forKey:</code>来作用于指定属性。更详细地：</p>
<blockquote>
<p>对于対一关系的属性，它的类必须做到：</p>
<ul>
<li>实现方法名为<code>-&lt;key&gt;</code>，<code>-is&lt;key&gt;</code>的方法，或者创建对象名为<key>或者_<key>的实例对象。</key></key></li>
<li>如果属性是可变的，那么它还需要实现<code>-set&lt;key&gt;:</code>方法。</li>
<li><code>-set&lt;Key&gt;:</code>的方法实现不应该包含验证操作。</li>
<li>若key需要进行验证它的类还需要实现<code>-validate&lt;Key&gt;:error:</code>方法。</li>
</ul>
<p>对于有索引的对多关系的属性，它的类必须要做到：</p>
<ul>
<li>实现方法名为<code>-&lt;key&gt;</code>的方法并返回数组。</li>
<li>或者有变量名为<key>或_<key>的实例变量。</key></key></li>
<li>或者实现方法<code>-countOf&lt;key&gt;</code>和<code>-objectIn&lt;key&gt;``-&lt;key&gt;AtIndexes:</code>两个方法中的一个。</li>
<li>另外，你可以实现<code>-get&lt;key&gt;:range:</code>来优化性能。</li>
</ul>
<p>对于无序的对多关系的属性，它的类需要做到：</p>
<ul>
<li>实现方法名为<code>-&lt;key&gt;</code>的方法并并返回一个集合。</li>
<li>或者创建变量名为<key>或_<key>的实例变量。</key></key></li>
<li>或者实现方法<code>-countOf&lt;key&gt;</code>、<code>-enumeratorOf&lt;key&gt;</code>和<code>-memberOf&lt;key&gt;:</code>。<br>若该属性还是可变的，它的类还需做到：</li>
<li>实现<code>-add&lt;key&gt;Object:</code>和<code>-add&lt;key&gt;:</code>中的一个或两个。</li>
<li>实现<code>-remove&lt;key&gt;Object:</code>和<code>-remove&lt;key&gt;:</code>中的一个或两个。</li>
<li>另外，你可以实现<code>-intersect&lt;key&gt;:</code>和<code>-set&lt;key&gt;:</code>来优化性能。</li>
</ul>
</blockquote>
<p>关于第二点，如何确保通知被发送？对于所有满足KVC规则的类的属性已经自动支持KVO。因此，只要你遵守标准Cocoa编码和命名规范，你可以使用自动变化通知（Automatic Change Notification）————你不需要编写额外的代码。<br>以下代码示例会触发KVO变化通知被发送：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Call the accessor method.</span></div><div class="line">[account setName:<span class="string">@"Savings"</span>];</div><div class="line"> </div><div class="line"><span class="comment">// Use setValue:forKey:.</span></div><div class="line">[account setValue:<span class="string">@"Savings"</span> forKey:<span class="string">@"name"</span>];</div><div class="line"> </div><div class="line"><span class="comment">// Use a key path, where 'account' is a kvc-compliant property of 'document'.</span></div><div class="line">[document setValue:<span class="string">@"Savings"</span> forKeyPath:<span class="string">@"account.name"</span>];</div><div class="line"> </div><div class="line"><span class="comment">// Use mutableArrayValueForKey: to retrieve a relationship proxy object.</span></div><div class="line">Transaction *newTransaction = &lt;<span class="meta">#Create a new transaction for the account#&gt;;</span></div><div class="line"><span class="built_in">NSMutableArray</span> *transactions = [account mutableArrayValueForKey:<span class="string">@"transactions"</span>];</div><div class="line">[transactions addObject:newTransaction];</div></pre></td></tr></table></figure>
<p>在某些情况下，你想控制通知的进程，比如想减少不必要的原因而触发通知的次数，或者想把多个变化整合进一个通知当中。这时候自动变化通知就无法满足需求，而手动变化通知（Manual Change Notification）则派上用场了。<br>在这种情况下，你需要重写<code>NSObject</code>的<code>automaticallyNotifiesObserversForKey:</code>方法。若你想将某个属性从自动变化通知中移除，则在<code>automaticallyNotifiesObserversForKey:</code>方法中返回NO。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)theKey &#123;</div><div class="line">    <span class="built_in">BOOL</span> automatic = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">if</span> ([theKey isEqualToString:<span class="string">@"balance"</span>]) &#123;</div><div class="line">        automatic = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        automatic = [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:theKey];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> automatic;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了实现手动变化通知，你需要在改变变量值�前触发<code>willChangeValueForKey:</code>方法并在改变变量值后触发<code>didChangeValueForKey:</code>方法。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</div><div class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">    _balance = theBalance;</div><div class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过检验值是否发生改变来减少不必要的通知发送。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setBalance:(<span class="keyword">double</span>)theBalance &#123;</div><div class="line">    <span class="keyword">if</span> (theBalance != _balance) &#123;</div><div class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">        _balance = theBalance;</div><div class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"balance"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>若一个操作引起多个属性值发生变化，你必须像下面这样嵌套变化的通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setBalance:(double)theBalance &#123;</div><div class="line">    [self willChangeValueForKey:@&quot;balance&quot;];</div><div class="line">    [self willChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    _balance = theBalance;</div><div class="line">    _itemChanged = _itemChanged+1;</div><div class="line">    [self didChangeValueForKey:@&quot;itemChanged&quot;];</div><div class="line">    [self didChangeValueForKey:@&quot;balance&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在有序的对多关系的属性中，你必须不仅指明改变的属性，而且还需指明改变的类型和涉及到的对象的索引值。改变的类型是<code>NSKeyValueChange</code>枚举，包含NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, NSKeyValueChangeReplacement。受影响的对象的索引值传入的是NSIndexSet对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeTransactionsAtIndexes:(<span class="built_in">NSIndexSet</span> *)indexes &#123;</div><div class="line">    [<span class="keyword">self</span> willChange:<span class="built_in">NSKeyValueChangeRemoval</span></div><div class="line">        valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</div><div class="line"> </div><div class="line">    <span class="comment">// Remove the transaction objects at the specified indexes.</span></div><div class="line"> </div><div class="line">    [<span class="keyword">self</span> didChange:<span class="built_in">NSKeyValueChangeRemoval</span></div><div class="line">        valuesAtIndexes:indexes forKey:<span class="string">@"transactions"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于第三点，在很多情况下某个属性依赖于另一个对象的一个或多个属性。如果一个属性值发生改变，那么受影响的属性其值也会发生改变。那么如何确保存在依赖关系的属性的KVO通知能正确发送？</p>
<p>在対一关系中，为了触发自动通知你需要重写<code>keyPathsForValuesAffectingValueForKey:</code>方法。<br>比如，一个人的名字包含姓和名。他的名字的全称可以用以下方法来写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)fullName &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当firstName或者lastName属性值发生改变时，观察fullName的对象必须接收到通知。其中一个解决方法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法来指明fullName属性依赖于lastName和firstName属性。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line"> </div><div class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"fullName"</span>]) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>];</div><div class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> keyPaths;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上面代码示例中，你的重写方法实现中必须要触发super方法调用，并且返回的集合中要包含父类的keys。<br>你还可以通过实现命名规则遵循<code>keyPathsForValuesAffecting&lt;Key&gt;</code>（Key为属性名并且首字母大写）的类方法来得到同样的结果。使用该方案对上面代码进行改写如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingFullName &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"lastName"</span>, <span class="string">@"firstName"</span>, <span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当你使用分类给现有的类添加属性时，不能重写<code>keyPathsForValuesAffectingValueForKey:</code>方法，因为在分类中不支持重写该方法。在这种情况下，只能通过实现<code>keyPathsForValuesAffecting&lt;Key&gt;</code>类方法来达到效果。</p>
<p>在对多关系中，<code>keyPathsForValuesAffectingValueForKey:</code>方法不支持。比如，你有一个Deprtment对象与employee对象的对多关系，并且employee有salary属性。在Department对象中有一个totalSalary属性依赖于所有的employee的salary的关系。<br>这里有两种解决方案：<br>1.你可以使用KVO注册父类（Department）为所有子类（employee）的salary属性的观察者。你必须在添加和移除子类对象的过程中添加和移除观察者。以下为示例代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (context == totalSalaryContext) &#123;</div><div class="line">        [<span class="keyword">self</span> updateTotalSalary];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="comment">// deal with other observations and/or invoke super...</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)updateTotalSalary &#123;</div><div class="line">    [<span class="keyword">self</span> setTotalSalary:[<span class="keyword">self</span> valueForKeyPath:<span class="string">@"employees.@sum.salary"</span>]];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setTotalSalary:(<span class="built_in">NSNumber</span> *)newTotalSalary &#123;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (_totalSalary != newTotalSalary) &#123;</div><div class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"totalSalary"</span>];</div><div class="line">        _totalSalary = newTotalSalary;</div><div class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"totalSalary"</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">NSNumber</span> *)totalSalary &#123;</div><div class="line">    <span class="keyword">return</span> _totalSalary;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.如果你使用Core Data，你可以注册父类为它管理对象上下文的观察者。当子类相关属性值发生改变其父类就会得到相应的通知，类似于KVO。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【转】UIScrollView实践小记——分页]]></title>
      <url>https://iiiceblink.github.io/2016/03/21/UIScrollView%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5/</url>
      <content type="html"><![CDATA[<p><code>UIScrollView</code>是iOS中很有意思也是最常用的控件之一，同时也是为数不多可以响应手势的UIKit控件。本篇文章主要研究的是<code>UIScrollView</code>的分页实现。分页有多种实现方法，且各自的效果和优点各不相同，但它们都依赖于<code>UIScrollView</code>的代理方法，所以，我们先从<code>UIScrollViewDelegate</code>说起。</p>
<h4 id="UIScrollViewDelegate"><a href="#UIScrollViewDelegate" class="headerlink" title="UIScrollViewDelegate"></a>UIScrollViewDelegate</h4><p><code>UIScrollView</code>有意思的功能都是通过它的 <code>delegate</code> 方法实现的。了解这些方法被触发的条件及调用的顺序对于使用 <code>UIScrollView</code> 是很有必要的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
<p>这个方法在任何方式触发 <code>contentOffset</code> 变化的时候都会被调用（包括用户拖动，减速过程，直接通过代码设置等），可以用于监控 <code>contentOffset</code> 的变化，并根据当前的 <code>contentOffset</code> 对其他 view 做出随动调整。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
<p>用户开始拖动 scroll view 的时候被调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset</div></pre></td></tr></table></figure>
<p>该方法从 iOS 5 引入，在 <code>didEndDragging</code> 前被调用，当 <code>willEndDragging</code> 方法中 <code>velocity</code> 为 <code>CGPointZero</code>（结束拖动时两个方向都没有速度）时，<code>didEndDragging</code> 中的 <code>decelerate</code> 为 NO，即没有减速过程，<code>willBeginDecelerating</code> 和 <code>didEndDecelerating</code> 也就不会被调用。反之，当 <code>velocity</code> 不为 <code>CGPointZero</code> 时，scroll view 会以 <code>velocity</code> 为初速度，减速直到 <code>targetContentOffset</code>。值得注意的是，这里的 <code>targetContentOffset</code> 是个指针，没错，你可以改变减速运动的目的地，这在一些效果的实现时十分有用，实例章节中会具体提到它的用法，并和其他实现方式作比较。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate</div></pre></td></tr></table></figure>
<p>在用户结束拖动后被调用，<code>decelerate</code> 为 <code>YES</code> 时，结束拖动后会有减速过程。注，在 <code>didEndDragging</code> 之后，如果有减速过程，<code>scroll view</code> 的 <code>dragging</code>并不会立即置为 NO，而是要等到减速结束之后，<strong><strong>所以这个 dragging 属性的实际语义更接近 scrolling</strong></strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
<p>减速动画开始前被调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
<p>减速动画结束时被调用，这里有一种特殊情况：当一次减速动画尚未结束的时候再次<code>drag scroll view</code>，<code>didEndDecelerating</code> 不会被调用，并且这时 scroll view 的 <code>dragging</code> 和 <code>decelerating</code> 属性都是 YES。新的 dragging 如果有加速度，那么 <code>willBeginDecelerating</code> 会再一次被调用，然后才是 <code>didEndDecelerating</code>；如果没有加速度，虽然 <code>willBeginDecelerating</code> 不会被调用，但前一次留下的 <code>didEndDecelerating</code> 会被调用，所以连续快速滚动一个 <code>scroll view</code> 时，delegate 方法被调用的顺序（不含 didScroll）可能是这样的：</p>
<blockquote>
<p>scrollViewWillBeginDragging:<br>scrollViewWillEndDragging: withVelocity: targetContentOffset:<br>scrollViewDidEndDragging: willDecelerate:<br>scrollViewWillBeginDecelerating:<br>scrollViewWillBeginDragging:<br>scrollViewWillEndDragging: withVelocity: targetContentOffset:<br>scrollViewDidEndDragging: willDecelerate:<br>scrollViewWillBeginDecelerating:<br>…<br>scrollViewWillBeginDragging:<br>scrollViewWillEndDragging: withVelocity: targetContentOffset:<br>scrollViewDidEndDragging: willDecelerate:<br>scrollViewWillBeginDecelerating:<br>scrollViewDidEndDecelerating:  </p>
</blockquote>
<p>虽然很少有因为这个导致的 bug，但是你需要知道这种很常见的用户操作会导致的中间状态。例如你尝试在 <code>UITableViewDataSource</code> 的 <code>tableView:cellForRowAtIndexPath:</code> 方法中基于 tableView 的 dragging 和 decelerating 属性判断是在用户拖拽还是减速过程中的话可能会误判（见例 1）。</p>
<p>了解了<code>UIScrollView</code>的核心代理方法，接下来就来看看<code>UIScrollView</code>的几种分页方式。</p>
<h4 id="pagingEnabled"><a href="#pagingEnabled" class="headerlink" title="pagingEnabled"></a>pagingEnabled</h4><p>这是系统提供的分页方式，最简单，但是有一些局限性：</p>
<blockquote>
<ul>
<li>只能以 frame size 为单位翻页，减速动画阻尼大，减速过程不超过一页</li>
<li>需要一些 hacking 实现 bleeding 和 padding（即页与页之间有 padding，在当前页可以看到前后页的部分内容）</li>
</ul>
</blockquote>
<p>Sample 中 <a href="https://github.com/allenhsu/UIScrollView-Samples/tree/master/Pagination" target="_blank" rel="external">Pagination</a> 有简单实现 bleeding 和 padding 效果的代码，主要的思路是：</p>
<p>让 <code>scroll view</code> 的宽度为 page 宽度 + padding，并且设置 <code>clipsToBounds</code> 为 NO<br>这样虽然能看到前后页的内容，但是无法响应 touch，所以需要另一个覆盖期望的可触摸区域的 view 来实现类似 <code>touch bridging</code> 的功能<br><strong><strong>适用场景：*</strong></strong>上述局限性同时也是这种实现方式的优点，比如一般 App 的引导页（教程），Calendar 里的月视图，都可以用这种方法实现。</p>
<h4 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h4><p>这种方法就是在 <code>didEndDragging</code> 且无减速动画，或在减速动画完成时，snap 到一个整数页。核心算法是通过当前 <code>contentOffset</code> 计算最近的整数页及其对应的 <code>contentOffset</code>，通过动画 snap 到该页。这个方法实现的效果都有个通病，就是最后的 snap 会在 <code>decelerate</code> 结束以后才发生，总感觉很突兀。</p>
<h4 id="修改targetContentOffset"><a href="#修改targetContentOffset" class="headerlink" title="修改targetContentOffset"></a>修改targetContentOffset</h4><p>通过修改 <code>scrollViewWillEndDragging: withVelocity: targetContentOffset:</code> 方法中的 <code>targetContentOffset</code> 直接修改目标 offset 为整数页位置。其中核心代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGPoint</span>)nearestTargetOffsetForOffset:(<span class="built_in">CGPoint</span>)offset</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGFloat</span> pageSize = BUBBLE_DIAMETER + BUBBLE_PADDING;</div><div class="line">    <span class="built_in">NSInteger</span> page = roundf(offset.x / pageSize);</div><div class="line">    <span class="built_in">CGFloat</span> targetX = pageSize * page;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGPointMake</span>(targetX, offset.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGPoint</span> targetOffset = [<span class="keyword">self</span> nearestTargetOffsetForOffset:*targetContentOffset];</div><div class="line">    targetContentOffset-&gt;x = targetOffset.x;</div><div class="line">    targetContentOffset-&gt;y = targetOffset.y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><strong>适用场景：</strong></strong>方法 2 和 方法 3 的原理近似，效果也相近，适用场景也基本相同，但方法 3 的体验会好很多，snap 到整数页的过程很自然，或者说用户完全感知不到 snap 过程的存在。这两种方法的减速过程流畅，适用于一屏有多页，但需要按整数页滑动的场景；也适用于如图表中自动 snap 到整数天的场景；还适用于每页大小不同的情况下 snap 到整数页的场景（不做举例，自行发挥，其实只需要修改计算目标 offset 的方法）。</p>
<p>完整代码参见 <a href="https://github.com/allenhsu/UIScrollView-Samples/tree/master/Pagination" target="_blank" rel="external">Pagination</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac workflow小记]]></title>
      <url>https://iiiceblink.github.io/2016/03/12/Mac%20workflow%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a></h3><p><img src="/images/workflow/homebrew.png" alt=""></p>
<p>Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。<br>homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。<br><a id="more"></a><br><strong>注</strong>：homebrew的安装程序需要用到Xcode的command line tools。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">brew install mysql  // 安装MySQL</div><div class="line">brew uninstall mysql     // 卸载MySQL</div><div class="line">brew search mysql   // 搜索MySQL</div><div class="line">brew upgrade mysql  // 更新MySQL</div><div class="line">brew list   // 显示已经安装的软件列表</div><div class="line">brew update     // 更新homebrew</div><div class="line">brew deps mysql     // 显示MySQL的包依赖</div></pre></td></tr></table></figure>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="http://www.iterm2.com/" target="_blank" rel="external">iTerm2</a></h3><p><img src="/images/workflow/iterm2.png" alt=""></p>
<p>iTerm2是mac下的替代Terminal的终端工具，可以说iTerm2是Mac下最好的终端工具。它有一些特色功能如下：</p>
<p><strong>标签变色</strong><br>iTerm2 的标签的颜色会变化，以指示该 tab 当前的状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。</p>
<p><strong>智能选中</strong><br>在 iTerm2 中，双击选中，三击选中整行，四击智能选中（智能规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。（很多时候双击的选中就已经很智能了）<br>在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。</p>
<p><strong>巧用 Command 键</strong><br>按住⌘键:<br>可以拖拽选中的字符串；<br>点击 url：调用默认浏览器访问该网址；<br>点击文件：调用默认程序打开文件；<br>如果文件名是filename:42，且默认文本编辑器是 Macvim、Textmate或BBEdit，将会直接打开到这一行；<br>点击文件夹：在 finder 中打开该文件夹；<br>同时按住option键，可以以矩形选中，类似于vim中的ctrl v操作。</p>
<p>iTerm2的可定制化也是一大特色，详细的定制化步骤可以参见我的另一篇博客。</p>
<h3 id="Alfred3"><a href="#Alfred3" class="headerlink" title="Alfred3"></a><a href="https://www.alfredapp.com/" target="_blank" rel="external">Alfred3</a></h3><p><img src="/images/workflow/alfred.png" alt=""></p>
<p>我对Alfred3的评价是Mac下最逆天的工具。如果你是个键盘党，Alfred绝对可以让你基本摆脱鼠标。丰富的workflow可以让你的操作变得得心应手而且高效。你可以去<a href="http://www.alfredworkflow.com/" target="_blank" rel="external">alfredworkflow</a>上下载安装适合你的workflow。当然，你要是想自己制作workflow也很容易，简单易上手，这也是Alfred workflow资源丰富的原因所在。如果兜里不差钱还是建议去买个终身会员，绝对值得。如果囊中羞涩，这里提供一个破解版本供大家尝鲜。（<a href="http://bbs.feng.com/read-htm-tid-10516652.html" target="_blank" rel="external">下载链接</a>）</p>
<h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a></h3><p><img src="/images/workflow/dash.png" alt=""></p>
<p>Dash是Mac下的API文档查阅器，其储存了超过150种API离线文档。这可以说是程序员必备利器，不管是从操作体验以及资源的丰富程度都是Mac平台下最好用的。同时，配合Alfred使用，效率会更高。Dash提供免费版也带有付费插件，如果不差钱，支持一下也是无可厚非的。</p>
<h3 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a><a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="external">CheatSheet</a></h3><p><img src="/images/workflow/cheatsheet.png" alt=""></p>
<p>CheatSheet是一款Mac上非常实用的快捷键快速提醒工具，只需要按住Command键，就会弹出当前应用所有的快捷键列表。所以，即使你记不住一些快捷键也没有关系，有CheatSheet就够了。</p>
<h3 id="Sequel-Pro"><a href="#Sequel-Pro" class="headerlink" title="Sequel Pro"></a><a href="http://www.sequelpro.com/" target="_blank" rel="external">Sequel Pro</a></h3><p><img src="/images/workflow/sequelpro.png" alt=""></p>
<p>Sequel Pro（原CocoaMySQL）是众多Mac程序员使用的MySQL管理软件，提供了比phpmyadmin更强大的管理能力，帮助用户轻松编辑数据库，表（字段和索引）和列，执行个性化查找以及导出/入数据，快速查询数据。</p>
<p>Sequel Pro它最大的优点是简单、易用。因为这款工具是苹果公司为了吸引Web开发者进入Mac平台而投资的项目。所以它处处体现了苹果公司简洁的设计哲学。说它是全世界最好用的MySQL数据库管理工具是一点也不夸张。</p>
<p>功能特点：</p>
<blockquote>
<ul>
<li>支持多达30种编码方式</li>
<li>快速导出/导入、备份/还原数据库的SQL/CSV文件</li>
<li>最高版本支持MySQL 5.6</li>
<li>内置强大的数据库查询编辑器，有自定义查询中的自动语句高亮功能，可自定义字体，自定义查询占位符.</li>
<li>允许你编辑数据库，表格（字段和索引）和列，执行个性化查找和导入导出数据</li>
<li>自动补全关键词，表名，域名</li>
<li>自动段落化查询命令</li>
<li>IP直连数据库</li>
<li>表触发机制</li>
<li>服务器运行监控Query Favourites for SQL reuse</li>
<li>包括检索功能在内的全表管理设计</li>
<li>快速在Mac上架设本地MySQL数据库</li>
<li>在MAMP/XAMP架构上连接数据库</li>
<li>SSH连接模式</li>
</ul>
</blockquote>
<h3 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a><a href="http://www.sublimetext.com/3" target="_blank" rel="external">Sublime Text 3</a></h3><p><img src="/images/workflow/sublime.png" alt=""></p>
<p>Sublime Text可以说是一款优雅高效地编辑器，越来越受到开发人员的欢迎。这款编辑器区别于其他编辑器的特性主要有以下几点：</p>
<blockquote>
<ul>
<li>随时保留文件的修改</li>
<li>多重选择，同时修改</li>
<li>智能选择</li>
<li>智能感知，一键注释</li>
<li>Goto Anything，智能搜索</li>
<li>自动完成，无处不在</li>
<li>HTML标签输入</li>
<li>标签输入，再简化</li>
<li>简单全面的插件体系</li>
</ul>
</blockquote>
<h3 id="Lantern"><a href="#Lantern" class="headerlink" title="Lantern"></a><a href="https://www.getlantern.org/" target="_blank" rel="external">Lantern</a></h3><p><img src="/images/workflow/lantern.jpeg" alt=""></p>
<p>Lantern是一款免费开源的科学上网的软件，安装和使用极其简单。Lantern让用户能流畅地访问被封锁的互联网站点。Lantern自动检测一个网站是否被封锁。对那些被封锁的网站，Lantern通过自有的服务器或者未封锁地区的用户运行的Lantern来提供访问。如果网站没有被封锁，Lantern选择靠边站。这样浏览器就会直接访问网站，而速度不受影响。</p>
<h3 id="iStat-Menus"><a href="#iStat-Menus" class="headerlink" title="iStat Menus"></a><a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="external">iStat Menus</a></h3><p><img src="/images/workflow/istatmenus.png" alt=""></p>
<p>iStat Menus 5 是一款由软件开发商 Bjango 制作的 System Monitor（工具，也是笔者电脑里的必装应用之一，它能让用户最快速、最直观地了解到几乎各硬件所有的运行状态，其中包括：CPU 中央处理器、GPU 图形处理器、Memory 虚拟内存、Network 网络、Battery 电池、Disks 硬盘等。</p>
<h3 id="Cmd-Markdown编辑器"><a href="#Cmd-Markdown编辑器" class="headerlink" title="Cmd Markdown编辑器"></a><a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">Cmd Markdown编辑器</a></h3><p><img src="https://www.zybuluo.com/static/img/logo.png" alt=""></p>
<p>Cmd Markdown是一款markdown编辑器，相比于同类markdown编辑器，Cmd Markdown编辑器的优势在于对中文支持比较好，实时的云端文稿，实时同步预览等等。</p>
<p>目前，也就只有这些了，后续如果发现好用的软件会继续更新的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[抽丝剥茧之block（上）]]></title>
      <url>https://iiiceblink.github.io/2016/03/12/%E6%8A%BD%E4%B8%9D%E5%89%A5%E8%8C%A7%E4%B9%8Bblock%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>block在iOS下的应用场景非常广泛，相比于delegate严谨繁琐的语法，block则更加灵活。因而，深入理解block还是很有必要的，以免在开发过程中踩到坑。整个关于block的系列着重点不在于介绍block的定义和使用，而是着眼于block中的关键概念以及难以理解的地方，系列索引在这里：</p>
<p><a href="">抽丝剥茧之block（上）</a></p>
<p><a href="">抽丝剥茧之block（下）</a></p>
<h4 id="问题和结论"><a href="#问题和结论" class="headerlink" title="问题和结论"></a>问题和结论</h4><p>本篇主要的探讨的问题是声明block变量时的修饰符使用<code>strong</code>还是<code>copy</code>？两者是否有区别？</p>
<p>这里先给出结论：在引入ARC之后，在ARC下使用<code>strong</code>和<code>copy</code>对于block而言，不管是实例变量、局部变量还是全局变量都是没有问题的，也可以说这两者几乎没有区别。</p>
<h4 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h4><p>先说是不是，再说为什么，要解释清楚这个问题要从堆和栈讲起。iOS系统中运行代码使用的空间在三个不同的内存区域，分成三个段：“text segment “，“stack segment ”，“heap segment ”。</p>
<blockquote>
<p>栈：<br>在现代操作系统中,一个线程会分配一个stack. 当一个函数被调用,一个stack frame(栈帧)就会被压到stack里。里面包含这个函数涉及的参数,局部变量,返回地址等相关信息。当函数返回后,这个栈帧就会被销毁。而这一切都是自动的,由系统帮我们进行分配与销毁。</p>
<p>堆：<br>提供一个保存中介贯穿函数的执行过程，全局和静态变量保存在“heap”中，直到应用退出。堆,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。 </p>
</blockquote>
<p><img src="/images/blockImages/1.gif" alt=""></p>
<p>stack 对象的优点主要有两点，一是创建速度快，二是管理简单，它有严格的生命周期。stack 对象的缺点是它不灵活。创建时长度是多大就一直是多大，创建时是哪个函数创建的，它的owner 就一直是它。不像heap 对象那样有多个owner ，其实多个owner 等同于引用计数。只有heap 对象才是采用“引用计数”方法管理它。在栈中创建对象，只要栈的剩余空间大于stack 对象申请创建的空间，操作系统就会为程序提供这段内存空间，否则将报异常提示栈溢出。而在堆中创建对象，操作系统对于内存heap 段是采用链表进行管理的。操作系统有一个记录空闲内存地址的链表，当收到程序的申请时，会遍历链表，寻找第一个空间大于所申请的heap 节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。</p>
<p>我们应该知道OC中的对象都分配在堆而不是栈中，其原因是stack对象的生命周期所导致的问题。例如一旦函数返回，则所在的stack frame就会被摧毁。那么此时返回的对象也会一并摧毁。这个时候我们去retain这个对象是无效的。因为整个stack frame都已经被摧毁了。简单而言，就是stack对象的生命周期不适合Objective-C的引用计数内存管理方法。同时，2. stack对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的stack frame。</p>
<h4 id="block存储"><a href="#block存储" class="headerlink" title="block存储"></a>block存储</h4><p>由上文我们了解到iOS中的对象存储在堆上，那block存储在堆还是栈上呢？一般而言，block存储在栈上，这是编译器内部的优化策略，并不会直接对编写的代码产生影响。这样做的好处在于当block创建出来并作为方法的参数传递，方法调用后将其抛弃时，block可以快速的在栈上进行内存分配并且销毁的时候不需要涉及到堆（动态内存池）。</p>
<p>将对象与局部变量做下比较。局部变量在栈中创建出来，当变量所属的方法返回时会自动销毁该变量，并且可以被方法调用者以地址方式传递给被调用方法。当变量的调用方法返回后临时变量的地址不会被存储和使用了，此时该变量已不再存在。</p>
<p>然而，在必要情况下，对象则期望比它们的创建方法生命周期更长，因此，与局部变量不同，对象是在堆上进行分配并且不会被创建方法返回时自动销毁，是否销毁取决于对象是否还被“需要”，“需要”则是由ARC自动管理。</p>
<p>再回到block，在栈上创建block在性能方面有好处但同时也会引起一个问题：如果block的生命周期需要超过它的创建方法，就像对象一样，那么它需要在创建方法的栈销毁之前移动到堆上。<br>在block第一次release时，由于编译器那时候无法自动处理需要移动到堆上的block的生命周期，所以需要开发者手动调用<code>block_copy()</code>方法将block复制到堆上。但是，在OC上层语言层面调用底层方法手动管理编译器中的变量生命周期显示时不合适的（block是<br>C语言结构）。因而，之后苹果发布了新版本的编译器来改善这方面的问题，开发者可以调用<br><code>[block copy]</code>代替<code>block_copy(block)</code>。然后，编译器会自动将block从栈复制到堆上，不过，这点并没有在官方文档中提及。</p>
<p>关于block的修饰符说明，在14年的苹果文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html" target="_blank" rel="external">WorkingwithBlocks</a>中提到block类型的属性应使用<code>copy</code>，但是不多久就被删除了，原文在这里：</p>
<blockquote>
<p>You should specify copy as the property attribute, because a block needs to be copied to keep track of its captured state outside of the original scope. This isn’t something you need to worry about when using Automatic Reference Counting, as it will happen automatically, but it’s best practice for the property attribute to show the resultant behavior.</p>
</blockquote>
<p>内容的大致意思是使用<code>copy</code>修饰block在规范上更推荐，它预示了block会发生的结果行为。实际上，在ARC下不需要我们去关心block的拷贝，ARC会自动完成，因而<code>strong</code>和<code>copy</code>并没有本质上的区别，只是在规范上更倾向于<code>copy</code>而已。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解NSMapTable、NSHashTable、NSPointerArray]]></title>
      <url>https://iiiceblink.github.io/2016/03/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3NSMapTable%E3%80%81NSHashTable%E3%80%81NSPointerArray/</url>
      <content type="html"><![CDATA[<p>最近在学习<code>YYCache</code>中的<code>YYDiskCache</code>时，注意到了这段代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// weak reference for all instances</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSMapTable</span> *_globalInstances;</div><div class="line"><span class="keyword">static</span> dispatch_semaphore_t _globalInstancesLock;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _YYDiskCacheInitGlobal() &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">        _globalInstances = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> YYDiskCache *_YYDiskCacheGetGlobal(<span class="built_in">NSString</span> *path) &#123;</div><div class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    _YYDiskCacheInitGlobal();</div><div class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</div><div class="line">    <span class="keyword">id</span> cache = [_globalInstances objectForKey:path];</div><div class="line">    dispatch_semaphore_signal(_globalInstancesLock);</div><div class="line">    <span class="keyword">return</span> cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</div><div class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    _YYDiskCacheInitGlobal();</div><div class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</div><div class="line">    [_globalInstances setObject:cache forKey:cache.path];</div><div class="line">    dispatch_semaphore_signal(_globalInstancesLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>YYDiskCache</code>采用<code>NSMapTable</code>作为全局变量而并没有采用<code>NSDictionary</code>来存储<code>cache</code>变量，这样做的好处是避免<code>_globalInstances</code>与<code>cache</code>发生循环引用，造成内存无法释放。回顾之前自己的编码经历，基本没考虑过<code>NSDictionary</code>与其元素可能发生的循环引用问题，不得不说自己在这方面还是有欠缺。因而写下这篇blog总结这部分的内容。</p>
<p>我在总结的过程中发现了<code>NSMapTable</code>-<code>NSDictionary</code>、<code>NSHashTable</code>-<code>NSSet</code>、<code>NSPointerArray</code>-<code>NSArray</code>三组存在相似的关系，于是我就想干脆将这几个类总结在一起，便于理解。</p>
<h2 id="NSMapTable-NSDictionary"><a href="#NSMapTable-NSDictionary" class="headerlink" title="NSMapTable - NSDictionary"></a>NSMapTable - NSDictionary</h2><p>以下是苹果文档关于<code>NSMapTable</code>的描述：</p>
<blockquote>
<p>The NSMapTable class is a mutable collection modeled after NSDictionary, with the following differences:</p>
<p>The major option is to have keys and/or values held “weakly” in a manner that entries are removed when one of the objects is reclaimed.</p>
<p>Its keys or values may be copied on input or may use pointer identity for equality and hashing.</p>
<p>It can contain arbitrary pointers (its contents are not constrained to being objects).</p>
</blockquote>
<p>总结一下，<code>NSMapTable</code>仿效的是<code>NSDictionary</code>，但它是可变的集合。它与<code>NSDictionary</code>有几点区别：</p>
<blockquote>
<p>1.<code>NSMapTable</code>与<code>NSDictionary</code>最重要的区别在于前者可以将keys和values以弱引用的方式关联，当其中任一对象被回收了，其所有的内容都会被移除。我们可以通过<code>mapTableWithKeyOptions:valueOptions:</code>分别控制键和值的对象获取/保留行为。<code>NSDictionary</code>则会对keys和values执行retain操作，只有等到<code>NSDictionary</code>被release才会release它所持有的keys和values。</p>
<ol>
<li><code>NSMapTable</code>可以包含任意的指针并且指针的内容不限定必须是对象，然后用指针去做相等或者hasing检查，而<code>NSDictionary</code>的key必须是遵循<code>NSCopying</code>协议的对象。不仅如此，如果<code>NSDictionary</code>要使用KVC那么key必须是字符串。</li>
<li>当<code>NSMapTable</code>指定为<code>NSMapTableCopyIn</code>，它会通过NSCopying协议将添加进来的数据复制一份副本，<code>NSDictionary</code>则需要调用<code>copy</code>方法来复制数据。</li>
</ol>
</blockquote>
<h2 id="NSHashTable-NSSet"><a href="#NSHashTable-NSSet" class="headerlink" title="NSHashTable - NSSet"></a>NSHashTable - NSSet</h2><p>以下是苹果文档关于<code>NSHashTable</code>的描述：</p>
<blockquote>
<p>NSHashTable is modeled after NSSet but provides different options, in particular to support weak relationships.</p>
<p>It can hold weak references to its members.</p>
<p>Its members may be copied on input or may use pointer identity for equality and hashing.</p>
<p>It can contain arbitrary pointers (its members are not constrained to being objects).</p>
<p>Because of its options, NSHashTable is not a set because it can behave differently (for example, if pointer equality is specified two isEqual: strings will both be entered).</p>
</blockquote>
<p>总结一下，<code>NSHashTable</code>效仿的是<code>NSSet</code>但提供更多不同的选项，尤其是支持weak关联。它支持对所有成员的弱引用，而<code>NSSet</code>对所有成员均是强引用。其他的不同点与前面<code>NSMapTable</code>与<code>NSDictionary</code>类似，可以参考对比，就不再码废话了。</p>
<h2 id="NSPointerArray-NSArray"><a href="#NSPointerArray-NSArray" class="headerlink" title="NSPointerArray - NSArray"></a>NSPointerArray - NSArray</h2><p>以下是苹果文档关于<code>NSPointerArray</code>的描述：</p>
<blockquote>
<p>The NSPointerArray class represents a mutable collection modeled after NSArray, but can also hold nil values. nil values may be inserted or removed and contribute to the object’s count. An NSPointerArray object can also increase and decrease its count directly.</p>
<p>A pointer array can be initialized to maintain strong or weak references to objects, or according to any of the memory or personality options defined by NSPointerFunctionsOptions.</p>
<p>The NSCopying and NSCoding protocols are applicable only when a pointer array is initialized to maintain strong or weak references to objects.</p>
<p>When enumerating a pointer array with NSFastEnumeration using for…in, the loop will yield any nil values present in the array. See Fast Enumeration Makes It Easy to Enumerate a Collection in Programming with Objective-C for more information.</p>
</blockquote>
<p>总结一下，<code>NSPointerArray</code>效仿的是<code>NSArray</code>，但可以存储值为<code>nil</code>的元素。<code>nil</code>可以被插入和移除并且计入对象的数目中。而<code>NSArray</code>不可以存储<code>nil</code>，通常它会将<code>nil</code>看做数组的终止符，并且不会计入到对象的数目当中。<code>NSPointerArray</code>可以直接增加或减少元素的数量，与<code>NSMutableArray</code>类似。<code>NSPointerArray</code>最重要的特性与前面两组相同，均是可以对存储的对象采用弱引用。只有当<code>NSPointerArray</code>存储的是对象时<code>NSCopying</code>、<code>NSCoding</code>协议才会适用。还有一点要注意的，在快速遍历的for…in方法中，如果<code>NSPointerArray</code>存在nil则循环遍历会终止。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>依据这三组类的不同也就归纳出它们各自的应用场景。若你的使用场景中可能会产生如实例代码中的循环引用问题，那就使用前者，若你的使用场景中存储的对象不遵循<code>NSCopying</code>协议或者就不是对象，而是指针之类，那就使用前者。其他大多数情况下还是使用后者。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[YYCache源码学习]]></title>
      <url>https://iiiceblink.github.io/2016/03/06/YYCache%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看<a href="http://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="external">YYCache 设计思路</a>。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。</p>
<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>YYCache文件数并不多，主要包含四个文件：</p>
<blockquote>
<ul>
<li>YYCache</li>
<li>YYDiskCache  </li>
<li>YYMemoryCache</li>
<li>YYKVStorage</li>
</ul>
</blockquote>
<a id="more"></a>
<p>他们之间的关系可以用一张图来描述：<br><img src="/images/YYCacheImage/codeArchitecture.png" alt=""></p>
<p><code>YYCache</code>是整个缓存框架的核心类，它是由<code>YYDiskCache</code>和<code>YYMemeoryCache</code>组成，而<code>YYDiskCache</code>需要借助<code>YYKVStorage</code>来实现对元素的读写。以下就依次对每个类进行详细的剖析，我觉得由下向上的去看代码理解起来会更方便，于是剖析的顺序依次是<code>YYKVStorage</code>、<code>YYDiskCache</code>、<code>YYMemeoryCache</code>、<code>YYCache</code>。</p>
<h2 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h2><p><code>YYKVStorage</code>文件中包含两个类<code>YYKVStorageItem</code>和<code>YYKVStorage</code>，前者的作用是为后者提供存储键值对和元数据服务的。前者将每一个储存的数据包装成一个元素，是静态的，后者则是对前者的元素进行读写操作，是动态的。做个比喻，<code>YYKVStorageItem</code>就好比是仓库里的货物，而<code>YYKVStorage</code>则是仓库管理员。不过，该类并非是线程安全的，所以，需要确保该类同一时间只能由一个<code>YYKVStorage</code>对象去访问某个<code>YYKVStorageItem</code>元素。<br><code>YYKVStorageItem</code>的结构很简单：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">///&lt; key</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">///&lt; value</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">///&lt; filename (nil if inline)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> size;                             <span class="comment">///&lt; value's size in bytes</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> modTime;                          <span class="comment">///&lt; modification unix timestamp</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> accessTime;                       <span class="comment">///&lt; last access unix timestamp</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">///&lt; extended data (nil if no extended data)</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>key：唯一标示元素的标识符<br>value：存储的二进制数据<br>filename：存储数据文件的文件名<br>size：限定存储数据的大小<br>modTime：最后一次修改数据的时间戳<br>accessTime：最后一次读取数据的时间戳<br>extendedData：附加的数据</p>
<p><code>YYKVStorage</code>类的结构如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorage</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="meta">#pragma mark - Attribute</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;        <span class="comment">///&lt; The path of this storage.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYKVStorageType type;  <span class="comment">///&lt; The type of this storage.</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> errorLogsEnabled;           <span class="comment">///&lt; Set `YES` to enable error logs for debug.</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>path：存储的路径<br>type：存储类型<br>errorLogsEnabled：debug下是否打印错误信息<br>注：由于写入速度方面sqlite比文件速度快，但是读取速度方面的性能则取决于数据的大小。在作者的测试当中，当数据大于20KB时，读取速度上文件要快于sqlite。为了从性能方面考虑，加入了<code>YYKVStorageType</code>枚举类型。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">/// The `value` is stored as a file in file system.</span></div><div class="line">    YYKVStorageTypeFile = <span class="number">0</span>,</div><div class="line">    </div><div class="line">    <span class="comment">/// The `value` is stored in sqlite with blob type.</span></div><div class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">/// The `value` is stored in file system or sqlite based on your choice.</span></div><div class="line">    YYKVStorageTypeMixed = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果是要存储大量的小数据，用<code>YYKVStorageTypeSQLite</code>性能会更好，如果是要存储大文件（比如图片缓存），使用YYKVStorageTypeFile来获取更好的性能，当然也可以使用<code>YYKVStorageTypeMixed</code>来自己决定每一个item的存储方式。</p>
<p><code>YYKVStorage</code>实现文件依据它的思路分为两部分：sqlite和文件，它们的存储结构如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> File:</div><div class="line"> /path/</div><div class="line">      /manifest.sqlite</div><div class="line">      /manifest.sqlite-shm</div><div class="line">      /manifest.sqlite-wal</div><div class="line">      /data/</div><div class="line">           /e10adc3949ba59abbe56e057f20f883e</div><div class="line">           /e10adc3949ba59abbe56e057f20f883e</div><div class="line">      /trash/</div><div class="line">            /unused_file_or_folder</div><div class="line"> </div><div class="line"> SQL:</div><div class="line"> create table if not exists manifest (</div><div class="line">    key                 text,</div><div class="line">    filename            text,</div><div class="line">    size                integer,</div><div class="line">    inline_data         blob,</div><div class="line">    modification_time   integer,</div><div class="line">    last_access_time    integer,</div><div class="line">    extended_data       blob,</div><div class="line">    primary key(key)</div><div class="line"> ); </div><div class="line"> create index if not exists last_access_time_idx on manifest(last_access_time);</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>File和SQL共用一张manifest表，如果是用SQL方式存储数据，则manifest表中的<code>filename</code>字段为空。这样设计的好处是，查询和修改item的信息只要查询一张表，效率上会高一点。</p>
<p>注：manifest.sqlite-shm和manifest.sqlite-wal是自sqlite 3.7后加入的，-wal文件的意思是write-ahead log，当一个数据库采用WAL模式，所有连接数据的操作都必须使用WAL，然后在数据库文件夹下生成后缀为-wal的文件来保存操作日志，-shm则说的是共享内存的问题，有兴趣可以看看下面这段。</p>
<blockquote>
<p>2.2 Write-Ahead Log (WAL) Files</p>
<p>A write-ahead log or WAL file is used in place of a rollback journal when SQLite is operating in WAL mode. As with the rollback journal, the purpose of the WAL file is to implement atomic commit and rollback. The WAL file is always located in the same directory as the database file and has the same name as the database file except with the 4 characters “-wal” appended. The WAL file is created when the first connection to the database is opened and is normally removed when the last connection to the database closes. However, if the last connection does not shutdown cleanly, the WAL file will remain in the filesystem and will be automatically cleaned up the next time the database is opened.</p>
<p>2.3 Shared-Memory Files</p>
<p>When operating in WAL mode, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters “-shm” appended. Shared memory files only exist while running in WAL mode.</p>
<p>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the VFS is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if PRAGMA locking_mode is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</p>
<p>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</p>
</blockquote>
<p>sqlite3部分涉及到sqlite3预编译，它的预编译过程分为以下几步：</p>
<blockquote>
<p>1.通过sqlite3_prepare_v2()创建sqlite3_stmt对象<br>2.通过sqlite3<em>bind</em>*()绑定预编译字段的值<br>3.通过sqlite2_step()执行SQL语句<br>4.通过sqlite3_reset()重置预编译语句，重复步骤2多次<br>5.通过sqlite3_finalize()销毁资源</p>
</blockquote>
<p>sqlite3<em>bind</em>*有多种形式，分别对应不同的类型：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sqlite3_bind_blob(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">int</span> n, <span class="keyword">void</span>(*)(<span class="keyword">void</span>*)); </div><div class="line"><span class="keyword">int</span> sqlite3_bind_double(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">double</span>);</div><div class="line"><span class="keyword">int</span> sqlite3_bind_int(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line"><span class="keyword">int</span> sqlite3_bind_int64(sqlite3_stmt*, <span class="keyword">int</span>, sqlite3_int64);</div><div class="line"><span class="keyword">int</span> sqlite3_bind_null(sqlite3_stmt*, <span class="keyword">int</span>);</div><div class="line"><span class="keyword">int</span> sqlite3_bind_text(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span> n, <span class="keyword">void</span>(*)(<span class="keyword">void</span>*));</div><div class="line"><span class="keyword">int</span> sqlite3_bind_text16(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">int</span>, <span class="keyword">void</span>(*)(<span class="keyword">void</span>*));</div><div class="line"><span class="keyword">int</span> sqlite3_bind_value(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">const</span> sqlite3_value*);</div><div class="line"><span class="keyword">int</span> sqlite3_bind_zeroblob(sqlite3_stmt*, <span class="keyword">int</span>, <span class="keyword">int</span> n);</div></pre></td></tr></table></figure></p>
<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p><code>YYDiskCache</code>是线程安全的底层依赖于SQLite和File系统（类似于NSURLCache的磁盘缓存）来存储键值对的缓存<br><code>YYDiskCache</code>有以下的特性：</p>
<blockquote>
<ul>
<li>使用LRU算法来移除对象</li>
<li>能够被开销、数量和寿命来控制</li>
<li>当没有多余的磁盘空间时它能够自动回收对象</li>
<li>能够自动决定为每个对象决定存储类型（sqlite还是文件）以达到更好的性能</li>
</ul>
</blockquote>
<p><code>YYDiskCache</code>结构如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYDiskCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Attribute</span></div><div class="line"><span class="comment">/** The name of the cache. Default is nil. */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="comment">/** The path of the cache (read-only). */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  如果对象的数据大小超过这个值，那对象就会被当做文件存储起来，否则对象会以sqlite形式存储起来。</div><div class="line">    0意味着所有的对象会被以单独的文件存储起来，NSIntegerMax意味着所有的对象都会以sqlite形式存储。</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  如果这个block不为空，那么这个block会被用来取代NSKeyedArchiver序列化对象。</div><div class="line"> *  你可以使用这个block来支持那些没有实现'NSCoding'协议的对象</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSData</span> *(^customArchiveBlock)(<span class="keyword">id</span> object);</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  反序列化那些没有遵从'NSCoding'协议的对象</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> (^customUnarchiveBlock)(<span class="built_in">NSData</span> *data);</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  当一个对象需要以文件的形式存储起来时，这个block会被触发来以指定的key生成文件名。</div><div class="line">    如果block为空，缓存就使用md5加密的key来作为文件名</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *(^customFileNameBlock)(<span class="built_in">NSString</span> *key);</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Limit</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  缓存所拥有的对象的最大限制</div><div class="line">    默认值为NSIntegMax，这不是一个严格的限制——如果缓存超过了这个限制，一些对象会在后台队列中被回收</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  在缓存开始回收对象前它所能持有的所有代价</div><div class="line">    如果缓存超过这个限制，一些对象会在后台队列中被回收。</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  缓存中对象的生命周期</div><div class="line">    如果对象超过这个限制，它会在后台队列中被回收</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  缓存保有的最小的空余磁盘空间大小</div><div class="line">    如果空余磁盘空间大小小于这个值，缓存会移除部分对象来释放磁盘空间。</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> freeDiskSpaceLimit;</div><div class="line"><span class="comment">/**</span></div><div class="line"> *  缓存有一个内部的timer来检查缓存是否达到它的限制，如果达到限制，便开始回收对象。</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval;</div><div class="line"><span class="comment">/**</span></div><div class="line"> Set `YES` to enable error logs for debug.</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> errorLogsEnabled;</div></pre></td></tr></table></figure></p>
<p><code>YYDiskCache</code>实现部分采用dispatch_semaphore来控制同步的，而并没有采用性能非常好的OSSpinLock自旋锁，研究了一下原因。</p>
<blockquote>
<p>OSSpinLock：得益于不进内核不挂起的方式，OSSpinLock有着优异的性能表现，然而在高并发执行(冲突概率大，竞争激烈)的时候，又或者代码片段比较耗时(比如涉及内核执行文件io、socket、thread等)，就容易引发CPU占有率暴涨的风险，因此更适用于一些简短低耗时的代码片段<br>dispatch_semaphore：GCD用于控制多线程并发的信号量，允许通过wait/signal的信号事件控制并发执行的最大线程数，当最大线程数降级为1的时候则可当作同步锁使用，注意该信号量并不支持递归；性能虽不如OSSpinLock但性能表现也是出乎意料之外的好，也没有OSSpinLock的CPU占有率暴涨的问题，然而原本是用于GCD的多线程并发控制，也是信号量机制。</p>
</blockquote>
<p>对于耗时较大又易冲突的读操作，可以使用dispatch_semaphore，对于性能要求苛刻，可以考虑使用OSSpinLock，但需要确保加锁片段的耗时足够小。由于<code>YYDiskCache</code>锁占用时间会比较长，使用OSSpinLock会造成CPU内存暴涨，相比之下，使用dispatch_semaphore性能上则会好很多。</p>
<h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p><code>YYMemoryCache</code>是一个高效的存储键值对的内存缓存。与NSDictionary相比，keys只被持有而并不进行拷贝, 其API和性能与NSCache接近，所有的方法都是线程安全的。它的特性如下：</p>
<blockquote>
<ul>
<li>YYMemoryCache与NSCache在以下几个方面不同：</li>
<li>它使用LRU算法移除对象；NSCache的回收方法的策略是不确定的。</li>
<li>它可以被开销，数量和生命周期来控制；NSCache的限制是不确定的。</li>
<li>当收到内存警告和进入后台时，它可以自动回收对象。</li>
</ul>
</blockquote>
<p><code>YYMemoryCache</code>使用pthread_mutex来控制同步。读写锁的在锁操作耗时上明显不占优势，读写锁的主要性能优势在于多线程高并发量的场景，这时候锁竞争可能会非常激烈，使用一般的锁这时候并发性能都会明显下降，读写锁对于所有读操作能够把同步放开，进而保持并发性能不受影响。由于内存缓存属于多线程高并发的使用场景，因此使用pthread_mutex会更稳定。</p>
<blockquote>
<p>pthread_mutex：POSIX标准的unix多线程库(pthread)中使用的互斥量，支持递归，需要特别说明的是信号机制pthread_cond_wait()同步方式也是依赖于该互斥量，pthread_cond_wait()本身并不具备同步能力；</p>
</blockquote>
<p><code>YYMemoryCache</code>的实现主要基于双链表，将链表的节点按照时间先后顺序逆序链接，若有节点被访问，则将该节点挪到表头，若插入新节点而缓存已满，则从链表表尾开始删除节点腾出存储空间。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">@package</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></div><div class="line">    <span class="keyword">id</span> _key;</div><div class="line">    <span class="keyword">id</span> _value;</div><div class="line">    <span class="built_in">NSUInteger</span> _cost;</div><div class="line">    <span class="built_in">NSTimeInterval</span> _time;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><code>YYMemoryCache</code>创建一个<code>YYMemoryCacheGetReleaseQueue</code>来release<code>CFMutableDictionaryRef</code>对象，避免阻塞主线程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123;</div><div class="line">    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>YYMemoryCache</code>的实现部分有段代码引起了我的注意：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        [_lru removeNode:node];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码实现的很巧妙，<code>removeObjectForKey:</code>方法执行完之后，<code>node</code>指向的对象的引用计数为0需要被释放，但是由于在<code>dispatch_async</code>方法中的block中调用了<code>[node class];</code>，使得blcok持有<code>node</code>，其指向的对象也就不会释放，而此时只有<code>dispatch_async</code>的block持有<code>node</code>，也就自然<code>node</code>释放的过程发生在<code>dispatch_async</code>指定的线程当中。</p>
<h2 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h2><p><code>YYCache</code>是线程安全的键值对缓存。它使用<code>YYMemoryCache</code>将对象存储在速度快但空间小的内存缓存中，使用<code>YYDiskCache</code>将对象持久化存储在速度慢但空间大的磁盘缓存中。其类结构也很简单：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">/** The name of the cache, readonly. */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="comment">/** The underlying memory cache. see `YYMemoryCache` for more information.*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</div><div class="line"><span class="comment">/** The underlying disk cache. see `YYDiskCache` for more information.*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><code>YYCache</code>没有太复杂的实现细节，主要就是调用<code>YYMemoryCache</code>和<code>YYDiskCache</code>相关方法存储、查找、修改、删除对象。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime对containsString方法的小改进]]></title>
      <url>https://iiiceblink.github.io/2016/02/20/runtime%E5%AF%B9containsString%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%8F%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<p>最近做项目过程中版本适配到iOS 7上出现了一点问题，定位分析了一下发现原来是<code>NSstring</code>的<code>containsString:</code>方法在从中作梗。看了一下文档发现原来<code>containsString:</code>是从iOS 8才加入的，iOS 7 SDK并没有该方法。这个问题解决起来也挺简单的，在iOS 7下可以用如下代码代替<code>containsString:</code>方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> isContained = [aString rangeOfString:bString].location != <span class="built_in">NSNotFound</span></div></pre></td></tr></table></figure>
<p>不过，我觉得要在每一个需要调用<code>containsString:</code>方法写一遍有点麻烦，把适配的代码抽离出来写入一个方法倒是可以，但我还是觉得有点麻烦，毕竟懒癌患者。于是，我想到了用runtime运行时机制动态添加<code>containsString:</code>方法就可以一劳永逸了。<br>实现的原理也很简单，在iOS 7下判断<code>NSString</code>中是否存在<code>containsString:</code>实例方法，若不存在，则动态添加该方法。这样就不用再需要调用<code>containsString:</code>实例方法去判断了。原理很简单，代码也很简单，还是很符合我这个懒癌患者的口味的嘛。<br><a id="more"></a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSString+containsStringCategory.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="meta-string">&lt; 80000</span></span></div><div class="line"></div><div class="line">@interface NSString (containsStringCategory)</div><div class="line"></div><div class="line">- (BOOL)containsString:(NSString *)str;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NSString+containsStringCategory.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"NSString+containsStringCategory.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MIN_REQUIRED <span class="meta-string">&lt; 80000</span></span></div><div class="line"></div><div class="line">@implementation NSString (containsStringCategory)</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        [self zs_modernizeSelector:@selector(containsString:) withSelector:@selector(zs_containsString:)];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)zs_modernizeSelector:(SEL)originSelector withSelector:(SEL)newSelector&#123;</div><div class="line">    if (![NSString instancesRespondToSelector:originSelector]) &#123;</div><div class="line">        Method newMethod = 	class_getInstanceMethod(self, newSelector);</div><div class="line">        class_addMethod(self, originSelector, method_getImplementation(newMethod), method_getTypeEncoding(newMethod));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)zs_containsString:(NSString *)str&#123;</div><div class="line">    return [self rangeOfString:str].location != NSNotFound;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ApplePay线上支付教程]]></title>
      <url>https://iiiceblink.github.io/2016/01/14/ApplePay%E7%BA%BF%E4%B8%8A%E6%94%AF%E4%BB%98%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="第一部分-准备阶段"><a href="#第一部分-准备阶段" class="headerlink" title="第一部分 准备阶段"></a>第一部分 准备阶段</h2><p>1）硬件要求：<br>iPhone6及更新的设备，还有iPad air2和iPad mini3之后的平板，以及apple watch。具体型号（截止2016年2月）：iPhone 6，iPhone 6 Plus，iPhone 6s， iPhone 6s Plus；iPad Air 2，iPad mini 3，iPad mini 4，iPad Pro；还有Apple Watch。</p>
<p>2）系统要求：<br>iPhone或iPad至少要升到iOS 9.2版，手表至少watch OS 2.1。</p>
<p>3）配置支付环境<br>1.进入苹果开发者中心，注册App ID。<br>App ID必须是explicit类型，否则无法使用ApplePay服务。<br><a id="more"></a><br><img src="/images/applePay/1.png" alt=""></p>
<p>2.勾选Apple Pay并点击continue，然后点击“submit”提交。<br><img src="/images/applePay/2.jpeg" alt=""></p>
<p>3.在App IDs中找到刚刚注册成功的App ID，点击edit，对Apple Pay进行配置。<br><img src="/images/applePay/3.png" alt=""></p>
<p>4.创建MerchantID。<br><img src="/images/applePay/4.png" alt=""></p>
<p>5.配置Apple Pay服务，勾选Merchant ID。<br><img src="/images/applePay/5.png" alt=""></p>
<p>6.App ID的apple pay选项变成enable表示配置成功。<br><img src="/images/applePay/6.png" alt=""></p>
<p>7.创建Xcode项目，填入刚注册的BundleID。<br><img src="/images/applePay/7.png" alt=""></p>
<p>8.在项目的target-&gt;Capabilities中，打开Apple Pay，并勾选Merchant ID。<br><img src="/images/applePay/8.png" alt=""></p>
<h2 id="第二部分-代码实现"><a href="#第二部分-代码实现" class="headerlink" title="第二部分 代码实现"></a>第二部分 代码实现</h2><p>项目地址：<a href="https://github.com/ZakariyyaSv/ApplePayDemo" target="_blank" rel="external">https://github.com/ZakariyyaSv/ApplePayDemo</a></p>
<h4 id="一、判断支付环境"><a href="#一、判断支付环境" class="headerlink" title="一、判断支付环境"></a>一、判断支付环境</h4><p>1.导入Passkit框架，加载view。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;PassKit/PassKit.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>2.判断当前设备是否支持Apple Pay以及wallet中是否有符合所支持网络的银行卡。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.判断当前设备是否支持ApplePay</span></div><div class="line"><span class="keyword">if</span> ([PKPaymentAuthorizationViewController canMakePayments]) &#123;</div><div class="line">    <span class="comment">// 2.判断是否添加了银行卡</span></div><div class="line">    <span class="keyword">if</span> ([PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkChinaUnionPay]]) &#123;</div><div class="line">        <span class="comment">// 3.1添加支付按钮，点击跳转去支付</span></div><div class="line">        PKPaymentButton *buyBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeBuy style:PKPaymentButtonStyleBlack];</div><div class="line">        [buyBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buyOnClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">        [<span class="keyword">self</span>.payView addSubview:buyBtn];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 3.2添加设置按钮，点击跳转去wallet绑定银行卡</span></div><div class="line">        PKPaymentButton *setupBtn = [PKPaymentButton buttonWithType:PKPaymentButtonTypeSetUp style:PKPaymentButtonStyleWhiteOutline];</div><div class="line">        [setupBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(jumpToWallet) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">        [<span class="keyword">self</span>.payView addSubview:setupBtn];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The device cannot support ApplePay!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行效果如下图所示：<br><img src="/images/applePay/2_1.png" alt=""></p>
<p>3.若wallet中没有绑定所支持网络的银行卡，则点击按钮跳转到wallet中去绑定银行卡。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)jumpToWallet&#123;</div><div class="line">    PKPassLibrary *walletLibrary = [[PKPassLibrary alloc] init];</div><div class="line">    [walletLibrary openPaymentSetup];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/applePay/2_2.png" alt=""></p>
<p>4.若该设备支持Apple Pay并且有绑定所支持网络的银行卡则发起支付请求。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)buyOnClick&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"start to pay!"</span>);</div><div class="line">    <span class="comment">// 创建支付请求，配置请求信息。</span></div><div class="line">    PKPaymentRequest *payRequest = [[PKPaymentRequest alloc] init];</div><div class="line">    <span class="comment">// 国家代码</span></div><div class="line">    payRequest.countryCode = <span class="string">@"CN"</span>;</div><div class="line">    <span class="comment">// 货币代码</span></div><div class="line">    payRequest.currencyCode = <span class="string">@"CNY"</span>;</div><div class="line">    <span class="comment">// 商家ID</span></div><div class="line">    payRequest.merchantIdentifier = <span class="string">@"merchant.com.zakariyya.fabrunMerchant"</span>;</div><div class="line">    <span class="comment">// 商家的处理方式</span></div><div class="line">    payRequest.merchantCapabilities = PKMerchantCapability3DS;</div><div class="line">    <span class="comment">// 商家支持的网络</span></div><div class="line">    payRequest.supportedNetworks = @[PKPaymentNetworkChinaUnionPay];</div><div class="line">    </div><div class="line">    <span class="comment">// 配置支付订单的详情</span></div><div class="line">    PKPaymentSummaryItem *cameraItem = [PKPaymentSummaryItem summaryItemWithLabel:<span class="string">@"单反相机"</span> amount:[<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:<span class="string">@"5999.0"</span>] type:PKPaymentSummaryItemTypeFinal];</div><div class="line">    PKPaymentSummaryItem *totalItem = [PKPaymentSummaryItem summaryItemWithLabel:<span class="string">@"佳能"</span> amount:[<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:<span class="string">@"5999.0"</span>] type:PKPaymentSummaryItemTypeFinal];</div><div class="line">    payRequest.paymentSummaryItems = @[cameraItem,totalItem];</div><div class="line">    </div><div class="line">    <span class="comment">// 跳转并验证支付权限</span></div><div class="line">    PKPaymentAuthorizationViewController *authViewController = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:payRequest];</div><div class="line">    authViewController.delegate = <span class="keyword">self</span>;</div><div class="line">    [<span class="keyword">self</span> presentViewController:authViewController animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>支付请求配置包括国家代码、货币代码、商家ID、商家的处理方式、商家支持的网络、订单的详情，这几个要素缺一不可。<br>其中，merchantCapabilities是一个枚举值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, PKMerchantCapability) &#123;</div><div class="line">    PKMerchantCapability3DS                                 = <span class="number">1</span>UL &lt;&lt; <span class="number">0</span>,   <span class="comment">// Merchant supports 3DS</span></div><div class="line">    PKMerchantCapabilityEMV                                 = <span class="number">1</span>UL &lt;&lt; <span class="number">1</span>,   <span class="comment">// Merchant supports EMV</span></div><div class="line">    PKMerchantCapabilityCredit <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0)   = <span class="number">1</span>UL &lt;&lt; <span class="number">2</span>,   <span class="comment">// Merchant supports credit</span></div><div class="line">    PKMerchantCapabilityDebit  <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0)   = <span class="number">1</span>UL &lt;&lt; <span class="number">3</span>    <span class="comment">// Merchant supports debit</span></div><div class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE</span>(NA, <span class="number">8</span>_0);</div></pre></td></tr></table></figure></p>
<p>这些枚举值当中PKMerchantCapability3DS是必选项，其他的则是可选项。</p>
<p>supportedNetworks是一个包含常量字符串的数组：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkAmex <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">8</span>_0);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkChinaUnionPay <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">9</span>_2);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkDiscover <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">9</span>_0);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkInterac <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">9</span>_2);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkMasterCard <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">8</span>_0);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkPrivateLabel <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">9</span>_0);</div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> PKPaymentNetworkVisa <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">8</span>_0);</div></pre></td></tr></table></figure></p>
<p>国内一般我们用到的会是中国银联，即PKPaymentNetworkChinaUnionPay，注意：iOS 9.2以后才开始支持银联支付。</p>
<p><img src="/images/applePay/2_3.png" alt=""></p>
<p>5.监听用户授权状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - PKPaymentAuthorizationViewControllerDelegate</span></div><div class="line"><span class="comment">// 用户授权成功后调用此方法</span></div><div class="line">- (<span class="keyword">void</span>)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(<span class="keyword">void</span> (^)(PKPaymentAuthorizationStatus))completion&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 一般在此处，拿到支付信息，发送给服务端处理，处理完毕后，服务器会返回一个状态来告诉客户端是否支付成功，然后由客户端进行处理。</span></div><div class="line">    <span class="built_in">BOOL</span> isSuccess = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">        completion(PKPaymentAuthorizationStatusSuccess);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        completion(PKPaymentAuthorizationStatusFailure);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 用户授权成功或者用户取消授权操作时调用该方法</span></div><div class="line">- (<span class="keyword">void</span>)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Authorization did finished!"</span>);</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><p><img src="/images/applePay/2_4.png" alt="ApplePay支付流程"></p>
<p><img src="/images/applePay/2_5.png" alt="第三方支付解决方案"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIButton之titleLabel、imageView解析]]></title>
      <url>https://iiiceblink.github.io/2015/12/28/UIButton%E4%B9%8BtitleLabel%E3%80%81imageView%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>UIButton</code>是我们开发过程中使用频率很高的控件类。在使用UIButton实现需求时，通常会碰到需要改变<code>UIButton</code>中image和title位置和大小的需求。如果对UIButton中的titleLabel和imageView理解不到位的话，只能是不停地修改参数，不停地调试，陷入恶性循环，既低效又很难正确地去实现。为了解决这个问题，我研究出了两套方案，分别是用<code>imageEdgeInsets</code>、<code>titleEdgeInsets</code>组合的方案以及<code>imageRectContentRet</code>、<code>titleRectContentRect</code>组合的方案。<br><a id="more"></a></p>
<h3 id="titleEdgeInsets、imageEdgeInsets组合"><a href="#titleEdgeInsets、imageEdgeInsets组合" class="headerlink" title="titleEdgeInsets、imageEdgeInsets组合"></a>titleEdgeInsets、imageEdgeInsets组合</h3><p>这个方案是使用的比较多的解决方案，它主要依赖的是两个方法：</p>
<blockquote>
<ul>
<li><code>titleEdgeInsets</code></li>
<li><code>imageEdgeInsets</code></li>
</ul>
</blockquote>
<p>这个方案比较麻烦的地方在于很多人对这两个方法的理解不到位，导致使用的时候设置和显示的效果不一致。<code>UIButton</code>继承自<code>UIControl</code>，它因此也继承了两个属性<code>contentVerticalAlignment</code>和<code>contentHorizontalAlignment</code>。这两个属性是用来排列内部元素的,默认值都是Center，先看下它们的定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentVerticalAlignment</span>) &#123;</div><div class="line">    <span class="built_in">UIControlContentVerticalAlignmentCenter</span>  = <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIControlContentVerticalAlignmentTop</span>     = <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIControlContentVerticalAlignmentBottom</span>  = <span class="number">2</span>,</div><div class="line">    <span class="built_in">UIControlContentVerticalAlignmentFill</span>    = <span class="number">3</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentHorizontalAlignment</span>) &#123;</div><div class="line">    <span class="built_in">UIControlContentHorizontalAlignmentCenter</span> = <span class="number">0</span>,</div><div class="line">    <span class="built_in">UIControlContentHorizontalAlignmentLeft</span>   = <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIControlContentHorizontalAlignmentRight</span>  = <span class="number">2</span>,</div><div class="line">    <span class="built_in">UIControlContentHorizontalAlignmentFill</span>   = <span class="number">3</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>按照4*4的组合分为16种选择结果。为了在计算过程中更方便点，我通常选择<code>UIControlContentVerticalAlignmentTop</code>、<code>UIControlContentHorizontalAlignmentLeft</code>的组合，这样符合我们以左上角作为坐标原点布局的思维。这里要纠正几个误区：第一，<code>edgeinsets</code>只是相对于当前位置的偏移量，并不是指距离UIButton边界的距离；第二，在同时存在图片还有文字的时候，只有UIButton的<code>contentRect</code>的宽度大于image和title的宽度才能正确显示，否则，文字由于无法进行拉伸收缩的原因只能显示…或者图片被压缩；第三、imageView的宽高都能被压缩，titleLabel的宽只能压缩不能拉伸，titleLabel的高只能拉伸不能压缩。</p>
<p>采用left-top方案初始情况下，image和title的位置如下图所示：<br><img src="/images/Btnimages/originRect.png" alt=""></p>
<p>在初始状态下，<code>imageEdgeInsets</code>和<code>titleEdgeInsets</code>均为0，因此在计算偏移量的时候，image的top、left、right、bottom以及title的top、bottom、right均能以button的边界作为参考，而title的left是以image的left为参考的。搞清楚了之后，来做一下image在上，title在下的button：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGFloat</span> imageTop = (button.height-image.height-title.height) / <span class="number">2</span>;</div><div class="line"><span class="built_in">CGFloat</span> titleTop = imageTop+image.height;</div><div class="line"></div><div class="line"><span class="built_in">CGFloat</span> imageLeft = (button.width-image.width) / <span class="number">2</span>;</div><div class="line"><span class="comment">// 这里减了image.width，因为title的left是以image的left为参考</span></div><div class="line"><span class="built_in">CGFloat</span> titleLeft = (button.width-title.widht) / <span class="number">2</span> - image.width;</div><div class="line"></div><div class="line">button.imageEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(imageTop, imageLeft, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">button.titleEdgeInsets = <span class="built_in">UIEdgeInsetsMake</span>(titleTop, titleLeft, <span class="number">0</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>这里还牵扯到一个问题，有人可能会觉得既然有left和top，那就不需要right和bottom了，实际不然。这实际上是涉及到约束的优先级。其定义如下：</p>
<blockquote>
<ul>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; imageView不能被压缩</li>
<li>top-left-bottom-right取负值 &gt; 不能超出button边界 &gt; titleLabel水平方向不能被压缩</li>
<li>titleLabel垂直方向不能被压缩 &gt; 不能超出button边界</li>
</ul>
</blockquote>
<p>若有人运用发现image超出button边界，只需要同时调整<code>contentEdgeInsets</code>即可。</p>
<h3 id="imageRectForContentRect、titleRectForContentRect组合"><a href="#imageRectForContentRect、titleRectForContentRect组合" class="headerlink" title="imageRectForContentRect、titleRectForContentRect组合"></a>imageRectForContentRect、titleRectForContentRect组合</h3><p>第一个方案理解之后确实可以解决问题，不过，我觉得有些麻烦，就想着能不能有更方便的方案。于是，我翻阅文档和资料后，找到了更简单的方案，也就是这第二个方案。</p>
<p>第二个方案涉及到两个方法：</p>
<blockquote>
<ul>
<li>(CGRect)titleRectForContentRect:(CGRect)contentRect</li>
<li>(CGRect)imageRectForContentRect:(CGRect)contentRect</li>
</ul>
</blockquote>
<p>根据文档的解释，这两个方法返回值是矩形区域，区域内则是用来绘制image和title，返回值的参照系都是UIButton。要想自定义image和title在UIButton的位置和大小，只需要继承UIButton，重写这两个方法即可。</p>
<p>相比第一个方案，第二个方案确实方便不少，但是又有一个问题。要是想改变一个UIButton都得继承UIButton重写方法显得太麻烦，实际上并没有达到简便的目的。于是，我想能不能用runtime运行时机制，给UIButton添加两个变量，直接设置就可以修改image和title在UIButton中的rect，这样会方便很多。</p>
<p>先贴上实现代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  UIButton+RectOfImageAndTitle.h</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">RectOfImageAndTitle</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGRect</span> btn_contentRect;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGRect</span> btn_imageRect;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">CGRect</span> btn_titleRect;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  UIButton+RectOfImageAndTitle.m</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"UIButton+RectOfImageAndTitle.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *btn_contentKey = <span class="string">"btn_contentKey"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *btn_imageKey = <span class="string">"btn_imageKey"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *btn_titleKey = <span class="string">"btn_titleKey"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">RectOfImageAndTitle</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)load&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        [<span class="keyword">self</span> exchangeIMPWithOriginSelector:<span class="keyword">@selector</span>(contentRectForBounds:) newSelector:<span class="keyword">@selector</span>(zs_contentRectForBounds:)];</div><div class="line">        [<span class="keyword">self</span> exchangeIMPWithOriginSelector:<span class="keyword">@selector</span>(imageRectForContentRect:) newSelector:<span class="keyword">@selector</span>(zs_imageRectForContentRect:)];</div><div class="line">        [<span class="keyword">self</span> exchangeIMPWithOriginSelector:<span class="keyword">@selector</span>(titleRectForContentRect:) newSelector:<span class="keyword">@selector</span>(zs_titleRectForContentRect:)];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)exchangeIMPWithOriginSelector:(SEL)originSeletor newSelector:(SEL)newSelector&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">UIButton</span> instancesRespondToSelector:originSeletor]) &#123;</div><div class="line">        Method oriMethod = class_getInstanceMethod(<span class="keyword">self</span>, originSeletor);</div><div class="line">        Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, newSelector);</div><div class="line">        method_exchangeImplementations(oriMethod, newMethod);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - getter &amp; setter</span></div><div class="line">- (<span class="keyword">void</span>)setBtn_contentRect:(<span class="built_in">CGRect</span>)btn_contentRect&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;btn_contentKey, [<span class="built_in">NSValue</span> valueWithCGRect:btn_contentRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)btn_contentRect&#123;</div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>, &amp;btn_contentKey)) &#123;</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;btn_contentKey, [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectZero</span>], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;btn_contentKey) <span class="built_in">CGRectValue</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBtn_imageRect:(<span class="built_in">CGRect</span>)btn_imageRect&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;btn_imageKey, [<span class="built_in">NSValue</span> valueWithCGRect:btn_imageRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)btn_imageRect&#123;</div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>, &amp;btn_imageKey)) &#123;</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;btn_imageKey, [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectZero</span>], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, &amp;btn_imageKey) <span class="built_in">CGRectValue</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setBtn_titleRect:(<span class="built_in">CGRect</span>)btn_titleRect&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, btn_titleKey, [<span class="built_in">NSValue</span> valueWithCGRect:btn_titleRect], OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)btn_titleRect&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, btn_titleKey) == <span class="literal">nil</span> ? <span class="built_in">CGRectZero</span> : [objc_getAssociatedObject(<span class="keyword">self</span>, btn_titleKey) <span class="built_in">CGRectValue</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - private method</span></div><div class="line">- (<span class="built_in">CGRect</span>)zs_contentRectForBounds:(<span class="built_in">CGRect</span>)contentRect&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.btn_contentRect, <span class="built_in">CGRectZero</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> zs_contentRectForBounds:<span class="keyword">self</span>.bounds];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.btn_contentRect;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)zs_imageRectForContentRect:(<span class="built_in">CGRect</span>)contentRect&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.btn_imageRect, <span class="built_in">CGRectZero</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> zs_imageRectForContentRect:<span class="keyword">self</span>.bounds];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.btn_imageRect;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CGRect</span>)zs_titleRectForContentRect:(<span class="built_in">CGRect</span>)contentRect&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.btn_titleRect, <span class="built_in">CGRectZero</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> zs_titleRectForContentRect:<span class="keyword">self</span>.bounds];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.btn_titleRect;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>简要说下实现的思路：由于在category中重写<code>imageRectForContentRect</code>、<code>titleRectForContentRect</code>会覆盖原来的方法实现，并且无法使用super关键字，因此重写方法行不通。转而我采用自己实现两个方法并分别与这两个方法的实现进行交换，这样就不会破坏原有方法的实现。此外，动态添加三个实例变量可以直接在实例对象中直接设置来调用<code>imageRectForContentRect</code>、<code>titleRectForContentRect</code>两个方法。</p>
<p>使用的时候导入头文件，再相应的设置一下实例变量就可以达到效果，有没有很方便。</p>
<h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><p>在开发过程中，我们经常会用到UIViewConentMode属性，有些人往往对属性值的意义不太了解，这里贴出一张图让你对此一目了然。</p>
<p><img src="/images/Btnimages/1.jpg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UICollectionView Layout学习笔记]]></title>
      <url>https://iiiceblink.github.io/2015/12/17/UICollectionView%20Layout%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><code>UITableView</code>是<code>UIKit</code>视图类中极其重要的一个，我们与之打交道的频率也是极高的。在UIKit视图类中有一个类与<code>UITableview</code>共享一套API设计，但相比<code>UITableview</code>，该类的视图布局更加灵活复杂。这就是<code>UICollectionView</code>。本篇的着重点也放在<code>UICollectionView</code>灵活强大的视图布局上面。<br><a id="more"></a></p>
<h3 id="UICollectionView结构"><a href="#UICollectionView结构" class="headerlink" title="UICollectionView结构"></a>UICollectionView结构</h3><p>UICollectionView的结构可以分为两部分来看：</p>
<blockquote>
<p>从数据和驱动角度能看到两部分：</p>
<ul>
<li>dataSource：数据源，遵循UICollectionViewDataSource协议，负责向collectionView提供数据以及视图。同时，还负责处理cells、supplementary views的创建和配置工作。</li>
<li>delegate：代理，遵循UICollectionViewDelegate协议，负责管理item视图的选中高亮状态以及item的点击事件。</li>
</ul>
<p>从视图角度能看到三部分：</p>
<ul>
<li>Cells：在collection view的可视范围内负责展示数据的内容</li>
<li>Supplementary views：也是负责展示数据，但与cells不同，它无法被用户选中，类似于UITableview的header和footer</li>
<li>Decoration views：属于装饰性view，不与collectionView的数据产生联系，更像是另一类的Supplementary views。<br>注：Supplementary views、Decoration views必须是UICollectionReusableView的子类。</li>
</ul>
</blockquote>
<p>这些组成结构与<code>UITableview</code>比较，并没有太大的区别，真正的区别在于<code>UICollectionLayout</code>，这不仅是本篇笔记的着重点，也是UICollectionView的精髓。</p>
<h3 id="UICollectionViewLayout"><a href="#UICollectionViewLayout" class="headerlink" title="UICollectionViewLayout"></a>UICollectionViewLayout</h3><p><code>UICollectionViewLayout</code>是一个抽象类，因此我们必须要继承并实现相关方法才能使用它。Layout的工作是确定Cells、supplementary views、decoration views在collectionView的bounds中的位置并且当collectionView需要时传递相关信息。collectionView根据传递过来的相关layout信息对views进行相应和处理以便能让他们在屏幕上能够显示出来。</p>
<p><code>UICollectionViewFlowLayout</code>是苹果提供的继承于<code>UICollectionViewLayout</code>的子类。当你对layout的需求不是很复杂的时候，<code>UICollectionViewFlowLayout</code>往往可以满足需求，并且实现也比较简单，这里就不再讨论，感兴趣的可以查阅相关文档<a href="https://developer.apple.com/reference/uikit/uicollectionviewflowlayout" target="_blank" rel="external">UICollectionviewFlowLayout</a>。</p>
<p>自定义继承<code>UICollectionViewLayout</code>的子类必须重写以下方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareLayout</div><div class="line"><span class="comment">// collectionView会在第一次布局向layout对象发送第一条消息时调用一次该方法，或者在invalidaed方法调用后在访问布局信息之前会再次调用该方法，重写该方法做些初始化的工作以确保layout实例的正确，子类重写必须调用super方法。</span></div><div class="line"></div><div class="line">- (<span class="built_in">CGSize</span>)collectionViewContentSize</div><div class="line"><span class="comment">// 返回collectionView的内容的尺寸。collectionView对它的content并不知情，因此需要提供滚动区域大小才能正确滚动。滚动区域大小必须包含内容的总大小，包括supplementary views 和 decoration views。</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSArray</span> *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect</div><div class="line"> <span class="comment">// 返回rect中的所有的元素的布局属性，其是包含UICollectionViewLayoutAttributes的数组。该方法传递一个自身坐标系的矩形进来，这个矩形也就是collectionView的bounds。这个方法涉及到所有类型的视图，即包括cells、supplementary views和decoration views。</span></div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span>  *)layoutAttributesForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> )indexPath</div><div class="line"><span class="comment">// 返回对应于indexPath的位置的cell的布局属性。有时候collectionView会为某个特殊的视图向layout对象请求布局属性。你可以通过调用 +[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]这个方法，然后根据 index path 修改属性。为了得到需要显示在这个 index path 内的数据，你可能需要访问 collection view 的数据源。到目前为止，至少确保设置了 frame 属性，除非你所有的 cell 都位于彼此上方。</span></div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span>  *)layoutAttributesForSupplementaryViewOfKind:(<span class="built_in">NSString</span> )kind atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line"><span class="comment">// （可选）返回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载</span></div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> * )layoutAttributesForDecorationViewOfKind:(<span class="built_in">NSString</span>)decorationViewKind atIndexPath:(<span class="built_in">NSIndexPath</span> )indexPath</div><div class="line"><span class="comment">// （可选）返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds</div><div class="line"><span class="comment">// 当collectionView的bounds发生改变时，是否应该重新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。</span></div></pre></td></tr></table></figure></p>
<p>这些方法提供了collectionView在屏幕上展示内容所需要的基本布局信息。当collectionView中的数据发生改变并且items需要执行增删操作，collectionView会要求layout对象去更新layout布局信息。任何item被添加、移除、移动都必须更新它的布局信息来对应它正确的位置信息。当item被移动时，collectionView调用上面的方法来重新获取item更新后的布局属性，而item被插入或删除时，collectionView会调用不同的方法，也就是你需要重写的方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)initialLayoutAttributesForAppearingItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)itemIndexPath;</div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)initialLayoutAttributesForAppearingDecorationElementOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPath:(<span class="built_in">NSIndexPath</span> *)decorationIndexPath;</div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)initialLayoutAttributesForAppearingSupplementaryElementOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPath:(<span class="built_in">NSIndexPath</span> *)elementIndexPath;</div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)finalLayoutAttributesForDisappearingItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)itemIndexPath;</div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)finalLayoutAttributesForDisappearingDecorationElementOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPath:(<span class="built_in">NSIndexPath</span> *)decorationIndexPath;</div><div class="line"></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)finalLayoutAttributesForDisappearingSupplementaryElementOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPath:(<span class="built_in">NSIndexPath</span> *)elementIndexPath;</div></pre></td></tr></table></figure></p>
<p>此外，你也可以重写<code>prepareForCollectionViewUpdates:</code>方法来处理任何与布局相关的预处理操作，重写<code>finalizeCollectionViewUpdates</code>方法来添加动画或者实现布局相关的任务。</p>
<h3 id="UICollectionViewLayoutAttributes"><a href="#UICollectionViewLayoutAttributes" class="headerlink" title="UICollectionViewLayoutAttributes"></a>UICollectionViewLayoutAttributes</h3><p>重写的方法中涉及到一个类<code>UICollectionViewLayoutAttributes</code>。该类负责管理collectionView中给定item的布局相关的属性。当collectionView需要时，便会要求layout对象创建该类的实例对象。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UICollectionViewLayoutAttributes</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">UIDynamicItem</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGRect</span> frame;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> center;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> size;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CATransform3D</span> transform3D;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGRect</span> bounds <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGAffineTransform</span> transform <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> alpha;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> zIndex; <span class="comment">// default is 0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isHidden) <span class="built_in">BOOL</span> hidden; <span class="comment">// As an optimization, UICollectionView might not create a view for items whose hidden attribute is YES</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UICollectionElementCategory</span> representedElementCategory;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *representedElementKind; <span class="comment">// nil when representedElementCategory is UICollectionElementCategoryCell</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForCellWithIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForSupplementaryViewOfKind:(<span class="built_in">NSString</span> *)elementKind withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line">+ (<span class="keyword">instancetype</span>)layoutAttributesForDecorationViewOfKind:(<span class="built_in">NSString</span> *)decorationViewKind withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>可以看出，<code>UICollectionViewLayoutAttributes</code>包含了Cell的frame、center、bounds等布局信息。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>相比于<code>UITableview</code>，<code>UICollectionview</code>布局的复杂程度要更复杂得多，能很好的写出一个很不容易。正是由于<code>UICollectionview</code>布局的复杂性，我们更需要多去使用，在使用的过程中才能更好的理解<code>UICollectionview</code>本身这套API，也更好地学习苹果设计类的灵活性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIImage加载图片方式的研究]]></title>
      <url>https://iiiceblink.github.io/2015/10/20/UIImage%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E6%96%B9%E5%BC%8F%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>常用的UIImage加载图片的方式有以下几种：</p>
<ul>
<li><code>[UIImage imageNamed:name]</code></li>
<li><code>[UIImage imageWithContentsOfFile:name]</code></li>
<li><code>[UIImage imageWithData:data]</code></li>
<li><code>[UIImage imageWithCGImage:imageRef]</code></li>
<li><code>[UIImage imageWithCIImage:obj]</code></li>
</ul>
<p>以上方法中<code>imageNamed:</code>和<code>imageWitData:</code>应用程序会对其自动缓存，不过，它们缓存的实现方式并不相同，后面会有详细说明。除去这两个方法以外剩下的三个方法默认情况下是不会产生缓存的，这三个方法的主要区别在于它们的数据源：<code>imageWithContentsOfFile:</code>从指定文件中创建对象，<code>imageWithCGImage:</code>以CGImageRef来创建对象，<code>imageWithCIImage:</code>以CIImage对象来创建对象。<br>最后两种方法平时用的相对会少一些，简要解释一下CGImage与CIImage的区别：CGImageRef只能代表位图，如果你需要与bitmap数据打交道，无疑CGImage是非常合适的选择。CGImageRef以CG开头就不难想到CGImageRef的相关操作都需要在Core Graphics中进行，比如混合、遮罩等等。CIImage以CI开头，即Core Image，不难理解CIImage是底层的数据对象，它通常包含了与它相关的图像数据，而不是一个图像。默认情况下，CIImage对象是不会被绘图系统渲染的，除非是得到明确的指令。这种机制（“lazy evaluation”）允许核心绘图系统尽可能高效地运行。CIImage通常被运用在GPU优化图像滤镜算法当中。<br><a id="more"></a></p>
<h3 id="UIImage缓存原理"><a href="#UIImage缓存原理" class="headerlink" title="UIImage缓存原理"></a>UIImage缓存原理</h3><p>1.<code>[UIImage imageNamed:name]</code><br>我通过查看<code>imageNamed</code>方法的调用栈以及查阅<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/occ/clm/UIImage/imageNamed:" target="_blank" rel="external">苹果相关文档</a>后对UIImage的缓存实现有了清晰的认识。<br>当调用imageNamed方法时，该方法会去内存缓存里去查找与参数一致的image对象并且返回最合适大小的image对象，如果没有找到，该方法则会去本地磁盘中查找然后加载图片并返回image对象，同时将image对象缓存到系统缓存中，以便下次重复使用。更底层一点的解释，当返回image对象时，并未对image的图片数据进行解码。它的解码过程发生在UIImage对象第一次显示到屏幕上的时候，而image对象的缓存也发生在这时候。当解码完成image显示在屏幕上后，应用程序会将image的解码结果保存到缓存中。通常缓存会在收到内存警告时才会被清空。</p>
<p>2.<code>[UIImage imageWithData:data]</code><br>在查看imageWithData方法的调用栈时发现了有意思的东西。通过二进制数据创建image对象时，实际上在底层调用的是<code>ImageIO/ImageIO.h</code>的<code>CGImageSourceCreateWithData()</code>方法。该方法的第二个参数可以传入key为kCGImageSourceShouldCache的键值对，它的值是CFBooleanRef类型的，默认情况下，在64位机器上它的值为kCFBooleanTrue，而在32位机器上它的值为kCFBooleanFalse。也就是说在64位机器上是会缓存的，而在32位机器上则是不会缓存的。与<code>imageNamed</code>方法类似，图片会在第一次显示到屏幕上时才会进行解码，随后再被缓存到CGImage里面。依据是<code>CGImageSourceCreateWithData()</code>方法第二个参数可以传入key为kCGImageSourceShouldCacheImmediately的键值对，默认情况下它的值是kCFBooleanFalse。</p>
<h3 id="UIImage不缓存"><a href="#UIImage不缓存" class="headerlink" title="UIImage不缓存"></a>UIImage不缓存</h3><ul>
<li><code>[UIImage imageWithContentsOfFile:name]</code><br>与前面两个方法略有不同，该方法是同步的（synchronous）。当在主线程（UI）中调用该方法时，会阻塞主线程并从磁盘中加载图片数据，若磁盘数据较大会造成卡顿或者延迟。通常的解决方法是另开一个线程异步完成磁盘加载图片数据的任务，然后在主线程中刷新UI。下面代码给出了一个例子：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [<span class="keyword">self</span>.button setBackgroundImage:image forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当图片显示在屏幕上时，系统并不会对其进行缓存。当图片数据被加载到内存中，它会被标记为可清除（purgeable）。如果数据被清除了且需要再次加载，image对象会再次从指定的文件路径获取数据并加载进内存中。根据它的实现原理，通常该方法的使用场景是图片不需要重复展示，或者图片的数据较大会造成内存警告。当然，这并不是说<code>imageWithContentsOfFile:</code>一定比<code>imageNamed:</code>方法高效，<code>imageWithContentsOfFile:</code>方法的问题在于它会将图片文件全尺寸展示在屏幕上即使是512*512的图片都要占到1M多的内存，加载会影响程序的性能，造成不好的用户体验。<br>针对图片尺寸太大带来的性能问题，比较好的解决方案是用<code>CGImageSource</code>的有关方法，将图片的尺寸缩减到适合的尺寸，减小数据大小。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;ImageIO/ImageIO.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *imageFileURL = [<span class="built_in">NSURL</span> fileURLWithPath:...];</div><div class="line"><span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((<span class="built_in">CFURLRef</span>)imageFileURL, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span> (imageSource == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">// Error loading image</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSDictionary</span> *options = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                         [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">NO</span>], (<span class="built_in">NSString</span> *)kCGImageSourceShouldCache,</div><div class="line">                         <span class="literal">nil</span>];</div><div class="line"><span class="built_in">CFDictionaryRef</span> imageProperties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, (<span class="built_in">CFDictionaryRef</span>)options);</div><div class="line"><span class="keyword">if</span> (imageProperties) &#123;</div><div class="line">    <span class="built_in">NSNumber</span> *width = (<span class="built_in">NSNumber</span> *)<span class="built_in">CFDictionaryGetValue</span>(imageProperties, kCGImagePropertyPixelWidth);</div><div class="line">    <span class="built_in">NSNumber</span> *height = (<span class="built_in">NSNumber</span> *)<span class="built_in">CFDictionaryGetValue</span>(imageProperties, kCGImagePropertyPixelHeight);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Image dimensions: %@ x %@ px"</span>, width, height);</div><div class="line">    <span class="built_in">CFRelease</span>(imageProperties);</div><div class="line">&#125;</div><div class="line"><span class="built_in">CFRelease</span>(imageSource);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode-Target、Project、WorkSpace、Scheme]]></title>
      <url>https://iiiceblink.github.io/2015/10/18/Xcode-Target%E3%80%81Project%E3%80%81WorkSpace%E3%80%81Scheme/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发iOS有一段时间了，Xcode用得也越发熟练，但对于Xcode中的一些常用项目结构的概念如<code>Target</code>、<code>Project</code>等却还是一知半解。故将其摘出来搞清楚，避免以后犯概念性错误。</p>
<a id="more"></a>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>一个<code>Target</code>对应一个编译的product并且包含将<code>Project</code>或<code>workspace</code>中的文件编译成product的指令。<code>Project</code>可以包含一个或多个<code>Target</code>，而每个<code>Target</code>对应一个product。</p>
<p>编译product的指令包含了<code>Build Settings</code>和<code>Build Phases</code>，我们可以在Xcode的编辑器中进行编辑和修改。<code>Target</code>继承了project中的<code>Build Settings</code>中的所有设置，我们也可以在<code>Target</code>中自行修改<code>Project</code>中的设定。同一时间只能有一个活动的<code>Target</code>，Xcode中通过schema来指定这个<code>Target</code>。</p>
<p><img src="/images/XcodeFileStructures/1.png" alt=""></p>
<p><code>Target</code>和它所创建的product可以与另一个<code>Target</code>相关联。如果一个<code>Target</code>需要另一个<code>Target</code>的输出来完成编译，那就可以说第一个<code>Target</code>依赖于第二个<code>Target</code>。如果两个<code>Target</code>处在同一个<code>WorkSpace</code>中，那么当Xcode编译是，便可以发现它们之间的依赖关系。这种关系也可称为隐式依赖。当然，我们也可以在<code>Build Settings</code>中指定显式依赖关系，Xcode中存在显式依赖关系的两个<code>Target</code>实际上并没有依赖。例如，在同一个<code>WorkSpace</code>中，你可以编译一个类库和一个应用并将那个类库链接进来。Xcode可以发现它们的关系并自动先编译那个类库。然而，如果你只是想链接这个类库的某一个版本而不是<code>WorkSpace</code>中编译的那个，你可以在<code>Build Settings</code>在创建显式依赖并覆盖隐式依赖。</p>
<h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>Xcode的<code>Project</code>是编译一个或多个软件产品不可或缺的所有文件、资源和信息的存储库。一个<code>Project</code>包含用来编译产品的所有元素和保存元素之间的关联信息。一个<code>Project</code>包含一个或多个<code>Target</code>，<code>Project</code>指定了项目中所有<code>Target</code>默认的编译设置。</p>
<p>一个Xcode Project包含以下信息：</p>
<blockquote>
<ul>
<li>源文件的索引：<blockquote>
<ul>
<li>源代码，包含头文件和实现文件</li>
<li>类库和框架，内部的和外部的</li>
<li>资源文件</li>
<li>图像文件</li>
<li>xib、storyboard文件</li>
</ul>
</blockquote>
</li>
<li>用来组织在结构导航中的源文件的组</li>
<li>项目级编译配置。你可以指定<code>Project</code>不止一种编译配置，例如，你可以设定<code>Project</code>有debug和release两种配置。</li>
<li>Targets，其中包含：<blockquote>
<ul>
<li>项目编译生成的product的索引</li>
<li>编译product所需要的源文件的索引</li>
<li>用来编译项目的编译配置，包含对其他<code>Target</code>的依赖和其他设置；项目级编译设定只会在<code>Target</code>编译配置没有重设时才会应用。</li>
</ul>
</blockquote>
</li>
<li>用于debug和测试项目的可执行环境</li>
</ul>
</blockquote>
<p>一个<code>Project</code>可以独立存在或者包含在<code>WorkSpace</code>中。你可以使用<code>Scheme</code>来给定模式下哪个<code>Target</code>、编译配置和可执行环境配置处于活跃状态。</p>
<h3 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h3><p><code>WorkSpace</code>是Xcode将<code>project</code>和其他文档组合在一起的文档，以便可以让它们协同工作。<code>WorkSpace</code>可以包含任何数目的<code>project</code>，可以添加任何你想引入的文件。此外，为了在每个Xcode项目中组织所有的文件，<code>WorkSpace</code>在<code>project</code>和它们的<code>Target</code>之间提供了显式和隐式关系。</p>
<p>此外，<code>WorkSpace</code>扩展了很多重要的Xcode工作流的范围。例如，因为索引贯穿整个的<code>WorkSpace</code>，因此代码提示、跳到定义和所有其他内容上的特性在整个<code>WorkSpace</code>中无缝使用。因为重构操作贯穿整个<code>WorkSpace</code>的内容中，你可以重构项目中框架的API并让所有使用该框架的项目都只需执行一次重构操作。当编译时，一个项目可以使用<code>WorkSpace</code>中其他<code>project</code>的product。</p>
<p><code>WorkSpace</code>文档包含指向包含的项目和其他文件的指针，而没有其他数据。一个<code>Project</code>可以属于不止一个<code>WorkSpace</code>。</p>
<p>默认情况下，在<code>WorkSpace</code>中的所有Xcode项目编译在同一个目录下。每个<code>WorkSpace</code>都有自己的编译目录。因为在同一个<code>WorkSpace</code>中的所有项目的所有文件在相同的编译目录下，所以所有这些文件对于每个项目都是可见的。因而，如果两个或者更多的<code>project</code>使用同一个类库，你不需要单独在每个项目中都拷贝一份。</p>
<p>在<code>WorkSpace</code>中的<code>project</code>都可以继续保有自己独立的实体。如果不想被其他项目影响或者不想影响别的项目，我们可以不在<code>WorkSpace</code>中打开<code>project</code>，或者也可以将<code>project</code>添加到别的<code>WorkSpace</code>中。</p>
<h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><p><code>scheme</code>定义编译的<code>Target</code>的集合，编译时使用的配置以及测试的集合。</p>
<p>你可以有很多的<code>scheme</code>，只要你想要，但是在同一时间只能有一个是活跃状态。你可以指定一个<code>scheme</code>是否应该保存在项目中。当你指定一个活跃的<code>scheme</code>，你还可以选择运行目标。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UINavigationBar背景色设置]]></title>
      <url>https://iiiceblink.github.io/2015/09/24/UINavigationBar%E8%83%8C%E6%99%AF%E8%89%B2%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近关于<code>UINavigationBar</code>背景色随tableView滚动而渐变的风格很流行，自己也想着研究去实现它，并决定把研究的结果写进这篇文章中。渐变的实现很简单，思路无非是监听tableView的<code>contentOffset</code>属性，在<code>scrollViewDidScroll</code>方法中更新navigationbar背景色的alpha值，我们的重点放在设置navigationbar背景色上。</p>
<a id="more"></a>
<p><img src="/images/navigationbarColor/TBNavigationbar.mov" alt=""></p>
<h3 id="关于translucent属性"><a href="#关于translucent属性" class="headerlink" title="关于translucent属性"></a>关于translucent属性</h3><p>在iOS 7后<code>translucent</code>属性默认为YES，如果你给navigtionbar设置自定义的背景图片，若该图片的alpha值小于1，那么显示时会使用图片本身的alpha值，若该图片不透明，显示时则会应用系统设置的透明度到图片上。如果设置<code>translucent</code>为NO，那么背景图片显示将会正常。</p>
<p>上面是苹果官方文档对于<code>translucent</code>属性的解释，我通过Reveal查看并在控制台打印两种情况下<code>UINavigationbar</code>的视图结构，结果也印证了文档中的说明。</p>
<h5 id="translucent为NO"><a href="#translucent为NO" class="headerlink" title="translucent为NO"></a>translucent为NO</h5><p><img src="/images/navigationbarColor/1.png" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;UINavigationBar: 0x7fe045a02530; frame = (0 20; 375 44); autoresize = W; gestureRecognizers = &lt;NSArray: 0x608000049ae0&gt;; layer = &lt;CALayer: 0x61000003e120&gt;&gt;</div><div class="line"> | &lt;_UIBarBackground: 0x7fe042405e20; frame = (0 -20; 375 64); userInteractionEnabled = NO; layer = &lt;CALayer: 0x61000003e000&gt;&gt;</div><div class="line"> |    | &lt;UIImageView: 0x7fe0424061c0; frame = (0 64; 375 0.5); userInteractionEnabled = NO; layer = &lt;CALayer: 0x61000003fba0&gt;&gt;</div><div class="line"> | &lt;&lt;UINavigationItemView: 0x7fe045809b00; frame = (170 8; 35 27); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x61800003d6a0&gt;&gt;: item=&lt;&lt;UINavigationItem: 0x6100001c78f0&gt;: title:'标题'&gt; title=标题&gt;</div><div class="line"> |    | &lt;UILabel: 0x7fe04580a110; frame = (0 3.5; 35 21.5); text = '标题'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x61800009bc60&gt;&gt;</div><div class="line"> |    |    | &lt;_UILabelContentLayer: 0x60800003db80&gt; (layer)</div><div class="line"> | &lt;_UINavigationBarBackIndicatorView: 0x7fe042507680; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60800003dfa0&gt;&gt;</div></pre></td></tr></table></figure>
<p>从视图结构可以看出，<code>UINavigationbar</code>主要由<code>_UIBarBackground</code>、<code>UINavigationItemView</code>、<code>_UINavigationBarBackIndicatorView</code>三部分组成，很简单。</p>
<h5 id="translucent为YES"><a href="#translucent为YES" class="headerlink" title="translucent为YES"></a>translucent为YES</h5><p><img src="/images/navigationbarColor/2.png" alt=""></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;UINavigationBar: 0x7fcc06e07280; frame = (0 20; 375 44); opaque = NO; autoresize = W; gestureRecognizers = &lt;NSArray: 0x610000044710&gt;; layer = &lt;CALayer: 0x61800002e560&gt;&gt;</div><div class="line">   | &lt;_UIBarBackground: 0x7fcc06d01980; frame = (0 -20; 375 64); userInteractionEnabled = NO; layer = &lt;CALayer: 0x6080000303c0&gt;&gt;</div><div class="line">   |    | &lt;UIImageView: 0x7fcc06d03920; frame = (0 64; 375 0.5); userInteractionEnabled = NO; layer = &lt;CALayer: 0x6080000308c0&gt;&gt;</div><div class="line">   |    | &lt;UIVisualEffectView: 0x7fcc06d09e60; frame = (0 0; 375 64); layer = &lt;CALayer: 0x608000030980&gt;&gt;</div><div class="line">   |    |    | &lt;_UIVisualEffectBackdropView: 0x7fcc08901a90; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;UICABackdropLayer: 0x61000002fac0&gt;&gt;</div><div class="line">   |    |    | &lt;_UIVisualEffectFilterView: 0x7fcc06d09490; frame = (0 0; 375 64); autoresize = W+H; userInteractionEnabled = NO; layer = &lt;CALayer: 0x608000030c40&gt;&gt;</div><div class="line">   | &lt;&lt;UINavigationItemView: 0x7fcc08e007f0; frame = (170 8; 35 27); opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x61800002e740&gt;&gt;: item=&lt;&lt;UINavigationItem: 0x6180001c1fe0&gt;: title:'标题'&gt; title=标题&gt;</div><div class="line">   |    | &lt;UILabel: 0x7fcc08e00d30; frame = (0 3.5; 35 21.5); text = '标题'; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x618000095f40&gt;&gt;</div><div class="line">   |    |    | &lt;_UILabelContentLayer: 0x61800002fb80&gt; (layer)</div><div class="line">   | &lt;_UINavigationBarBackIndicatorView: 0x7fcc06c05f30; frame = (8 11.5; 13 21); alpha = 0; opaque = NO; userInteractionEnabled = NO; layer = &lt;CALayer: 0x60000002e780&gt;&gt;</div></pre></td></tr></table></figure>
<p>相比于<code>trasulent</code>为NO时，<code>UINavigationbar</code>在<code>_UIBarBackground</code>中多了一层<code>UIVisualEffectView</code>。我们都知道<code>UIVisualEffectView</code>类是给背景图层提供虚化效果的，这也解释了文档中对于<code>trasulent</code>为YES时的说明。</p>
<h3 id="设置navigationbar背景色问题"><a href="#设置navigationbar背景色问题" class="headerlink" title="设置navigationbar背景色问题"></a>设置navigationbar背景色问题</h3><p>通常要设置navigationbar背景颜色，我们会调用<code>[self.navigationController.navigationBar setBackgroundColor:[UIColor redColor]];</code>方法。运行看看，效果好像跟预想的不太一样。</p>
<h5 id="transulent-YES"><a href="#transulent-YES" class="headerlink" title="transulent=YES"></a>transulent=YES</h5><p><img src="/images/navigationbarColor/3.png" alt=""></p>
<h5 id="transulent-NO"><a href="#transulent-NO" class="headerlink" title="transulent=NO"></a>transulent=NO</h5><p><img src="/images/navigationbarColor/4.png" alt=""></p>
<p>在transulent=YES时，还能看见一点红色，而在transulent=NO时，则完全没效果。这是为嘛呢？回头看看前面<code>UINavigationbar</code>视图结构，你也许就有答案了。</p>
<p><img src="/images/navigationbarColor/5.png" alt=""></p>
<p>从上图可以看到，<code>UINavigationBar</code>实际上被前面的<code>_UIBarBackground</code>挡住了，故而没有效果。</p>
<h3 id="设置navigationbar背景色解决方案"><a href="#设置navigationbar背景色解决方案" class="headerlink" title="设置navigationbar背景色解决方案"></a>设置navigationbar背景色解决方案</h3><p>既然找到了问题的缘由，自然也就有对应的解决方案。我这里只提供两种解决方法，实际上解决方法不止两种，而我选择这两种解决方法是因为一种很便利，一种可扩展性强，基本上这两种解决办法可以满足我们大部分的需求。</p>
<p>先说第一种便利的解决办法。既然<code>_UIBarBackground</code>对象挡住了navigationbar，那就设置<code>_UIBarBackground</code>对象的backgroundColor。由于API中并没有提供关于<code>_UIBarBackground</code>对象，我们只能通过KVC的方式，通过断点调试我们发现<code>UINavigationbar</code>的成员变量如下：</p>
<p><img src="/images/navigationbarColor/6.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationBar</span> (<span class="title">ZS_BackgroundColor</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setZS_BackgroundColor:(<span class="built_in">UIColor</span> *)color&#123;</div><div class="line">    <span class="built_in">UIView</span> *originView = [<span class="keyword">self</span> valueForKey:<span class="string">@"_barBackgroundView"</span>];</div><div class="line">    originView.backgroundColor = color;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从图中我们可以看出有个叫<code>_barBackgroundView</code>的<code>_UIBarBackground</code>对象，就它了。通过category去设置<code>_barBackgroundView</code>的背景色，貌似这样就能成功了。编译运行，结果大跌眼镜，并没有任何变化。猜想应该是内部在显示之前重置了<code>_barBackgroundView</code>的背景色，那就意味着此路不通，PASS。</p>
<p>第二种方案是在<code>_barBackgroundView</code>上面插入自定义的view，通过这个view来控制navigationbar的背景色。实现上在category中运行runtime机制将view与指定的key动态绑定，以便可以做更多扩展性的事情，比如QQ空间中<code>UIActivityView</code>加载等。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UINavigationBar+BackgroundColor.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UINavigationBar</span> (<span class="title">ZS_BackgroundColor</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> overlayKey;</div><div class="line"></div><div class="line">- (<span class="built_in">UIView</span> *)overlay&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;overlayKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setOverlay:(<span class="built_in">UIView</span> *)overlay&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;overlayKey, overlay, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setZS_BackgroundColor:(<span class="built_in">UIColor</span> *)backgroundColor&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.overlay) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// insert an overlay into the view hierarchy</span></div><div class="line">        <span class="keyword">self</span>.overlay = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">-20</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="keyword">self</span>.bounds.size.height + <span class="number">20</span>)];</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span> insertSubview:<span class="keyword">self</span>.overlay aboveSubview:[<span class="keyword">self</span> valueForKey:<span class="string">@"_barBackgroundView"</span>]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.overlay.backgroundColor = backgroundColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>设置编译运行，看看效果，没有问题，问题解决！</p>
<p><img src="/images/navigationbarColor/7.png" alt=""></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在<code>UINavigationbar</code>的视图层中插入自定义view是很好的解决方案，一方面不破坏视图结构，另一方面提供了更多的扩展性，例如下图QQ空间中的activityView。</p>
<p><img src="/images/navigationbarColor/8.png" alt=""></p>
]]></content>
    </entry>
    
  
  
</search>
