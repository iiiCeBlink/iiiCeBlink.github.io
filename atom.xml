<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iiiCeBlink</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-27T05:05:35.467Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iiiCeBlink</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探究 iOS 11 下的 UIDebuggingInformationOverlay</title>
    <link href="http://yoursite.com/2017/11/18/%E6%8E%A2%E7%A9%B6%20iOS%2011%20%E4%B8%8B%E7%9A%84%20UIDebuggingInformationOverlay/"/>
    <id>http://yoursite.com/2017/11/18/探究 iOS 11 下的 UIDebuggingInformationOverlay/</id>
    <published>2017-11-18T12:43:48.000Z</published>
    <updated>2018-08-27T05:05:35.467Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;自 iOS 9 以后，Apple 加入了悬浮窗调试工具，也就是 &lt;code&gt;UIDebuggingInformationOverlay&lt;/code&gt; 。利用它我们可以做到很多事情，例如：查看视图层级，控制器层级，页面中的变量，测量等等。那么我们如何开启这个调试工具呢？只需要添加如下的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; overlayClass = &lt;span class=&quot;type&quot;&gt;NSClassFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;UIDebuggingInformationOverlay&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;UIWindow&lt;/span&gt;.&lt;span class=&quot;type&quot;&gt;Type&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; = overlayClass?.perform(&lt;span class=&quot;type&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;prepareDebuggingOverlay&quot;&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; overlay = overlayClass?.perform(&lt;span class=&quot;type&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;overlay&quot;&lt;/span&gt;)).takeUnretainedValue() &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt;? &lt;span class=&quot;type&quot;&gt;UIWindow&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;_&lt;/span&gt; = overlay?.perform(&lt;span class=&quot;type&quot;&gt;NSSelectorFromString&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;toggleVisibility&quot;&lt;/span&gt;))&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码的实际意义可以转换成以下两行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;UIDebuggingInformationOverlay&lt;/span&gt; prepareDebuggingOverlay];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[[&lt;span class=&quot;built_in&quot;&gt;UIDebuggingInformationOverlay&lt;/span&gt; overlay] toggleVisibility];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;调用成功后，我们就能看到悬浮窗的庐山真面目了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Weak 属性在 dealloc() 背后的逻辑</title>
    <link href="http://yoursite.com/2017/10/04/Weak%20%E5%B1%9E%E6%80%A7%E5%9C%A8%20dealloc()%20%E8%83%8C%E5%90%8E%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    <id>http://yoursite.com/2017/10/04/Weak 属性在 dealloc() 背后的逻辑/</id>
    <published>2017-10-04T09:29:32.000Z</published>
    <updated>2018-08-27T05:05:28.364Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们都知道在 ARC 环境无论是强指针还是弱指针都无需在 &lt;code&gt;dealloc&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; ， ARC 会自动帮我们处理。然而，最近在项目中遇到这样一个问题，代码示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// class Foo&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)dealloc &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (_obj) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        [_obj removeObserver:[KVOObserverStub stub] forKeyPath:_keyPath];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;_obj&lt;/code&gt; 是类 &lt;code&gt;Foo&lt;/code&gt; 的 weak 属性，这段代码所做的工作是在 &lt;code&gt;Foo&lt;/code&gt; 的实例对象销毁的时候，移除 &lt;code&gt;_obj&lt;/code&gt; 对象上的观察者，否则，会导致 &lt;code&gt;KVO still registering when deallocated&lt;/code&gt; 的 crash 。原以为这样写会 work ，然而在实际测试中发现，在触发 &lt;code&gt;dealloc&lt;/code&gt; 方法时，&lt;code&gt;_obj&lt;/code&gt; 此时已被置为 &lt;code&gt;nil&lt;/code&gt; ，即 &lt;code&gt;[_obj removeObserver:[KVOObserverStub stub] forKeyPath:_keyPath];&lt;/code&gt; 并不会触发。解决方案则是将 &lt;code&gt;_obj&lt;/code&gt; 属性的修饰符由 &lt;code&gt;weak&lt;/code&gt; 改为 &lt;code&gt;unsafe_unretained&lt;/code&gt; 或者 &lt;code&gt;assign&lt;/code&gt; 。但是，这样改可能会为其他代码引入 bug ，因为现在 ARC 不会自动为将 &lt;code&gt;_obj&lt;/code&gt; 对象置为 &lt;code&gt;nil&lt;/code&gt; ，需要去检查涉及 &lt;code&gt;_obj&lt;/code&gt; 部分的代码。虽然这样解决问题了，但是，我还是对 &lt;code&gt;weak&lt;/code&gt; 属性在其持有对象的 &lt;code&gt;dealloc&lt;/code&gt; 方法触发时背后的逻辑很感兴趣。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（四）</title>
    <link href="http://yoursite.com/2016/10/10/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/10/CFNetwork学习笔记（四）/</id>
    <published>2016-10-10T08:46:53.000Z</published>
    <updated>2016-10-22T04:59:18.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要讲述用CFHTTPAuthentication API如何与HTTP认证服务器交互，如何找到合适的认证对象和证书并填入到HTTP请求中。一般而言，如果HTTP服务器给你的HTTP请求返回401或407，就意味着服务器是认证服务器并且要求证书。在CFHTTPAuthentication API中，每个证书集合都被存储在CFHTTPAuthentication对象中。因此，每个不同的认证服务器和连接到服务器的不同用户都需要存储在独立的CFHTTPAuthentication对象中。为了能与服务器进行通信，你需要将CFHTTPAuthentication存储到HTTP请求当中。后面会对这些步骤进行详细解释。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://yoursite.com/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（三）</title>
    <link href="http://yoursite.com/2016/10/07/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/07/CFNetwork学习笔记（三）/</id>
    <published>2016-10-07T06:39:12.000Z</published>
    <updated>2016-10-22T05:04:34.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍如何创建、发送和接收HTTP请求和响应。&lt;/p&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://yoursite.com/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（二）</title>
    <link href="http://yoursite.com/2016/10/06/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/06/CFNetwork学习笔记（二）/</id>
    <published>2016-10-06T12:50:01.000Z</published>
    <updated>2016-10-22T05:00:22.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要讨论如何创建、开启读写流并检查读写流上的错误。此外，还会介绍如何从读流中读出数据，如何向写流中写入数据，如何在读写的过程中防止发生阻塞，如何通过代理服务器来引导流。&lt;/p&gt;
&lt;p&gt;CFStream可以用来读写文件或者与socket一起工作。除了创建流的过程之外，它们其他的行为都很相似。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://yoursite.com/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（一）</title>
    <link href="http://yoursite.com/2016/10/05/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/05/CFNetwork学习笔记（一）/</id>
    <published>2016-10-05T04:36:19.000Z</published>
    <updated>2016-10-20T12:29:54.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;提到CFNetwork框架，首先想到的是当年号称“网络终结者”的ASIHTTPRequest。ASI的底层就是基于CFNetwork开发的，现如今用的最广泛的AFNetworking框架则是基于NSURLSession开发的，相比而言，CFNetwork比NSURLSession更底层，在性能方面理论上来说CFNetwork会更好。之前没怎么研究过CFNetwork，所以决定深入研究一下。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://yoursite.com/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>dumpdecrypted砸壳记录</title>
    <link href="http://yoursite.com/2016/10/03/dumpdecrypted%E7%A0%B8%E5%A3%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2016/10/03/dumpdecrypted砸壳记录/</id>
    <published>2016-10-03T02:14:41.000Z</published>
    <updated>2016-10-19T13:07:14.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一直采用Clutch对ipa包进行砸壳，后来发现Clutch在某些iOS版本下砸壳会失效，故而放弃了Clutch而采用dumpdecrypted。本篇文章就是记录用dumpdecrypted砸壳的过程以及其中的注意点。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;砸壳需要的东西：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stefanesser/dumpdecrypted&quot;&gt;dumpdecrypted&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;越狱的iOS设备&lt;/li&gt;
&lt;li&gt;OpenSSH（Cydia）&lt;/li&gt;
&lt;li&gt;iFile（Cydia）&lt;/li&gt;
&lt;li&gt;Cycript（Cydia）&lt;/li&gt;
&lt;li&gt;XCode&lt;/li&gt;
&lt;li&gt;Command Line Tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS OpenDev踩坑记录</title>
    <link href="http://yoursite.com/2016/09/20/iOS%20OpenDev%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2016/09/20/iOS OpenDev踩坑记录/</id>
    <published>2016-09-20T14:52:58.000Z</published>
    <updated>2016-10-15T14:53:24.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在研究iOS逆向工程，需要用到iOSDev工具，心想那就安装呗，多大点事儿。谁知道自己有点too young too simple，原以为下载完安装包再按步骤点点点就完了，谁知道到了最后一步，它给我来个安装失败。真是没有一点点防备啊，于是各种找办法解决安装问题，最终解决了，于是，决定把解决的过程写下来，方便以后回顾。&lt;br&gt;
    
    </summary>
    
      <category term="iOS逆向工程" scheme="http://yoursite.com/categories/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS APP砸壳小记</title>
    <link href="http://yoursite.com/2016/09/18/iOS%20APP%E7%A0%B8%E5%A3%B3%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/09/18/iOS APP砸壳小记/</id>
    <published>2016-09-18T01:07:15.000Z</published>
    <updated>2016-10-15T09:32:04.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在逆向工程中，砸壳是很必要并且不可缺少的一个步骤。所谓“壳”，其实就是苹果给应用加密的一层保护，我们只要是从APP Store上下载的APP都是带壳的。带壳的APP是无法进行class-dump以及hook等操作，因此，需要对APP进行砸壳。接下来，我以微信为例来进行砸壳。&lt;br&gt;
    
    </summary>
    
      <category term="iOS逆向工程" scheme="http://yoursite.com/categories/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS APP中调用私有方法</title>
    <link href="http://yoursite.com/2016/09/04/iOS%20APP%E4%B8%AD%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/04/iOS APP中调用私有方法/</id>
    <published>2016-09-04T15:08:43.000Z</published>
    <updated>2016-10-14T16:26:12.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;得益于苹果封闭的生态系统，iOS平台才能如此优秀和健壮。然而，对于开发者而言，开源永远是最受欢迎的，闭源只会让开发者束手束脚。我们在开发的过程中可能会遇到有需求需要依赖于iOS私有API，但由于iOS的封闭，我们无法直接调用私有方法，这让人很是头疼。那有没有方法能让我们在不越狱的情况下去调用私有API呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>拆解ARC下的self</title>
    <link href="http://yoursite.com/2016/08/24/%E6%8B%86%E8%A7%A3ARC%E4%B8%8B%E7%9A%84self/"/>
    <id>http://yoursite.com/2016/08/24/拆解ARC下的self/</id>
    <published>2016-08-24T13:23:28.000Z</published>
    <updated>2016-10-10T13:14:54.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究AFNetworking源码的过程中碰到了很多处地方用到了&lt;code&gt;weakSelf&lt;/code&gt;和&lt;code&gt;strongSelf&lt;/code&gt;。依据自己之前的理解，正常情况下使用&lt;code&gt;weakSelf&lt;/code&gt;是为了避免发生循环引用，而使用&lt;code&gt;strongSelf&lt;/code&gt;是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。&lt;/p&gt;
&lt;h3 id=&quot;self的本质&quot;&gt;&lt;a href=&quot;#self的本质&quot; class=&quot;headerlink&quot; title=&quot;self的本质&quot;&gt;&lt;/a&gt;self的本质&lt;/h3&gt;&lt;p&gt;self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是&lt;code&gt;const Class self&lt;/code&gt;，在实例方法中self是&lt;code&gt;Person const* self&lt;/code&gt;（以Person类举例）。事实确实如此么？来验证一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CallKit学习笔记</title>
    <link href="http://yoursite.com/2016/07/30/CallKit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/07/30/CallKit学习笔记/</id>
    <published>2016-07-30T02:21:17.000Z</published>
    <updated>2016-10-10T12:06:52.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;近几年4G大规模的普及使得VoIP（Voice over Internet Protocol）变得可靠和稳定。iOS 10开始全面支持VOIP，于是推出了&lt;code&gt;CallKit&lt;/code&gt;框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CallKit&lt;/code&gt;框架能让你的第三方VoIP应用程序获得原声应用程序的体验效果。为了能更好得讲述&lt;code&gt;CallKit&lt;/code&gt;新特性，我们以一个第三方VoIP应用程序——“Speakerbox”举例来说明。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10推送通知小记（下）</title>
    <link href="http://yoursite.com/2016/07/26/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/26/iOS 10推送通知小记（下）/</id>
    <published>2016-07-26T02:50:03.000Z</published>
    <updated>2016-09-24T16:37:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h3&gt;&lt;p&gt;在上一篇&lt;a href=&quot;http://zakariyyasv.pub/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;iOS 10推送通知小记（上）&lt;/a&gt;中，已经将iOS 10推送机制的改进以及原理讲完了。本篇文章的着重点放在心的推送框架&lt;code&gt;UserNotification.framework&lt;/code&gt;上面。&lt;/p&gt;
&lt;p&gt;先说说iOS 10之前的推送API中存在的问题。比如，本地推送和远程推送使用的是不同的回调方法但有可能回调方法中的代码是重复的。当你的app将通知发送给用户之后就没办法再去控制它了。为了解决这些问题，iOS 10推出了新的推送框架——&lt;code&gt;UserNotification.framework&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10推送通知小记（上）</title>
    <link href="http://yoursite.com/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/23/iOS 10推送通知小记（上）/</id>
    <published>2016-07-23T06:22:31.000Z</published>
    <updated>2016-09-22T12:30:30.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;最近在体验iOS 10Beta版的过程中，我发现iOS 10在锁屏界面的变动比较大，与之前的交互逻辑完全不同。与此同时，推送通知消息也有了改进，比如支持3D Touch，可以展示更多的信息，通知内容可以包含图片等等。按照逻辑推断iOS 10推送通知的API会有变化，于是，我赶紧查阅了Xcode 8Beta中的文档以及WWDC2016的视频，果然发现了玄机。&lt;/p&gt;
&lt;h3 id=&quot;推送机制&quot;&gt;&lt;a href=&quot;#推送机制&quot; class=&quot;headerlink&quot; title=&quot;推送机制&quot;&gt;&lt;/a&gt;推送机制&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10 UICollectionView新特性小记</title>
    <link href="http://yoursite.com/2016/07/18/iOS%2010%20UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/07/18/iOS 10 UICollectionView新特性小记/</id>
    <published>2016-07-18T06:36:31.000Z</published>
    <updated>2016-10-14T12:42:10.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;预览&quot;&gt;&lt;a href=&quot;#预览&quot; class=&quot;headerlink&quot; title=&quot;预览&quot;&gt;&lt;/a&gt;预览&lt;/h3&gt;&lt;p&gt;iOS 10对于UICollectionview的改进优化主要表现在以下三个方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;平滑的滑动体验&lt;/li&gt;
&lt;li&gt;self-sizing改进&lt;/li&gt;
&lt;li&gt;interactive reordering&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;平滑的滑动体验&quot;&gt;&lt;a href=&quot;#平滑的滑动体验&quot; class=&quot;headerlink&quot; title=&quot;平滑的滑动体验&quot;&gt;&lt;/a&gt;平滑的滑动体验&lt;/h3&gt;&lt;h5 id=&quot;1-卡顿的原因&quot;&gt;&lt;a href=&quot;#1-卡顿的原因&quot; class=&quot;headerlink&quot; title=&quot;1.卡顿的原因&quot;&gt;&lt;/a&gt;1.卡顿的原因&lt;/h5&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>H5游戏接入技术小结（下）</title>
    <link href="http://yoursite.com/2016/05/20/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/20/H5游戏接入技术小结（下）/</id>
    <published>2016-05-20T08:16:06.000Z</published>
    <updated>2016-10-14T12:09:36.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;在上一篇&lt;a href=&quot;http://zakariyyasv.pub/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;H5游戏接入技术小结（上）&lt;/a&gt;中，主要介绍了H5游戏资源的下载和运行。本篇文章主要是介绍app与H5游戏的交互以及在线与其他玩家对战的技术总结。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>H5游戏接入技术小结（上）</title>
    <link href="http://yoursite.com/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/17/H5游戏接入技术小结（上）/</id>
    <published>2016-05-17T08:17:55.000Z</published>
    <updated>2016-10-12T13:48:40.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;这段时间忙着做游戏平台H5游戏的接入，趁着刚做完还热乎劲儿，将其中的技术要点总结下来。H5游戏的接入主要分为两个部分：游戏的下载和游戏对战。本篇博客着重讲述游戏的下载部分，下篇博客将着重讲述H5游戏与app通过JS进行数据交互以及在线对战的技术要点。&lt;/p&gt;
&lt;p&gt;H5游戏资源本质上是由一些目录以及目录下的文件资源组成，要能够在app中运行H5游戏，就是要在&lt;code&gt;WKWebView&lt;/code&gt;的浏览器中用HTTPServer搭建本地服务，然后去加载游戏资源根目录下的index.html文件，换句话说index.html文件是游戏的入口文件。
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>庖丁解牛KVO（二）——KVO实现原理</title>
    <link href="http://yoursite.com/2016/04/23/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2016/04/23/庖丁解牛KVO（二）——KVO实现原理/</id>
    <published>2016-04-23T08:38:13.000Z</published>
    <updated>2016-10-10T11:58:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;在上一篇文章中，我们已经了解了KVO的使用场景以及使用方法。作为Objective-c中异常强大和重要的特性，我们有必要去了解和探索KVO底层的实现机制。&lt;/p&gt;
&lt;p&gt;KVO的实现机制到底是怎么样的呢？依据苹果官方文档的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Automatic key-value observing is implemented using a technique called isa-swizzling.&lt;/p&gt;
&lt;p&gt;The is a pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.&lt;/p&gt;
&lt;p&gt;When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.&lt;/p&gt;
&lt;p&gt;You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>庖丁解牛KVO（一）——KVO概览和使用</title>
    <link href="http://yoursite.com/2016/04/13/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94KVO%E6%A6%82%E8%A7%88%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/13/庖丁解牛KVO（一）——KVO概览和使用/</id>
    <published>2016-04-13T10:21:33.000Z</published>
    <updated>2016-10-10T11:58:26.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（&lt;code&gt;-bind:toObject:withKeyPath:options:&lt;/code&gt;）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。&lt;/p&gt;
&lt;p&gt;KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。&lt;/p&gt;
&lt;p&gt;在通知机制中，KVO与&lt;code&gt;NSNotification&lt;/code&gt;提供的通知机制类似，但是也存在很鲜明的区别。&lt;code&gt;NSNotification&lt;/code&gt;是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】UIScrollView实践小记——分页</title>
    <link href="http://yoursite.com/2016/03/21/UIScrollView%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5/"/>
    <id>http://yoursite.com/2016/03/21/UIScrollView实践小记——分页/</id>
    <published>2016-03-21T08:45:53.000Z</published>
    <updated>2017-03-29T10:06:14.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UIScrollView&lt;/code&gt;是iOS中很有意思也是最常用的控件之一，同时也是为数不多可以响应手势的UIKit控件。本篇文章主要研究的是&lt;code&gt;UIScrollView&lt;/code&gt;的分页实现。分页有多种实现方法，且各自的效果和优点各不相同，但它们都
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
