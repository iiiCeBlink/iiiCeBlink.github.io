<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zakariyyasv&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zakariyyasv.pub/"/>
  <updated>2016-10-22T04:59:18.000Z</updated>
  <id>http://zakariyyasv.pub/</id>
  
  <author>
    <name>zakariyyasv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CFNetwork学习笔记（四）</title>
    <link href="http://zakariyyasv.pub/2016/10/10/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/10/10/CFNetwork学习笔记（四）/</id>
    <published>2016-10-10T08:46:53.000Z</published>
    <updated>2016-10-22T04:59:18.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要讲述用CFHTTPAuthentication API如何与HTTP认证服务器交互，如何找到合适的认证对象和证书并填入到HTTP请求中。一般而言，如果HTTP服务器给你的HTTP请求返回401或407，就意味着服务器是认证服务器并且要求证书。在CFHTTPAuthentication API中，每个证书集合都被存储在CFHTTPAuthentication对象中。因此，每个不同的认证服务器和连接到服务器的不同用户都需要存储在独立的CFHTTPAuthentication对象中。为了能与服务器进行通信，你需要将CFHTTPAuthentication存储到HTTP请求当中。后面会对这些步骤进行详细解释。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://zakariyyasv.pub/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（三）</title>
    <link href="http://zakariyyasv.pub/2016/10/07/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/10/07/CFNetwork学习笔记（三）/</id>
    <published>2016-10-07T06:39:12.000Z</published>
    <updated>2016-10-22T05:04:33.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍如何创建、发送和接收HTTP请求和响应。&lt;/p&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://zakariyyasv.pub/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（二）</title>
    <link href="http://zakariyyasv.pub/2016/10/06/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/10/06/CFNetwork学习笔记（二）/</id>
    <published>2016-10-06T12:50:01.000Z</published>
    <updated>2016-10-22T05:00:22.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本篇文章主要讨论如何创建、开启读写流并检查读写流上的错误。此外，还会介绍如何从读流中读出数据，如何向写流中写入数据，如何在读写的过程中防止发生阻塞，如何通过代理服务器来引导流。&lt;/p&gt;
&lt;p&gt;CFStream可以用来读写文件或者与socket一起工作。除了创建流的过程之外，它们其他的行为都很相似。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://zakariyyasv.pub/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CFNetwork学习笔记（一）</title>
    <link href="http://zakariyyasv.pub/2016/10/05/CFNetwork%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/10/05/CFNetwork学习笔记（一）/</id>
    <published>2016-10-05T04:36:19.000Z</published>
    <updated>2016-10-20T12:29:53.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;提到CFNetwork框架，首先想到的是当年号称“网络终结者”的ASIHTTPRequest。ASI的底层就是基于CFNetwork开发的，现如今用的最广泛的AFNetworking框架则是基于NSURLSession开发的，相比而言，CFNetwork比NSURLSession更底层，在性能方面理论上来说CFNetwork会更好。之前没怎么研究过CFNetwork，所以决定深入研究一下。&lt;br&gt;
    
    </summary>
    
      <category term="MacOS" scheme="http://zakariyyasv.pub/categories/MacOS/"/>
    
    
  </entry>
  
  <entry>
    <title>dumpdecrypted砸壳记录</title>
    <link href="http://zakariyyasv.pub/2016/10/03/dumpdecrypted%E7%A0%B8%E5%A3%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://zakariyyasv.pub/2016/10/03/dumpdecrypted砸壳记录/</id>
    <published>2016-10-03T02:14:41.000Z</published>
    <updated>2016-10-19T13:07:14.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前一直采用Clutch对ipa包进行砸壳，后来发现Clutch在某些iOS版本下砸壳会失效，故而放弃了Clutch而采用dumpdecrypted。本篇文章就是记录用dumpdecrypted砸壳的过程以及其中的注意点。&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;砸壳需要的东西：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/stefanesser/dumpdecrypted&quot;&gt;dumpdecrypted&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;越狱的iOS设备&lt;/li&gt;
&lt;li&gt;OpenSSH（Cydia）&lt;/li&gt;
&lt;li&gt;iFile（Cydia）&lt;/li&gt;
&lt;li&gt;Cycript（Cydia）&lt;/li&gt;
&lt;li&gt;XCode&lt;/li&gt;
&lt;li&gt;Command Line Tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS OpenDev踩坑记录</title>
    <link href="http://zakariyyasv.pub/2016/09/20/iOS%20OpenDev%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://zakariyyasv.pub/2016/09/20/iOS OpenDev踩坑记录/</id>
    <published>2016-09-20T14:52:58.000Z</published>
    <updated>2016-10-15T14:53:23.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在研究iOS逆向工程，需要用到iOSDev工具，心想那就安装呗，多大点事儿。谁知道自己有点too young too simple，原以为下载完安装包再按步骤点点点就完了，谁知道到了最后一步，它给我来个安装失败。真是没有一点点防备啊，于是各种找办法解决安装问题，最终解决了，于是，决定把解决的过程写下来，方便以后回顾。&lt;br&gt;
    
    </summary>
    
      <category term="iOS逆向工程" scheme="http://zakariyyasv.pub/categories/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS APP砸壳小记</title>
    <link href="http://zakariyyasv.pub/2016/09/18/iOS%20APP%E7%A0%B8%E5%A3%B3%E5%B0%8F%E8%AE%B0/"/>
    <id>http://zakariyyasv.pub/2016/09/18/iOS APP砸壳小记/</id>
    <published>2016-09-18T01:07:15.000Z</published>
    <updated>2016-10-15T09:32:03.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在逆向工程中，砸壳是很必要并且不可缺少的一个步骤。所谓“壳”，其实就是苹果给应用加密的一层保护，我们只要是从APP Store上下载的APP都是带壳的。带壳的APP是无法进行class-dump以及hook等操作，因此，需要对APP进行砸壳。接下来，我以微信为例来进行砸壳。&lt;br&gt;
    
    </summary>
    
      <category term="iOS逆向工程" scheme="http://zakariyyasv.pub/categories/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS APP中调用私有方法</title>
    <link href="http://zakariyyasv.pub/2016/09/04/iOS%20APP%E4%B8%AD%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
    <id>http://zakariyyasv.pub/2016/09/04/iOS APP中调用私有方法/</id>
    <published>2016-09-04T15:08:43.000Z</published>
    <updated>2016-10-14T16:26:12.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;得益于苹果封闭的生态系统，iOS平台才能如此优秀和健壮。然而，对于开发者而言，开源永远是最受欢迎的，闭源只会让开发者束手束脚。我们在开发的过程中可能会遇到有需求需要依赖于iOS私有API，但由于iOS的封闭，我们无法直接调用私有方法，这让人很是头疼。那有没有方法能让我们在不越狱的情况下去调用私有API呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>拆解ARC下的self</title>
    <link href="http://zakariyyasv.pub/2016/08/24/%E6%8B%86%E8%A7%A3ARC%E4%B8%8B%E7%9A%84self/"/>
    <id>http://zakariyyasv.pub/2016/08/24/拆解ARC下的self/</id>
    <published>2016-08-24T13:23:28.000Z</published>
    <updated>2016-10-10T13:14:53.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究AFNetworking源码的过程中碰到了很多处地方用到了&lt;code&gt;weakSelf&lt;/code&gt;和&lt;code&gt;strongSelf&lt;/code&gt;。依据自己之前的理解，正常情况下使用&lt;code&gt;weakSelf&lt;/code&gt;是为了避免发生循环引用，而使用&lt;code&gt;strongSelf&lt;/code&gt;是为了避免方法还没有执行完成self已经被释放从而导致崩溃。不过为何在方法执行完成之前无法确保self不被释放却不是很明白，于是乎，自己花了些时间研究了一下。&lt;/p&gt;
&lt;h3 id=&quot;self的本质&quot;&gt;&lt;a href=&quot;#self的本质&quot; class=&quot;headerlink&quot; title=&quot;self的本质&quot;&gt;&lt;/a&gt;self的本质&lt;/h3&gt;&lt;p&gt;self是类的隐藏参数，在类方法中self指向当前调用方法的类，在实例方法中指向当前调用方法的类的init方法族生成的实例。更准确来说，在类方法中self是&lt;code&gt;const Class self&lt;/code&gt;，在实例方法中self是&lt;code&gt;Person const* self&lt;/code&gt;（以Person类举例）。事实确实如此么？来验证一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CallKit学习笔记</title>
    <link href="http://zakariyyasv.pub/2016/07/30/CallKit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zakariyyasv.pub/2016/07/30/CallKit学习笔记/</id>
    <published>2016-07-30T02:21:17.000Z</published>
    <updated>2016-10-10T12:06:51.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;近几年4G大规模的普及使得VoIP（Voice over Internet Protocol）变得可靠和稳定。iOS 10开始全面支持VOIP，于是推出了&lt;code&gt;CallKit&lt;/code&gt;框架。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CallKit&lt;/code&gt;框架能让你的第三方VoIP应用程序获得原声应用程序的体验效果。为了能更好得讲述&lt;code&gt;CallKit&lt;/code&gt;新特性，我们以一个第三方VoIP应用程序——“Speakerbox”举例来说明。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10推送通知小记（下）</title>
    <link href="http://zakariyyasv.pub/2016/07/26/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/07/26/iOS 10推送通知小记（下）/</id>
    <published>2016-07-26T02:50:03.000Z</published>
    <updated>2016-09-24T16:37:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h3&gt;&lt;p&gt;在上一篇&lt;a href=&quot;http://zakariyyasv.pub/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;iOS 10推送通知小记（上）&lt;/a&gt;中，已经将iOS 10推送机制的改进以及原理讲完了。本篇文章的着重点放在心的推送框架&lt;code&gt;UserNotification.framework&lt;/code&gt;上面。&lt;/p&gt;
&lt;p&gt;先说说iOS 10之前的推送API中存在的问题。比如，本地推送和远程推送使用的是不同的回调方法但有可能回调方法中的代码是重复的。当你的app将通知发送给用户之后就没办法再去控制它了。为了解决这些问题，iOS 10推出了新的推送框架——&lt;code&gt;UserNotification.framework&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10推送通知小记（上）</title>
    <link href="http://zakariyyasv.pub/2016/07/23/iOS%2010%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5%E5%B0%8F%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/07/23/iOS 10推送通知小记（上）/</id>
    <published>2016-07-23T06:22:31.000Z</published>
    <updated>2016-09-22T12:30:30.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;最近在体验iOS 10Beta版的过程中，我发现iOS 10在锁屏界面的变动比较大，与之前的交互逻辑完全不同。与此同时，推送通知消息也有了改进，比如支持3D Touch，可以展示更多的信息，通知内容可以包含图片等等。按照逻辑推断iOS 10推送通知的API会有变化，于是，我赶紧查阅了Xcode 8Beta中的文档以及WWDC2016的视频，果然发现了玄机。&lt;/p&gt;
&lt;h3 id=&quot;推送机制&quot;&gt;&lt;a href=&quot;#推送机制&quot; class=&quot;headerlink&quot; title=&quot;推送机制&quot;&gt;&lt;/a&gt;推送机制&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 10 UICollectionView新特性小记</title>
    <link href="http://zakariyyasv.pub/2016/07/18/iOS%2010%20UICollectionView%E6%96%B0%E7%89%B9%E6%80%A7%E5%B0%8F%E8%AE%B0/"/>
    <id>http://zakariyyasv.pub/2016/07/18/iOS 10 UICollectionView新特性小记/</id>
    <published>2016-07-18T06:36:31.000Z</published>
    <updated>2016-10-14T12:42:10.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;预览&quot;&gt;&lt;a href=&quot;#预览&quot; class=&quot;headerlink&quot; title=&quot;预览&quot;&gt;&lt;/a&gt;预览&lt;/h3&gt;&lt;p&gt;iOS 10对于UICollectionview的改进优化主要表现在以下三个方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;平滑的滑动体验&lt;/li&gt;
&lt;li&gt;self-sizing改进&lt;/li&gt;
&lt;li&gt;interactive reordering&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;平滑的滑动体验&quot;&gt;&lt;a href=&quot;#平滑的滑动体验&quot; class=&quot;headerlink&quot; title=&quot;平滑的滑动体验&quot;&gt;&lt;/a&gt;平滑的滑动体验&lt;/h3&gt;&lt;h5 id=&quot;1-卡顿的原因&quot;&gt;&lt;a href=&quot;#1-卡顿的原因&quot; class=&quot;headerlink&quot; title=&quot;1.卡顿的原因&quot;&gt;&lt;/a&gt;1.卡顿的原因&lt;/h5&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>H5游戏接入技术小结（下）</title>
    <link href="http://zakariyyasv.pub/2016/05/20/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/05/20/H5游戏接入技术小结（下）/</id>
    <published>2016-05-20T08:16:06.000Z</published>
    <updated>2016-10-14T12:09:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;在上一篇&lt;a href=&quot;http://zakariyyasv.pub/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/&quot;&gt;H5游戏接入技术小结（上）&lt;/a&gt;中，主要介绍了H5游戏资源的下载和运行。本篇文章主要是介绍app与H5游戏的交互以及在线与其他玩家对战的技术总结。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>H5游戏接入技术小结（上）</title>
    <link href="http://zakariyyasv.pub/2016/05/17/H5%E6%B8%B8%E6%88%8F%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://zakariyyasv.pub/2016/05/17/H5游戏接入技术小结（上）/</id>
    <published>2016-05-17T08:17:55.000Z</published>
    <updated>2016-10-12T13:48:39.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;这段时间忙着做游戏平台H5游戏的接入，趁着刚做完还热乎劲儿，将其中的技术要点总结下来。H5游戏的接入主要分为两个部分：游戏的下载和游戏对战。本篇博客着重讲述游戏的下载部分，下篇博客将着重讲述H5游戏与app通过JS进行数据交互以及在线对战的技术要点。&lt;/p&gt;
&lt;p&gt;H5游戏资源本质上是由一些目录以及目录下的文件资源组成，要能够在app中运行H5游戏，就是要在&lt;code&gt;WKWebView&lt;/code&gt;的浏览器中用HTTPServer搭建本地服务，然后去加载游戏资源根目录下的index.html文件，换句话说index.html文件是游戏的入口文件。
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>庖丁解牛KVO（二）——KVO实现原理</title>
    <link href="http://zakariyyasv.pub/2016/04/23/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94KVO%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://zakariyyasv.pub/2016/04/23/庖丁解牛KVO（二）——KVO实现原理/</id>
    <published>2016-04-23T08:38:13.000Z</published>
    <updated>2016-10-10T11:58:32.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h3&gt;&lt;p&gt;在上一篇文章中，我们已经了解了KVO的使用场景以及使用方法。作为Objective-c中异常强大和重要的特性，我们有必要去了解和探索KVO底层的实现机制。&lt;/p&gt;
&lt;p&gt;KVO的实现机制到底是怎么样的呢？依据苹果官方文档的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Automatic key-value observing is implemented using a technique called isa-swizzling.&lt;/p&gt;
&lt;p&gt;The is a pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.&lt;/p&gt;
&lt;p&gt;When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.&lt;/p&gt;
&lt;p&gt;You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>庖丁解牛KVO（一）——KVO概览和使用</title>
    <link href="http://zakariyyasv.pub/2016/04/13/%E5%BA%96%E4%B8%81%E8%A7%A3%E7%89%9BKVO%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94KVO%E6%A6%82%E8%A7%88%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://zakariyyasv.pub/2016/04/13/庖丁解牛KVO（一）——KVO概览和使用/</id>
    <published>2016-04-13T10:21:33.000Z</published>
    <updated>2016-10-10T11:58:25.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;KVO是对Objective-c观察者模式的实现，也是OC非常强大和有用的特性，同时还是实现cocoa bndings的基础（&lt;code&gt;-bind:toObject:withKeyPath:options:&lt;/code&gt;）。因此，理解和掌握KVO可以给我们带来很多便利以及意想不到的效果。&lt;/p&gt;
&lt;p&gt;KVO可以让观察者在被观察者的属性被修改时直接接收到通知。在KVO的作用下，一个对象可以观察另一个对象的任何属性，同时，也可以知道某个属性的修改前和修改后的值。对多关系的观察者不仅能知道改变发生的类型，而且还能知道哪些对象被改变了。&lt;/p&gt;
&lt;p&gt;在通知机制中，KVO与&lt;code&gt;NSNotification&lt;/code&gt;提供的通知机制类似，但是也存在很鲜明的区别。&lt;code&gt;NSNotification&lt;/code&gt;是以广播的形式将通知传递给所有注册为观察者的对象，即“一对多”，而KVO则会在属性值发生改变时直接将通知传递给观察者，即“点对点”。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac workflow小记</title>
    <link href="http://zakariyyasv.pub/2016/03/12/Mac%20workflow%E5%B0%8F%E8%AE%B0/"/>
    <id>http://zakariyyasv.pub/2016/03/12/Mac workflow小记/</id>
    <published>2016-03-12T12:11:39.000Z</published>
    <updated>2016-08-31T12:36:47.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Mac平台下做开发也有一段时间了，虽然说相对于windows平台而言，Mac下的软件资源并不如windows下的那么丰富，但是在适应以及找到合适的软件后，我觉得Mac对我而言更适合做开发。对于开发人员来说，效率至上是毋庸置疑的，因此，拥有一套提升效率的软件和工具对于开发人员来说是至关重要的。这篇博客就记录下我自己开发的workflow，也希望通过这篇博客能与他人分享。&lt;/p&gt;
&lt;h3 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot;&gt;Homebrew&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/workflow/homebrew.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Homebrew之于Mac的关系就跟apt之于Linux的关系是一样的，它实际上是Mac下的套件管理器。比如你想安装MySQL、git等等工具软件，都可以使用homebrew来下载和管理。&lt;br&gt;homebrew的安装也非常方便，你可以去到它的官网，根据提示进行安装。安装成功后就使用homebrew的命令去下载和管理你需要的工具软件了。&lt;br&gt;
    
    </summary>
    
      <category term="Mac相关" scheme="http://zakariyyasv.pub/categories/Mac%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解NSMapTable、NSHashTable、NSPointerArray</title>
    <link href="http://zakariyyasv.pub/2016/03/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3NSMapTable%E3%80%81NSHashTable%E3%80%81NSPointerArray/"/>
    <id>http://zakariyyasv.pub/2016/03/10/深入理解NSMapTable、NSHashTable、NSPointerArray/</id>
    <published>2016-03-10T02:19:45.000Z</published>
    <updated>2016-09-19T14:33:47.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习&lt;code&gt;YYCache&lt;/code&gt;中的&lt;code&gt;YYDiskCache&lt;/code&gt;时，注意到了这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// weak reference for all instances&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; *_globalInstances;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; dispatch_semaphore_t _globalInstancesLock;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _YYDiskCacheInitGlobal() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _globalInstancesLock = dispatch_semaphore_create(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        _globalInstances = [[&lt;span class=&quot;built_in&quot;&gt;NSMapTable&lt;/span&gt; alloc] initWithKeyOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsStrongMemory&lt;/span&gt; valueOptions:&lt;span class=&quot;built_in&quot;&gt;NSPointerFunctionsWeakMemory&lt;/span&gt; capacity:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; YYDiskCache *_YYDiskCacheGetGlobal(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *path) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (path.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _YYDiskCacheInitGlobal();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; cache = [_globalInstances objectForKey:path];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dispatch_semaphore_signal(_globalInstancesLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cache;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; _YYDiskCacheSetGlobal(YYDiskCache *cache) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cache.path.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    _YYDiskCacheInitGlobal();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [_globalInstances setObject:cache forKey:cache.path];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dispatch_semaphore_signal(_globalInstancesLock);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>YYCache源码学习</title>
    <link href="http://zakariyyasv.pub/2016/03/06/YYCache%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://zakariyyasv.pub/2016/03/06/YYCache源码学习/</id>
    <published>2016-03-06T06:17:28.000Z</published>
    <updated>2016-09-19T14:33:19.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章并不是对YYCache的设计思路的范范分析，而是对YYCache代码实现的详细分析。一方面YYCache的设计思路作者已经写得比较清楚了，我就没必要再多此一举了，有兴趣的可以到大神的博客去看&lt;a href=&quot;http://blog.ibireme.com/2015/10/26/yycache/&quot;&gt;YYCache 设计思路&lt;/a&gt;。从代码层面进行分析，一方面是因为很多思路上的东西很虚理解起来大都很容易，但是要能用代码实现却往往不那么轻松，另一方面是因为代码分析可以学习优秀代码的编码风格以及加深对iOS技术上的理解，这样做给自己带来的帮助或许会更多。&lt;/p&gt;
&lt;h2 id=&quot;代码结构&quot;&gt;&lt;a href=&quot;#代码结构&quot; class=&quot;headerlink&quot; title=&quot;代码结构&quot;&gt;&lt;/a&gt;代码结构&lt;/h2&gt;&lt;p&gt;YYCache文件数并不多，主要包含四个文件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;YYCache&lt;/li&gt;
&lt;li&gt;YYDiskCache  &lt;/li&gt;
&lt;li&gt;YYMemoryCache&lt;/li&gt;
&lt;li&gt;YYKVStorage&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://zakariyyasv.pub/categories/iOS/"/>
    
    
  </entry>
  
</feed>
